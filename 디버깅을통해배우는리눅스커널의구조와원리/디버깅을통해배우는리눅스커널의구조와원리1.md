# 01 리눅스 소개와 전망

**이번 장에서 다룰 내용**

* 리눅스는 왜 배워야 할까?
* 리눅스의 전망
* 임베디드 리눅스 개발 단체
* 임베디드 리눅스 개발자는 무엇을 알아야 할까?

2000년대 초반까지만 해도 리눅스는 교육용 혹은 서버에서만 사용하던 운영체제였다. 하지만 2020년을 맞이하는 현재, 리눅스는 광범위하게 사용되고 있으며, 그 저변은 계속 확대되고 있다.

## 1.1 리눅스 커널은 왜 배워야 할까?

리눅스 세미나에서 다음과 같은 질문을 종종 받곤 한다.

*리눅스를 배워야 하는 이유가 무엇인가요?*

이 질문은 특히 리눅스를 처음 접하는 분들이 많이 던지는 질문이었다. 이런 질문을 받고는 리눅스를 과연 왜 배워야 할까, 곰곰히 생각해봤다. 여러 생각 끝에 다음과 같은 결론을 내리게 됐다.

*소프트웨어 개발을 하려고 한다면 리눅스를 반드시 알아야 한다.*

그래서 이번 절에서는 먼저 리눅스를 왜 배워야 하는지 설명한다.

### 1.1.1 리눅스는 왜 배워야 할까?

최근 IT 직무 기술로 리눅스가 채택되어 IT 아카데미에서 '리눅스'를 교육 과정으로 운영하는 곳이 많다. 대학교 학부 과정에서도 리눅스 시스템 프로그래밍을 배울 수 있다. 또한 대학원 프로젝트 과제도 리눅스 환경에서 수행되는 경우가 많다. 이처럼 리눅스는 정규 교육 과정으로 잡아가는 듯 하다. 그런데 여러분은 리눅스를 왜 배워야 하는지 생각해본 적이 있는가? 그리 많지는 않을 텐데, 리눅스를 배우는 이유는 크게 다음과 같다.

첫째, 리눅스는 IT 산업 전반에서 쓰는 운영체제이다. 휴대폰, 클라우드 서버, 네트워크 장비는 물론 전기자동차와 IoT 디바이스까지 리눅스를 채택하고 있다.

둘째, 네트웤, 브라우저, WAS 웹 어플리케이션, 보안 유틸리티 등 수많은 프로그램이 리눅스 기반 환경에서 동작한다. 여러분이 리눅스를 알고 싶지 않고 리눅스 사용법을 알고 싶지 않을 수 있더라도 다양한 프로그램을 실행하고 운영하기 위해서는 리눅스를 알아야 한다.

셋째, 리눅스는 오픈소스 기반 운영체제이다. 리눅스는 하드웨어를 제어하는 리눅스 커널과 그 위에서 실행되는 리눅스 유틸리티로 구성돼 있다. 그런데 리눅스 커널은 물론이고 대부분 리눅스에서 실행되는 프로그램의 소스코드는 공개돼 있다.

구체적으로 다음과 같은 기술들이 리눅스 시스템 프로그램이나 리눅스 디바이스 드라어버에 구현돼 있고,

* 운영체제 핵심 기능
* 각종 보안 기술
* 네트워크 패킷 통신
* 각종 센서 드라이버
* 메모리 시스템
* CPU 아키텍쳐(ARM, x86) : 익셉션, 인터럽트, 메모리 관리
* 파일 시스템과 SD 카드

소스코드가 공개돼 있어서 소스코드를 분석함으로써 세부 동작 원리를 파악할 수 있다.

### 1.1.2 리눅스 커널은 왜 배워야 할까?

누군가가 '프로그래머로 일하려면 리눅스를 배워야 한다'라고 말한다면 대부분 수긍할 것이다. 하지만 '리눅스 커널도 배워야 한다'라고 주장한다면 바로 납득하기는 어려울 것이다. 이번에는 '리눅스 커널을 배워야 하는 이유'에 대해 이야기해보려고 한다.

이 책의 주제가 리눅스 커널이긴 하지만 필자는 솔직히 말씀드리고 싶다.

*반드시 리눅스 커널을 배울 필요는 없다.*

임배디드 리눅스나 리눅스 시스템을 개발할 때 '커널 소스'를 읽지 않고도 '리눅스 명령어'를 입력하고 '커널 로그'를 읽으면서 개발할 수도 있다. 커널에 대한 깊이 있는 지식 없이도 개발자로서의 경력을 유지할 수도 있다

하지만 필자는 다음과 같이 말씀드리고 싶다.

*리눅스 고급 개발자 또는 엔지니어로 실력을 인정바고 오랫동안 리눅스 개발을 하고 싶다면 리눅스 커널은 반드시 배워야 한다.*

그럼 '리눅스 커널'을 배워야 하는 이유를 더 자세히 알아보겠다.

첫째, 임베디드 리눅스 혹은 BSP(Board Support Package) 개발자로 디바이스 드라이버 개발을 맡고 있다면 리눅스 커널을 잘 알아야 한다. 그 이유는 간단하다.

*디바이스 드라이버는 커널 함수를 호출하는 방식으로 구현돼 있기 때문이다.*

C 프로그래밍을 잘 하려면 strcpy, strcmp, printf 같은 라이브러리 함수의 용법을 잘 알아야 하듯이 디바이스 드라이버 개발을 잘 하려면 커널이 제공하는 함수의 동작 원리를 파악하고 있어야 한다. 그래서 임베디드 리눅스 혹은 BSP 벤더에서는 '리눅스 커널'을 직무 교육 과정으로 운영하는 경우가 많다.

둘째, 고급 리눅스 시스템 프로그래머가 되려면 리눅스 커널을 알아야 한다.

리눅스 시스템 프로그램은 다음과 같은 함수로 구성돼 있다.

* open(), read(), write(), close() : 파일 처리 관련 함수
* fork(), getpid(), exit() : 프로세스 처리 관련 함수
* sigaction(), pause() : 시그널 처리 관련 함수

이러한 함수를 호출하면 리눅스 라이브러리 함수가 이를 처리할 것이라 생각할 수 있다. 하지만 실제로는 리눅스 라이브러리의 도움으로 POSIX 시스템 콜을 호출해 커널이 동작한다. 한 가지 예를 들어본다.

리눅스 시스템 프로그램으로 open(), read(), write() 함수를 호출했는데 함수에서 에러를 반환했다. 에러 코드를 반환한 주인공은 누구인가? 리눅스 라이브러리인가? 그 주인공은 바로 커널이다. 여기에는 그럴 만한 이유가 있다. 리눅스 시스템 프로그램을 실행하는 주체는 커널이기 때문이다. 따라서 커널을 배우면 리눅스 시스템 프로그램의 세부 동작 원리를 알 수 있다.

셋째, 운영체제의 핵심 원리를 소스코드 분석으로 배울 수 있다. 리눅스 커널은 오픈소스 프로젝트이므로 다음과 같은 커널의 핵심 구현 원리를 소스코드 분석을 통해 배울 수 있다.

* CPU 아키텍쳐(ARM, x86) : 익셉션, 인터럽트, 메모리 관리
* 스케쥴링
* 시스템 콜
* 시그널
* 가상 파일 시스템
* 메모리 관리

우리가 새로운 소프트웨어 기술을 배우는 과정은 크게 두 가지로 생각해볼 수 있다.

* 우선 프로그램을 사용해 본다.
* 코드를 작성하거나 소스코드를 분석해본다.

프로그램을 사용해 본 후 소스코드를 분석해서 구현 방식을 파악하면 더 많은 것을 배울 수 있다. 마찬가지로 커널도 이 방식으로 배울 수 있다. 즉, 커널 디버깅을 통해 '커널을 사용'해보고 커널 소스를 작성하면서 분석할 수 있다. 운영체제 커널을 이론만으로 공부하는 방법보다 더 빨리 실력이 늘 것이다.

넷째, IT 산업을 이루는 제반 기술의 세부 구현 방식을 알 수 있다. 파일 시스템, 메모리 관리, 네트워크, 이더넷 등의 기술들은 커널에서 소스코드로 만날 수 있다.

지금까지 설명한 '리눅스 커널을 배워야 하는 이유'를 한 문장으로 정리하면 다음과 같다.

*고급 리눅스 개발자가 되려면 커널을 배워야 한다.*

## 1.2 리눅스의 전망

이번 절에서는 먼저 일반적인 운영체제의 특징을 소개하고 리눅스 운영체제의 점유율을 확인하면서 리눅스의 전망을 알아본다.

### 1.2.1 운영체제란 무엇인가?

운영체제는 알게 모르게 우리 일상 생활의 일부가 된 지 오래이다. 가령 대학생들은 수강 신청을 컴퓨터로 하고 과제도 이메일로 제출한다. 사무직에 종사하는 분들은 대부분 컴퓨터로 일을 한다. 소프트웨어 개발자는 물론이고 다른 사무직에 종사하는 분들도 데스크톱 PC나 노트북으로 업무를 처리한다. 또한 대부분의 사람들이 휴대폰을 하나씩 가지고 다닌다.

그럼 사람들은 컴퓨터와 휴대폰으로 무엇을 하는가? 프로그램을 사용한다. 컴퓨터나 휴대폰으로 게임을 즐기거나 업무 처리를 위해 메일을 읽고 보내기도 한다. 브라우저로 인터넷 서핑을 하고 음악을 듣는다.

그런데 대부분의 사람들은 데스크톱 PC와 휴대폰에서 사용하는 프로그램이 모두 운영체제 위에서 실행되고 있다는 사실은 잘 모른다. 운영체제에는 관심이 없고 운영체제에서 실행되는 애플리케이션에만 관심이 있다. 자, 여기서 한 가지 질문을 해본다.

*여러분 중에서 운영체제를 직접 써 본 분이 있는가?*

대부분 이 질문을 받으면 황당하다고 느낄 것이다. 우리는 운영체제에서 실행되는 애플리케이션을 쓰는 것이지 운영체제를 직접 사용하지는 않는다.

이번에는 다음 그림을 보면서 운영체제가 무엇인지 알아본다.

![image-20240302200059842](C:\Users\jungs\AppData\Roaming\Typora\typora-user-images\image-20240302200059842.png)

보다시피 '운영체제'는 하드웨어와 응용 프로그램 사이에 있는 계층이다. 운영체제는 일반 사용자가 '스타크래프트'와 같은 게임이나 브라우저 프로그램이 잘 실행되는 기반 환경을 제공한다.

또한 운영체제는 세부 하드웨어를 관리하는 역할을 수행하는데, 이를 가리켜 '운영체제는 하드웨어를 가상화한다'라고 말한다. 사실 일반 사용자는 휴대폰이나 컴퓨터를 처음 고를 때 화면 크기, CPU 속도나 메모리 용량과 같은 기본적인 스펙에 관심을 기울인다. 하지만 막상 휴대폰이나 컴퓨터를 구입하고 나면 응용 프로그램만 사용하지 세부 하드웨어 부품이나 스펙(CPU 코어나 메모리 대역폭)에 대해 알려고 하지 않는다. 그 이유는 운영체제가 서로 다른 하드웨어 부품을 관리하는 역할을 수행하기 때문이다.

이처럼 일반 사용자는 운영체제에서 돌아가는 '게임'이나 '워드나 엑셀' 같은 응용 프로그램에 관심을 갖지 운영체제에는 관심이 없다. 당연한 이야기지만 '운영체제'에 관심을 둘 필요도 없다.

하지만 일반 사용자가 아닌 개발자인 경우에는 조금 상황이 다르다. 여러분이 작성하는 모든 코드를 실제로 실행하는 주체는 다음과 같이 운영체제 커널이다.

* 유저 애플리케이션 : 리눅스 표준 함수를 호출하면 시스템 콜을 통해 실제로 커널이 동작
* 디바이스 드라이버 : 디바이스 드라이버는 커널이 제공하는 함수를 사용하므로 실제 커널이 동작

따라서 개발자가 작성한 코드의 핵심 동작 원리를 파악하려면 운영체제의 핵심인 커널을 잘 알아야 한다.

여기까지 리눅스 운영 체제의 핵심인 커널을 잘 알아야 하는 이유를 설명했다. 그런데 이 부분까지 읽고 나면 한 가지 의문이 들 수 있다. "이렇게 운영체제의 커널이 중요하다면 학생들에게 이를 배울 기회를 줘야 하지 않을까?"

사실 컴퓨터 공학 관련 학과 전공 필수 과목으로 '운영체제'가 개설돼 있다. 이 책에서 설명하는 프로세스, 스케줄러, 메모리 관리와 같은 리눅스 커널의 개념들은 모두 운영체제 수업에서 다루는 내용이다. 그렇다면 교육 과정으로 운영체제가 개설돼 있다는 사실은 어떤 의미를 내포하는가? 운영체제는 미래의 프로그래머가 될 학생이 필수적으로 알아야 할 내용이라서 전공 수업으로 정하지 않았을까?

이어지는 절에서는 우리가 실행활에서 어떤 운영체제를 사용하고 있는지 살펴본다.

### 1.2.2 우리는 어떤 운영체제를 쓰고 있나?

우리가 알지 못하는 사이 리눅스는 우리 생활의 구석구석에 쓰이고 있다. 이번 절에서는 다음과 같은 분야에서 리눅스 운영체제가 차지하는 점유율을 알아본다.

* 데스크톱(개인용 컴퓨터)
* 모바일(휴대폰)
* 슈퍼 컴퓨터

#### 데스크톱(개인용 컴퓨터)

![image-20240302201215210](C:\Users\jungs\AppData\Roaming\Typora\typora-user-images\image-20240302201215210.png)

그래프의 가장 윗부분에 72~90%의 점유율을 보이는 운영체제가 마이크로소프트 '윈도우 NT 계열' 운영체제이다. 78%의 점유율로 부동의 1위를 지키고 있다. 그 다음으로는 iOS가 16%, 리눅스가 2%의 점유율을 보인다. 유닉스 계열 운영체제로 분류되는 IOS와 리눅스 운영체제를 합쳐도 15%밖에 되지 않는다.

> 보통 iOS와 리눅스를 합쳐 유닉스 계열 운영체제라고 부른다.

일반인이 많이 쓰는 데스크톱 PC 기기의 경우 리눅스의 점유율은 저조하다. 즉, '윈도우가 대세다'라고 말할 수 있다. 그래서 이 데이터를 보고 나면 이렇게 불평할 수도 있다.

*리눅스 운영체제는 거의 안 쓰는데 왜 배워야 할까?*

어느 정도 일리가 있는 의견이다. 운영체제를 쓰는 기기가 데스크톱 PC로 한정돼 있다면 말이다. 하지만 시선을 모바일 기기로 돌려보면 이야기가 달라진다.

![image-20240302201752182](C:\Users\jungs\AppData\Roaming\Typora\typora-user-images\image-20240302201752182.png)

그림 1.3에서 가장 위에 보이는 숫자를 보면 모바일 기기에서 리눅스 기반 안드로이드는 76%, 아이폰 등에서 쓰이는 iOS는 22%의 점유율을 보인다. 유닉스 계열로 분류되는 iOS와 안드로이드를 합친 점유율이 98%에 육박한다.

일상 생활의 필수품으로 자리잡은 휴대폰의 경우 유닉스 계열 운영체제가 시장을 지배하고 있다. 특히 안드로이드는 리눅스에서 가장 인기 있는 배포판으로, 많은 개발자들이 안드로이드 리눅스 개발에 참여하고 있다.

#### 슈퍼컴퓨터

이번에는 슈퍼컴퓨터에서 어떤 운영체제를 쓰고 있는지 알아본다. 그림 1.4는 슈퍼컴퓨터의 운영체제 점유율을 나타낸 것이다.

![image-20240302202117899](C:\Users\jungs\AppData\Roaming\Typora\typora-user-images\image-20240302202117899.png)

거의 100% 점유율로 슈퍼컴퓨터에서는 리눅스 운영체제를 쓰고 있다. 이 밖에 70% 이상의 웹 서버에서도 리눅스를 사용하고 있으며, 라우터나 태블릿 같은 IT 기기에서도 리눅스를 많이 사용하고 있다.

이번 절에서 다룬 내용을 정리하면 다음과 같다.

**데스크톱 PC를 제외한 모바일, 슈퍼컴퓨터를 포함한 기기에서는 리눅스 계열 운영체제를 많이 쓰고 있다.**

> 여기까지 우리의 실행활에서 리눅스란 운영체제를 얼마나 사용하는지 살펴봤다. 이번에는 이번 절에서 설명한 내용들을 뒷받침할 수 있는 신문(금융 IT) 기사 중 일부 내용을 소개한다.
>
> 리눅스 운영체제 배포판은 스마트 폰, TV, 디지털 비디오 레코더, 항공 엔터테인먼트 시스템, 자동차 제어 시스템, 라우터, 스위치 등에 적용됐다. 현재 어디서나 리눅스 커널 기반 시스템을 만날 수 있으니, 리눅스가 가장 지배적인 운영체제라고 볼 수 있다.
>
> 출처 : https://newsroom.koscom.co.kr/17371

## 1.3 리눅스의 역사

'무료 유닉스 계열 운영체제'를 표방하는 리눅스가 탄생하는 과정을 살펴보고 리눅스가 인기 있는 운영체제로 발전한 이유를 알아본다.

### 1.3.1 유닉스의 탄생

리눅스의 역사를 알기 위해서는 먼저 유닉스의 탄생 과정을 살펴볼 필요가 있다. 리눅스의 모태는 유닉스이기 때문이다.

컴퓨터가 발명된 후 컴퓨터는 한동안 한 가지 프로그램만 실행했다. 가령 음악 CD를 재생하는 컴퓨터가 있다고 하면 오직 CD만 재생하는 프로그램만 실행하는 식이다.

시간이 흘러 컴퓨터는 1개 이상의 프로그램을 실행할 수 있는 수준으로 컴퓨팅 속도가 빨라진다. 이런 상황에서 컴퓨터 공학자들은 뭔가 새로운 소프트웨어를 만들어 보려는 시도를 하게 되는데, 이 프로젝트가 바로 유닉스의 모태가 된 '멀틱스' 운영체제이다.

#### 멀틱스 운영체제

1965년 MIT, AT&T 벨 연구소, 제너럴 일렉트릭(General Electric) 소속 개발자들이 모여 멀틱스(Multics)라는 운영체제를 개발하기 시작했다. 이 중에는 '켄 톰슨'과 '데니스 리치' 같은 컴퓨터의 역사를 바꾼 전설적인 프로그래머도 있었다. 이들이 구현하고자 하는 운영체제의 핵심 기능은 다음과 같았다.

*멀티태스킹을 지원하는 운영체제를 구현하자!*

4차 산업혁명 시대를 맞이하는 현 시점에서 보면 멀티태크킹은 운영체제의 기본 기능이다. 하지만 1960년대 중반에는 혁신적인 기능이었다. 당시 소프트웨어 기술로는 한 개의 제품에서는 하나의 소프트웨어만 실행할 수 있는 수준이었기 때문이다.

여러 가지 노력에도 불구하고 멀틱스 운영체제는 목표를 이루지 못하고 좌초되고 만다. 하지만 멀틱스 프로젝트에 투입됐던 켄 톰슨과 다른 개발자들은 다음과 같은 목표를 위해 지속적으로 운영체제 연구에 몰두한다.

*멀티태스킹과 멀티 유저를 지원하는 운영체제를 개발하자.*

이 과정에서 탄생한 것이 바로 유닉서(UNIX)이다. 유닉스 운영체제는 어셈블리어를 사용해 구현했는데, PDP-7란 소형 컴퓨터에서만 실행됐기에 호환성이 없다고 볼 수 있었다. 그래서 다른 기종의 CPU가 탑재된 컴퓨터에서 유닉스를 쓰려면 해당 기종에 맞는 어셈블리어로 새롭게 코드를 작성해서 새로운 CPU 아키텍쳐에 맞는 유닉스 운영체제를 구현해야 했다. 다음과 같은 상황이다.

*드디어 유닉스 커널을 완성했다. 이제 이 어셈블리 코드를 다른 CPU 어셈블리 명령어로 바꿔서 유닉스 커널을 개발해 볼까?*

*전체 유닉스 커널 어셈블리 코드를 다른 CPU 아키텍쳐에서 구동하는 어셈블리 명령어로 바꾸라고?*

즉, 유닉스를 완성한 시점에서 모든 유닉스 어셈블리 코드를 새로운 CPU 아키텍처에 맞게 모두 바꿔야 했다.

현재 시점으로 바꿔서 x86 어셈블리 명령어로 구현된 리눅스의 전체 소스코드를 ARMv8 명령어로 '모두' 바꿔서 개발해야 하는 것과 동일하다.

#### 1973년 : 최초의 유닉스가 완성되다

유닉스의 호환성 문제를 개선하고자 데니스 리치는 아예 새로운 프로그래밍 언어를 개발하기로 결심한다. 이 프로그래밍 언어의 이름은 C 언어이다. C 언어 개발을 완성한 후 어셈블리 명령어로 구현됐던 유닉스를 C 언어로 작성해 새로운 버전의 유닉스를 개발하게 된다.

C 언어의 등장으로 유닉스 개발에 속도가 붙게 됐고, 이에 발맞춰 대학과 연구기관에 소속된 개발자들이 유닉스 기능을 구현하게 된다. 유닉스는 여러 기기에서 실행할 수 있는 호환성과 이식성을 갖추게 됐다. 시간이 흘러 유닉스는 제품으로 상용화할 수 있는 수준의 운영체제로 발전한다.

여기까지가 유닉스의 중반기 시절이다. 유닉스가 빠른 속도로 완성도가 높아진 이유는 무엇일까?

*첫째, 유닉스는 오픈소스로서 소스코드를 무료로 대학기관이나 연구소에 배포했다.*

처음에는 대학 기관에서 운영체제의 원리를 학습하고 연구하려는 목적으로 유닉스의 소스코드를 분석했다. 하지만 대학 기관과 연구소에 소속된 개발자들은 소스코드 분석에서 한걸음 나아가 유닉스 코드를 개선하면서 유닉스 프로젝트에 기여하게 됐다.

*둘째, C 언어의 도입으로 유닉스의 이식성과 호환성을 높였다.*

초창기 유닉스는 모든 소스를 어셈블리 명령어로 작성했다. 그래서 유닉스가 특정 CPU 아키텍쳐에서만 작동할 수 있었다. 그런데 데니스 리치가 만든 C 언어로 유닉스를 개발하면서 어셈블리 명령어에 비해 이식성과 호환성을 높일 수 있게 됐다.

유닉스는 발전을 거듭해 다양한 버클리 유닉스(Berkeley Unix; BSD), SYSV 계열로 분화되어 현재까지 리눅스와 더불어 다양한 유닉스 계열 운영체제가 사용되고 있다.

#### 1984년 : 유닉스 유료화에 대한 반발로 GNU 단체가 설립되다

앞에서 설명한 바와 같이 유닉스는 AT&T 회사의 벨 연구소에서 개발했다. 그러던 AT&T가 전화기를 비롯해 전자 및 컴퓨터 사업까지 사업 영역을 넓히다 보니 규모가 커졌다.

AT&T가 거대 기업이 되다 보니 모든 미국 졸업생은 AT&T로 몰려들게 되고 미국도 AT&T에 의존하게 됐다. 이런 상황에서 AT&T는 '반독점 소송'을 당하고 패소하게 된다. 1984년에 이르러 미국 법원은 다음과 같은 결정을 내린다.

*AT&T란 거대 기업을 7개 회사로 나누자.*

그 7개 회사 중에서도 지금도 유명한 버라이즌, 루슨트 등등이 있다. 이 과정에서 AT&T에 다음과 같은 판결을 내린다.

*AT&T는 컴퓨터 사업에 손 대지 말아라!*

미국 법원에서 이런 판결을 내리자 AT&T는 수년 동안 유닉스를 개발하고도 이를 컴퓨터 제품으로 만들 수 있는 개발 인프라를 구축할 수 없게 된다. 그래서 유닉스를 연구할 필요가 없어졌다. 그래서 AT&T는 유닉스를 돈을 받고 팔게 된다.

그런데 유닉스를 여러 회사에 팔다 보니 유닉스의 변종들이 생겨났다. 그래서 '유닉스에 대한 표준을 맞춰 보자'라고 해서 POSIX라는 규격이 만들어진다. 이후 여러 유닉스 벤더들은 POSIX 규약에 맞춰 호환성을 유지한 유닉스 제품을 개발하게 된다.

그런데 유닉스 개발에 참여했던 대학이나 연구기관은 더 이상 무료로 유닉스 소스코드를 볼 수 없게 됐다. 오로지 AT&T에게서 유닉스를 구매한 컴퓨터 업체의 개발자들만 유닉스 소스코드를 분석하면서 개발할 수 있게 된 것이다. 그래서 기존 유닉스 개발에 참여했던 연구원들은 불맞을 갖기 시작한다.

이런 유닉스의 유료화에 반기를 들고 새로운 무료 버전의 유닉스를 만들어보자는 움직임이 일어난다. 돈을 내고 유닉스를 만드는 것이 아니라 무료 버전의 유닉스를 개발하자는 목표로 다음과 같은 단체를 설립한다.

*GNU(GNU is not  UNIX) : GNU는 유닉스가 아니다.*

GNU라는 단체가 FSF(Free Software Foundation) 재단을 설립하면서 무료 유닉스 개발에 착수한다. GNU는 리처드 스톨만을 중심으로 설립됐는데 시간이 흘러 수백만 명이 참여하는 프로젝트로 규모가 커졌다. 그래서 유닉스 유틸리티와 같은 유닉스 기능을 다시 구현하게 됐는데 기존의 유닉스보다 더 완성도 높은 코드로 만들어지게 된다. 이처럼 유닉스 유틸리티를 하니씩 구현하면서 유닉스를 구성하는 소프트웨어를 만들기 시작한다.

유닉스라는 프로그램을 구조적 관점에서 보면 유닉스를 구동하는 핵심 코어인 유닉스 커널이 있고, 그 위에서 실행되는 유닉스 유틸리티가 있다. 유닉스 유틸리티는 여러 개발자들이 모여 어느 정도 완성도를 높여서 개발했다. 그런데 문제가 생겼다. 유닉스 커널을 제대로 만들기가 어렵다는 것이다. 그래서 한동안 유닉스 커널 개발이 정체된다.

#### 1992년 : AT&T와 BSD 간의 유닉스 소송

그런데 GNU에서만 무료 유닉스 개발을 시도한 것이 아니었다. 유닉스가 개발되던 초기에는 유닉스 코드를 대학 연구소에 배포했다. 그중 UC 버클리에 속한 BSD(Berkely Software Distribution) 개발자들이 기존 유닉스 코드를 재해석해서 1989년 후반 유닉스 커널을 포함한 무료 유닉스를 완성한다.

BSD 개발자는 AT&T에서 배포한 유닉스 코드를 다시 작성해서 'Net/1'이라는 이름으로 무료로 소스코드를 배포하게 된다. 이후 1991년에는 코드 완성도를 높여서 'Net/2'를 공개한다. 그런데 1992년 AT&T는 UC 버클리에 소송을 걸게 된다. 소송의 이유는 다음과 같다.

*AT&T 내부 자료를 이용해 배포한 BSD 유닉스인 Net/2는 AT&T의 저작권을 침해했다.*

1992년부터 시작된 AT&T와 BSD 간의 소송을 '유닉스 전쟁'이라고 부르기도 한다. 소송은 1994년까지 진행됐는데, AT&T USL(Unix Syste Laboratory)이 노벨에 팔린 후에 AT&T는 소송을 취하하게 된다.

소송이 진행되는 동안 US 버클리에서 BSD 유닉스 개발은 정체되고 만다.

### 1.3.2 1991년 : 리누스 토발즈의 등장

비슷한 시기에 무료 유닉스를 만들고자 하는 움직임이 있었다. 그 주인공은 리누스 토발즈이다. 핀란드의 헬싱키 대학에 재학 중이던 리누스 토발즈는 GNU 시스템에 적합한 커널을 직접 개발하기 시작해서 1991년 8월 25일 GNU 커널을 어느 정도 완성한 다음 comp.os.minix 라는 뉴스그룹에 다음과 같은 글을 올린다.

```
From: torvalds@klaava.Helsinki.FI (Linus Benedict Torvalds)
Newsgroups: comp.os.minix
Subject: What would you like to see most in minix?
Summary: small poll for my new operating system
Message-ID:
Data: 25 Aug 91 20:57:08 GMT
Organization: University of Helsinki

Hello everybody out there using minix -
I'm doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones. This has been brewing since april, and is starting to get ready. I'd like any feedback on things people like/dislike in minix, as my OS resembles it somewhat(same physical layout of the file-system (due to practical reasons) among other things).

I've currently ported bash(1.08) and gcc(1.40), and things seem to work. This implies that I'll get something practical within a few months, and I'd like to know what features most people would want. Any suggestions are welcom, but I won't promis I'll implement them :-)
```

위 글의 핵심은 다음과 같다.

*GNU 무료 운영체제를 개발 중인데, 인텔 칩 i386에서 구동된다.*

그런데 초기 버전인 0.01은 지금과 비교하면 정말 기본적인 커널 기능만 지원했다. 또한 실행도 되지 않았다. 그 후 0.02 공식 버전을 발표했는데, BASH(GNU Bourne Agin Shell)와 GCC(GNU C 컴파일러) 정도만 실행 가능한 수준이었다. 이듬해 3월, 리눅스는 0.95로 버전이 업그레이드됐고 다음과 같은 기능을 지원했다.

* 인텔 x86 칩에서 그래픽 사용자 인터페이스를 추가

그런데 그 당시 스톨만과 FSF 단체는 허드(Hurd)를 GNU 커널로 개발하고 있었다. 생각보다 허드 개발이 진척되지 않아 고민 끝에 다음과 같은 결정을 내린다.

*리누스 토발즈가 개발한 유닉스 커널을 GNU 커널로 채택하자.*

이 과정에서 탄생한 것이 리눅스이며, 기존 GNU 유틸리티와 커널이 결합해 GNU는 완성된 구조를 이루게 됐다.

#### 1.3.3 리눅스가 인기 있는 이유는 무엇일까?

GNU 리눅스 프로젝트에서 시작된 리눅스는 현재 가장 널리 쓰이는 운영체제로 발전했다. 그렇다면 리눅스가 윈도우와 함께 전 세계에서 쓰이는 이유는 무엇인가?

첫째, 누구나 소스코드를 볼 수 있다.

리눅스는 크게 리눅스 커널과 그 위에서 실행되는 리눅스 유틸리티로 구성돼 있다. 그런데 커널은 물론 리눅스를 구성하는 대부분의 유틸리티 프로그램은 오픈소스이다. 그래서 누구나 리눅스 커널과 리눅스 유틸리티 소스코드를 받아서 분석할 수 있다. 또한 소스코드를 누구나 읽을 수 있다는 것은 전 세계의 모든 개발자가 같은 조건에서 리눅스를 익힐 수 있다는 의미이다.

둘째, 개방적인 오픈소스 프로젝트다.

리눅스의 가장 큰 매력은 누구나 리눅스 프로젝트에 참가해 자신이 작성한 코드를 배포할 수 있다는 점이다. 리눅스 소스코드를 분석하다거나 버그나 논리적인 오류가 있으면 누구나 자신의 소스코드를 리눅스 오픈소스 프로젝트에 반영할 수 있다. 또는 가독성이 떨어지는 코드를 리팩터링(Refactoring)한 코드를 반영할 수도 있다.

누구나 소스코드를 볼 수 있을뿐더러 프로젝트에 기여할 수도 있으니 개방적인 옾느소스 프로젝트라고 말할 수 있다.

셋째, 리눅스 커뮤니티의 힘이 막강하다.

리눅스는 각 기능마다 메일링 리스트를 통해 전 세계 개발자들이 다음과 같은 주제로 치열한 토론을 벌인다.

* 커널 버그
* 커널 개선 패치

리눅스에 어떤 버그가 있으면 커뮤니티를 통해 빠른 시간 내 논의되며, 전 세계 개발자들이 서로 버그를 해결하는 패치를 제안하면 토론한다.

넷째, 다양한 CPU 아키텍쳐를 지원한다.

리눅스는 다양한 CPU 아키텍쳐를 지원하도록 설계돼 있다. CPU 아키텍쳐에 맞춰 리눅스를 빌드하면 리눅스를 실행할 수 있다.

## 1.4 리눅스는 어디에 쓰일까?

리눅스는 윈도우와 함께 우리의 일상 생활과 떼려야 뗄 수 없는 관계에 있는 운영체제입니다. 리눅스는 휴대폰, TV, 클라우드 서버에서 전기자동차에 이르기까지 곳곳에 쓰이고 있다. 4차 산업 혁명의 시대를 맞이해서 리눅스는 그 저변을 계속 확대하고 있다. 이번 절에서는 이처럼 우리 사회에 자리 잡은 리눅스란 운영체제를 어디에 쓰는지 좀 더 구체적으로 살펴본다.

### 1.4.1 안드로이드

리눅스는 휴대폰 운영체제로 이미 자리를 잡았다. 대표 주자인 안드로이드는 2010년부터 현재까지 스마트폰의 주력 운영체제로 쓰이고 있다. 

![image-20240302211737840](C:\Users\jungs\AppData\Roaming\Typora\typora-user-images\image-20240302211737840.png)

리눅스 커널은 안드로이드의 핵심 요소이다. 그림 1.5와 같이 안드로이드는 리눅스 커널 위에서 동작하므로 구글의 안드로이드 개발자는 리눅스 커널을 안드로이드 시나리오에 맞게 수정해서 쓰고 있다.

처음 휴대폰용으로 개발했던 안드로이드는 TV와 자동차용 플랫폼으로 영역을 확장하고 있다.

#### 자동차(AutoMotive)

리눅스는 휴대폰에서만 쓰는 운영체제가 아니다. 리눅스 저변은 휴대폰에서 자동차로 확대되고 있다.

최근에 전기자동차 시장이 열리면서 자동차 인포테인먼트(Infotainment) 분야에 리눅스 커널이 활발히 쓰이고 있다. 인포테인먼트란 자동차의 내비게이션 기능에서 운전자에게 제공하는 다양한 멀티 미디어 서비스를 의미한다.

제니비(GENIVI Alliance) 같은 자동차 기본의 인포테인먼트(IVI)와 커넥티비티 소프트웨어 플랫폼을 위한 단체가 설립됐으며 지속적으로 그 영역을 확대할 것으로 예상한다.

![image-20240302212234526](C:\Users\jungs\AppData\Roaming\Typora\typora-user-images\image-20240302212234526.png)

### 1.4.3 사물인터넷 디바이스

대부분의 IoT 및 임베디드 디바이스는 다양한 리눅스 상에서 구현되고 있다. 각종 센서와 전자 명함, 전자 메뉴판과 같은 더 많은 IoT 디바이스들이 앞으로 등장할 것이며, 이를 위해 리눅스 기술에 계속 관심이 모아질 것이다.

엔비디아나 인텔, 퀄컴 같은 대형 SoC 벤더들도 자사의 강점을 살려 IoT 시장에 뛰어들고 있다. IoT 임베디드 리눅스 개발을 위한 욕토 프로젝트(Yocto Project) 같은 단체가 만들어져서 다양한 리눅스 배포판 생성을 가능하게 하는 도구를 만들고 있다.

이 밖에도 TV, 클라우드 서버, 슈퍼컴퓨터 등 수많은 기기에서 리눅스 운영체제가 실행되고 있다. 앞으로 리눅스는 5G 및 AI 기술과 결합해 더 많이 활용될 것이라 예상한다. 

## 1.5 임베디드 리눅스 개발 단체

임베디드 리눅스는 여러 단체가 협업한 결과물이다. 각 단체의 역할을 알아본다.

### 1.5.1 리눅스 커널 커뮤니티

우리가 접하는 대부분의 리눅스 커널 코드는 리눅스 커널 커뮤니티에서 만들어진다. 리눅스 커널 커뮤니티는 리눅스 커널 개발의 심장으로서, 리눅스 커널 자체의 알고리즘을 비롯해 논리적 오류나 문제점을 개선하는 패치를 논의하고 관리한다.

* 버그 수정 패치
* 코드 리팩터링
* 신규 알고리즘
* 문서화

보통 2주 간격으로 그렉 크로아 하트만이라는 개발자가 메일로 전 세계 개발자들에게 패치 반영 사실을 통지한다.

리눅스 커널 버전과 코드 내역은 리눅스 커널 아카이브(https://www.kernel.org/) 사이트에서 확인할 수 있다.

![image-20240302213146708](C:\Users\jungs\Desktop\study\디버깅을통해배우는리눅스커널의구조와원리\assets\image-20240302213146708.png)

그림 1.8에서 왼쪽 부분을 보면 'longterm'으로 표시된 부분이 보인다. 이는 안정화된 리눅스 커널 버전을 의미한다. 이처럼 리눅스 커널 커뮤니티에서 관리하는 안정화된 리눅스 커널 버전을 LTS라고 부른다. 최신 리눅스 커널 버전에 적용된 버그 수정 패치는 LTS 리눅스 커널 버전에 꾸준히 반영된다.

SoC 업체들은 대부분 이 LTS 리눅스 커널 버전을 선택해 개발한다. 이 책에서 사용할 라즈비안 배포판도 LTS 리눅스 커널을 탑재했다.

### 1.5.2 CPU 벤더

리눅스 커널과 관련된 다른 주요 단체로 CPU 벤더가 있다. CPU 벤더는 CPU를 설계하는 회사를 뜻하며, 대표적인 업체는 다음과 같다.

* ARM(ARMv7/ARMV8)
* 인텔(x86)
* IBM(PowerPC)

CPU 벤더도 리눅스 커널 개발에 참여한다. 다음과 같은 리눅스 커널의 핵심 기능은 CPU에 따라 구현 방식이 다르기 때문이다.

* 시스템 콜
* 익셉션
* 컨텍스트 스위칭

![image-20240303013707834](C:\Users\jungs\Desktop\study\디버깅을통해배우는리눅스커널의구조와원리\assets\image-20240303013707834.png)

보다시피 리눅스 커널은 다양한 CPU 아키텍처와 함께 구동된다. 그런데 커널의 핵심 동작은 서로 다른 CPU 어셈블리 코드로 구현돼 있다. 컨텍스트 스위칭의 세부 동작은 x86이나 ARMv7 같은 CPU별로 구현 방식이 다르다.

리눅스의 구조는 위와 같은데 라즈비안과 같이 ARMv7 기반 리눅스 커널을 쓰려면 어떻게 해야 할까? ARMv7에 맞는 빌드 스크립트로 커널을 빌드하면 된다. 즉, 리눅스 커널은 다양한 CPU 아키텍처를 지원하는 소스 트리를 갖추고 있으며 사용하고자 하는 CPU 아키턱처에 맞춰 빌드하면 이에 맞는 커널 이미지를 생성할 수 있다.

### 1.5.3 SoC 벤더

SoC는 System-on-chip의 약자로 하나의 컴퓨터 또는 다른 전자 시스템들의 모든 구성 요소를 통합한 직접회로를 의미한다. SoC를 개발하는 업체인 브로드컴, 삼성전자, 퀄컴, 인텔, 미디어텍, 엔비디아 같은 회사를 SoC 벤터라고 부른다. 이들은 먼저 리눅스 커널 버전을 선택한다. 그리고 CPU 벤더로부터 툴 체인을 받아 자신의 SoC 스펙에 맞게 리눅스 커널 코드를 수정하거나 드라이버를 추가한다.

SoC 벤터에서 개발하는 제품명은 아래와 같다.

* 브로드컴 : BCM(bcm2837, 라즈베리 파이에 탑재)
* 삼성전자(시스템 LSI) : 엑시노스(Exynos)
* 퀄컴 : 스냅드래곤
* 인텔 : 아톰, 무어필드
* 미디어텍 : 헬리오
* 엔비디아 : 테그라

SoC 벤더에서 개발하는 리눅스의 전체 구조는 다음과 같다.

![image-20240303014411625](C:\Users\jungs\Desktop\study\디버깅을통해배우는리눅스커널의구조와원리\assets\image-20240303014411625.png)

그림 1.10에서 가장 오른쪽 윗부분 박스에서 볼 수 있듯이 리눅스 커널을 사용해 SoC 하드웨어를 제어하는 디바이스 드라이버를 작성한다. 예를 들면, 엔비디아 SoC와 퀄컴 SoC의 CPU(Graphics Processing Unit)는 자사의 SoC 하드웨어에 맞게 설계돼 있으니 서로 다른 디바이스 드라이버가 있는 것이다.

### 1.5.4 보드 벤더 및 OEM

보드 벤더와 OEM(Original Equipment Manufacturer) 업체는 SoC가 릴리즈한 리눅스 커널 코드를 받아 제품 스펙과 시나리오에 맞게 제품을 개발한다. 여기서 '보드 벤더 및 OEM'은 무엇을 의미하는가?

보드 벤더는 라즈베리 파이 재단과 같은 업체이고 OEM은 삼성전자, LG전자와 같이 상용 제품을 개발하는 업체를 뜻한다.

이해를 돕기 위해 한 가지 예스를 들어본다. 라즈베리 파이는 BCM2837이라는 SoC를 탑재한 교육용 보드이며 라즈베리 파이 재단에서 개발한다. 여기서 보드 벤더인 라즈베리 파이 재단은 SoC 벤더인 브로드컴이 릴리즈한 리눅스 커널 코드를 받아 라즈베리 파이의 스펙과 시나리오에 맞게 범용 보드로 개발하는 것이다.

많은 개발자들은 이 단계에서 SoC에서 제작한 리눅스 드라어버 코드(리눅스 커널 + SoC 드라이버)를 받아 임베디드 리눅스를 개발한다.

![image-20240303015026265](C:\Users\jungs\Desktop\study\디버깅을통해배우는리눅스커널의구조와원리\assets\image-20240303015026265.png)

제품마다 다양한 시나리오와 컨셉이 있을 수 있다. 만약 제품 컨셉이 카메라이면 카메라 센서를 제어하는 드라이버를 제작하고, 자동차 내비게이션이면 그래픽 드라이버를 개발할 것이다.

'보드 벤더 및 OEM' 개발자들은 이 과정에서 SoC 업체와 협업할 때가 많다. 만약 SoC 벤더에서 작성한 드라이버에서 버그를 확인하면 '보드 벤더 및 OEM' 업체는 버그를 리포트하고 개선 패치를 받아 수정하는 경우가 많다.

그런데 간혹 '보드 벤더 및 OEM' 업체의 개발자가 SoC 벤더에서 작성한 드라이버에 있는 버그를 직접 수정하는 경우가 있다. SoC 벤더에서 작성한 드라이버 코드는 리눅스 커널 소스코드와 함께 배포하므로 누구나 소스코드를 열어 볼 수 있다. 그래서 자신이 작성하지 않은 리눅스 드라이버 코드를 수정할 수 있는 것이다. 

## 1.6 임베디드 리눅스 개발을 잘 하려면 무엇을 알아야 할까?

좁게 보면 임베디드 리눅스 개발자가 알아야 할 지식은 다음과 같다.

* 디바이스 드라이버
* 리눅스 커널
* CPU 아키텍처
* SoC

조금 넓게 보면 다음과 같은 내용도 알면 좋다.

* 유저 공간 HAL(Hardware Abstraction Layer) 코드 구현
* 빌드 스크립트 구현
* 테스트용 디바이스 드라이버 구현
* Git과 형상 관리

### 1.6.1 디바이스 드라이버

임베디드 리눅스 개발을 시작하면 바로 디바이스 드라이버 업무를 맡는 경우가 많다. 물론 프로세스나 회사 규모에 따라 드라이버 개발 범위가 다르다. 제품을 구성하는 디바이스 드라이버의 특정 분야를 맡을 수도 있고, 한 명의 임베디드 개발자가 임베디드 리눅스를 책임지는 경우도 있다.

디바이스 드라이버의 시나리오와 제어하는 하드웨어의 종류는 다양하지만 다음 내용 정도는 알아야 한다.

* 인터럽트 핸들러 함수와 인터럽트를 처리하는 방식
* 디바이스 파일로 open/read/write 연산에 대한 함수를 등록하는 방법
* 디바이스 트리를 읽어 디바이스 속성을 저장하는 방식

디바이스 드라이버 코드를 빨리 읽고 이해하는 능력을 키우는 것도 중요하다.

### 1.6.2 리눅스 커널

디바이스 드라이버는 리눅스 커널에서 제공하는 함수로 구성돼 있다. 호출한 함수의 동작 방식을 알려면 자연히 리눅스 커널 코드를 분석할 수밖에 없다. "리눅스 디바이스 드라이버는 리눅스 커널 그 자체"라고 말하기도 한다.

또한 디바이스 드라이버를 개발하는 과정은 코드를 입력해 드라이버를 구현하는 데 그치지 않는다. 인증 테스트 부서를 통해 드라이버 안정화 테스트 과정을 거친다. 이 과정에서 다양한 버그나 문제 증상이 리포트된다. 카메라 디바이스의 경우 사진을 찍은 후 저장한 화면이 모두 검은색일 수도 있다. 또한 디바이스의 경우 화면이 깨질 수 있다. 이 과정에서 접하는 다양한 버그를 수정해 문제를 해결하기 위해서는 리눅스 커널을 잘 알아야 한다.

### 1.6.3 CPU 아키텍처

리눅스 커널의 핵심 개념들은 대부분 어셈블리 코드로 구현돼 있다. 그 이유는 리눅스 커널의 핵심 동작은CPu 아키텍처와 연관된 부분이 많기 때문이다. 예를 들면 다음과 같다.

* 컨텍스트 스위칭
* 익셉션 벡터
* 시스템 콜
* 시그널 핸들러
* 메모리 관리(MMU)

CPU 아키텍처 세부 동작 원리와 어셈블리 코드를 깊게 공부하기보다는 먼저 리눅스 시스템과 커널 로그, ftrace에 친숙해져야 한다.

그런데 리눅스 커널을 좀 더 깊게 알고자 하면 CPU 아키텍처(ARM, x86)에 대해 다음과 같은 내용을 알아야 한다.

* 어셈블리 언어
* 익셉션이 발생하는 원리와 익셉션 벡터의 세부 동작
* 함수 호출 규약(Calling Convention)

### 1.6.4 빌드 스크립트와 Git

앞에서 소개한 빌드 스크립트를 잘 이해하고Git(https://git-scm.com/)을 잘 다루면 효율적으로 개발할 수 있다. 다른 업체가 개발한 드라이버나 응용 프로그램을 현재 사용 중인 소스 트리에 추가해야 할 때가 있다. 이때를 대비해 빌드 스크립트와 빌드 구조를 잘 파악해두어야 한다. 

임베디드 및 BSP 리눅스 개발자가 갖춰야 할 기본 소양은 디바이스 드라이버와 커널에 대한 이해이다.

## 1.7 라즈베리 파이와 리눅스 커널

### 1.7.1 라즈베리 파이 실습 보드

라즈베리 파이 3 모델 B의 기본 하드웨어 스펙

* SoC : Broadcom BCM2837 SoC
* CPU : 1.2GHz ARM Cortex-A53 MP4
* GPU : Broadcom VideoCore 4 MP2 400 MHz
* 메모리 : 1GB LPDDR2
* SD카드 : Micro SD, push-pull type

### 1.7.2 리눅스 커널 버전

라즈비안 리눅스 커널의 코드는 라즈베리 파이 깃허브에서 확인할 수 있다.

* https://github.com/raspberrypi/linux/tree/rpi-4.19.y

라즈비안에서만 실행되는 디바이스 드라이버를 제외하고는 라즈비안 커널 소스는 리눅스 커널 커뮤니티 소스와 99% 같다. 

### 1.7.3 라즈비안 버전

### 1.7.4 ARM 아키텍처

## 1.8 정리

1. 리눅스 커널을 반드시 배워야 한다.
2. 리눅스는 광범위하게 사용되고 있으며, 그 저변은 계속 확대되고 있다.
3. 임베디드 리눅스 개발자들은 대부분 SoC 벤더에서 제공한 드라이버 코드를 토대로 제품을 개발한다.
4. 디바이스 드라이버, 리눅스 커널, CPU 아키텍처, 빌드 스크립트, Git을 기본적으로 알아야 한다.

# 02 라즈베리 파이 설정

이번 장에서 다룰 내용

* 라즈베리 파이 설치
* 라즈베리 파이에서 커널 빌드와 설치
* 바이너리 유틸리티 사용법
* 라즈베리 파이 사용 시 주의사항

라즈베리 파이에서 커널의 세부 동작을 알려주는 ftrace와 커널 로그를 열어 보면서 커널 동작을 디버깅하면 빠르게 리눅스 커널을 익힐 수 있다.

## 라즈베리 파이란?

실전 개발에서도 다양한 데모용 디바이스로 자주 활용되고 있다.

장점은 다음과 같다.

#### 막강한 커뮤니티

*"리눅스 교육용 보드는 라즈베리 파이가 대세다."*

#### 저렴한 가격

#### 간단한 설치

라즈베리 파이 커뮤니티에서는 라즈베리 파이를 구동할 수 있는 다양한 이미지를 배포한다.

#### 최신 리눅스 커널을 지원

라즈비안 리눅스 커널 버전이 안드로이드 리눅스 커널 버전보다 최신 버전이다. 이처럼 라즈비안은 상용 리눅스 제품보다 더 업그레이드된 리눅스 커널에서 작동한다.

## 2.2 라즈베리 파이 설정

### 2.2.1 라즈베리 파이 실습을 위한 준비물

### 2.2.2 라즈베리 파이 설치

#### 라즈비안 이미지 다운로드

#### 라즈비안 이미지를 굽는 방법

### 2.2.3 라즈베리 파이 기본 설정

## 2.3 라즈베리 파이 커널 빌드

### 2.3.2 라즈비안 커널 소스코드 내려받기

리눅스 유틸리티 프로그램 설치

```
sudo apt-get install git bc bison libssl-dev
```

라즈비안 최신 커널 소스 내려받기

```
sudo git clone --depth=1 https://github.com/raspberrypi/linux
```

브랜치 확인

```
git branch
```

### 2.3.3 라즈비안 리눅스 커널 빌드

아래 라즈베리 파이 홈페이지에 가면 커널을 빌드하는 방법을 확인할 수 있다.

* https://www.raspberrypi.org/documentation/linux/kernel/building.md

커널 빌드 설정

```
cd linux
KERNEL=kelnel7
make bcm2709_defconfig
```

본격적으로 커널 빌드 진행

```
make -j4 zImage modules dtbs
sudo make modules_install
sudo cp arch/arm/boot/dts/*.dtb /boot/
sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/
sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/
sudo cp arch/arm/boot/zImage /boot/$KERNEL.img
```

커널 빌드 스크립트 

***build_rpi_kernel.sh***

```sh

#!/bin/bash

echo "configure build output path"

KERNEL_TOP_PATH="$( cd "$(dirname "$0")" ; pwd -P )"
OUTPUT="$KERNEL_TOP_PATH/out"
echo "$OUTPUT"

KERNEL=kernel7
BUILD_LOG="$KERNEL_TOP_PATH/rpi_build_log.txt"

echo "move kernel source"
cd linux

echo "make defconfig"
make 0=$OUTPUT bcm2709_defconfig

echo "kernel build"
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

```

#!/bin/bash

echo "configure build output path"

KERNEL_TOP_PATH="$(pwd)"
OUTPUT="$KERNEL_TOP_PATH/out"
echo "$OUTPUT"

KERNEL=kernel7
BUILD_LOG="$KERNEL_TOP_PATH/rpi_build_log.txt"

echo "move kernel source"
cd linux

echo "make defconfig"
sudo make 0=$OUTPUT bcm2709_defconfig

echo "kernel build"
sudo make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```



파일에 실행 권한 부여

```
chmod +x build_rpi_kernel.sh
```

현재 작업 디렉토리를 KERNEL_TOP_PATH에 저장

```
KERNEL_TOP_PATH="$( cd "$(dirname "$0")" ; pwd -P )"
```

KERNEL_TOP_PATH 경로에 out 폴더를 추가해 OUTPUT이라는 셸 스크립트 변수에 저장

OUTPUT 변수는 "/home/pi/rpi_kernel_src/out" 으로 변경

```
OUTPUT="$KERNEL_TOP_PATH/out"
```

여기서 설정한 OUTPUT은 커널 컨피그와 커널 빌드 명령어에서 "0=$OUTPUT" 형식으로 사용

```
make 0=$OUTPUT bcm2709_defconfig
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

커널 컨피그 파일을 생성하는 코드

```
make 0=$OUTPUT bcm2709_defconfig
```

위 명령어는 bcm2709_defconfig 파일에 선언된 컨피그 파일을 참고해 .config 파일을 생성

```
/home/pi/rpi_kernel_src/out/.config
```

 리눅스 커널 소스 빌드 명령어

```
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

커널 빌드 로그 저장 코드

$KERNEL_TOP_PATH 디렉터리 안의 rpi_build_log.txt 라는 파일을 지정해 BUILD_LOG에 저장

```
BUILD_LOG="$KERNEL_TOP_PATH/rpi_build_log.txt"
...
make 0=$OUTPUT zImage modules dtbs -j4 2>&1 | tee $BUILD_LOG
```

>  명령어 tee - read from standard input and write to standard output and files

build_rpi_kernel.sh 스크립트로 커널 빌드

```
ojs@raspberrypi:/home/pi/rpi_kernel_src $ build_rpi_kernel.sh 
configure build output path
/home/pi/rpi_kernel_src/out
move kernel source
make defconfig
#
# configuration written to .config
#
kernel build
scripts/kconfig/conf  --syncconfig Kconfig
  CALL    scripts/checksyscalls.sh
  CHK     include/generated/compile.h
  GZIP    kernel/config_data.gz
  Kernel: arch/arm/boot/Image is ready
  Building modules, stage 2.
  Kernel: arch/arm/boot/zImage is ready
  MODPOST 1607 modules
```

만약 컴파일 에러가 발생한다면 반드시 리눅스 커널 코드를 수정한 다음 다시 커널 빌드를 해야 한다.

### 2.3.4 라즈비안 리눅스 커널 설치

커널 코드를 빌드만 해서는 수정한 코드가 라즈베리 파이에서 실행되지 않는다. 컴파일해 생성된 이미지를 라즈베리 파이에 설치해야 한다. 라즈비안 리눅스 커널을 빌드했으니 이제 빌드한 커널 이미지를 설치해본다. 다음은 라즈비안 이미지를 라즈베리 파이에 설치하는 셸 스크립트이다.

***install_rpi_kernel_img.sh***

```sh
#!/bin/bash

KERNEL_TOP_PATH="$(pwd)"
OUTPUT="$KERNEL_TOP_PATH/out"

echo "$OUTPUT"

cd linux

make 0=$OUTPUT modules_install
cp $OUTPUT/arch/arm/boot/dts/*.dtb /boot/
cp $OUTPUT/arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/
cp $OUTPUT/arch/arm/boot/dts/overlays/README /boot/overlays/
cp $OUTPUT/arch/arm/boot/zImage /boot/kernel7.img
```

install_rpi_kernel_img.sh 스크립트 실행

### 2.3.5 전처리 코드 생성

리눅스 커널을 캡슐화나 다형성과 같은 객체지향으로 구현하다 보니 매크로로 구현된 코드가 많다. 그런데 이 매크로가 소스 분석의 걸림돌 중 하나로 작용한다.

전처리 코드는 이러한 매크로를 모두 풀어서 표현한다. 따라서 훨씬 편하게 소스코드를 분석할 수 있으며, 리눅스 커널 코드를 분석할 때는 전처리 코드를 함께 본다.

전처리 코드는 GCC 컴파일 오브젝트를 생성하는 과정에서 추출된다. 커널에서 전처리 코드를 추출하는 방법은 크게 두 가지가 있다.

* 전체 전처리 파일을 추출
* 특정 전처리 파일을 추출

#### 전체 전처리 파일을 추출하는 방법

전처리 구문

```makefile
-save-temps=obj \
```

***/home/pi/rpi_kernel_src/linux/Makefile***  410L ~

```makefile
# Use LINUXINCLUDE when you must reference the include/ directory.
# Needed to be compatible with the O= option
LINUXINCLUDE    := \
		-I$(srctree)/arch/$(SRCARCH)/include \
		-I$(objtree)/arch/$(SRCARCH)/include/generated \
		$(if $(KBUILD_SRC), -I$(srctree)/include) \
		-I$(objtree)/include \
		$(USERINCLUDE)

KBUILD_AFLAGS   := -D__ASSEMBLY__
KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
		   -fno-strict-aliasing -fno-common -fshort-wchar \
		   -Werror-implicit-function-declaration \
		   -Wno-format-security \
		   -std=gnu89
```

-Wno-format-security \ 와 -std=gnu89 사이에 전처리 구문 삽입

```makefile
# Use LINUXINCLUDE when you must reference the include/ directory.
# Needed to be compatible with the O= option
LINUXINCLUDE    := \
		-I$(srctree)/arch/$(SRCARCH)/include \
		-I$(objtree)/arch/$(SRCARCH)/include/generated \
		$(if $(KBUILD_SRC), -I$(srctree)/include) \
		-I$(objtree)/include \
		$(USERINCLUDE)

KBUILD_AFLAGS   := -D__ASSEMBLY__
KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
		   -fno-strict-aliasing -fno-common -fshort-wchar \
		   -Werror-implicit-function-declaration \
		   -Wno-format-security \
		   -save-temps=obj \
		   -std=gnu89
```

저장 후 build_rpi_kernel.sh 스크립트 실행

그러면 전처리 코드가 out 폴더에 생성된다.

이후 전처리 코드가 어떻게 생성되었는지 확인해본다.

C 언어로 작성된 리눅스 커널 소스 파일은 다음 위치에서 전처리 파일로 생성된다.

```
linux/kernel/sched/core.c
out/kernel/sched/.tmp_core.i
```

