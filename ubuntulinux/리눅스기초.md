# 리눅스 기초

## 리눅스의 구조

* 커널

  : 프로세스 관리, 메모리 관리, 파일 시스템 관리, 장치 관리 등 컴퓨터의 모든 자원을 초기화, 모니터링, 제어하는 기능을 수행

* 셸

  : 리눅스의 사용자 인터페이스

  : 사용자와 커널 사이의 중간자 역할

  : 셸은 사용자가 입력한 명령을 해석하여 커널에 넘겨준다. 이후 커널은 명령의 수행 결과를 돌려주고 셸은 다시 사용자가 이해할 수 있는 형태로 바꿔 출력한다.

* 응용 프로그램

  : 각종 프로그래밍 개발 도구, 문서 편집 도구, 네트워크 관련 도구 등의 사용자 편의 기능 프로그램

## 리눅스 실습 환경 구축

리눅스 실습 환경은 다음과 같다. VMWare 등 가상환경으로 실습해도 되고 OS를 여러 개 설치한 듀얼부팅을 통해서도 실습해도 된다. 나의 경우에는 라즈베리파이를 통해 실습을 진행하였다. 라즈비안OS를 설치하는 과정은 생략하였다. 다만 해당 링크를 걸어둔다.

[라즈비안OS 설치 링크](https://www.robotstory.co.kr/raspberry/?board_page=6&vid=31)

| 하드웨어      | OS                             | 통신방식 | 코드 에디터 |
| ------------- | ------------------------------ | -------- | ----------- |
| 라즈베리파이3 | 라즈비안OS(우분투와 거의 동일) | SSH      | VSCode      |

실습 환경 구축은 다음과 같다.

1. VSCode 설치

   ![image-20240217212357709](.\assets\image-20240217212357709.png)

2. SSH 연결

   1. 라즈베리파이 SSH 설치

   ![image-20240217212710846](.\assets\image-20240217212710846.png)

   2. VSCode - Extension - Remote-SSH 설치

      ![image-20240217212849641](.\assets\image-20240217212849641.png)

   3. VSCode - F1키 or Ctrl + Shif + p - Remote-SSH: Open SSH Configuration File - 기본경로 - 설정파일 수정

      * Host : 사용할 이름(아무거나 지정)
      * HostName : 접속할 서버의 호스트이름 or ip
      * User : 접속할 서버의 사용자명
      * IdentityFile : pem키의 경로 및 파일명

      ![image-20240217213149768](.\assets\image-20240217213149768.png)

   4. VSCode - F1키 or Ctrl + Shift + p - Connect to Host - 지정한 호스트명

   5. 좌측 중간 모니터 아이콘 클릭 및 ssh 접속

      ![image-20240217213552261](.\assets\image-20240217213552261.png)

## 리눅스 명령 사용법

* 터미널 접속 해제 : exit, ^d
* 문자 지우기 : delete 키
* 단어 지우기 : ctrl + w
* 모두 지우기 : ctrl + u

### 명령의 구조

* 형식

  명령 [옵션] [인자]

  * 명령

    사용자가 리눅스에게 명령을 내리기 위해 사용하는 명령어

  * 옵션

    명령의 세부 기능 

  * 인자

    명령으로 전달되는 값

### 기초 명령 사용법

* date 명령

  * 날짜와 시간을 출력
  * date

* clear 명령

  * 화면을 지운다.
  * clear

* man

  * 명령 사용 방법을 화면에 출력한다.
  * man [명령]

* passwd 

  * 사용자 계정의 비밀번호 변경

    passwd [사용자]

# 디렉터리와 파일 사용법

* 리눅스 파일의 종류와 특징
* 디렉터리 계층 구조
* 절대 경로명과 상대 경로명
* 디렉터리 이동, 디렉터리 내용 확인
* 디렉터리 생성, 삭제
* 파일 내용 확인
* 파일 복사/이동/삭제
* 파일 링크의 특징
* 하드 링크, 심볼릭 링크 생성
* 파일의 내용과 위치 검색

## 리눅스 파일과 디렉터리

### 파일의 종류

* 일반 파일

  : 각종 텍스트 파일, 실행 파일, 이미지 파일 등

  : 실행 파일이나 이미지 파일의 경우 바이너리 형태로 저장(바이너리 파일은 특정 응용 프로그램이 있어야 해당 내용을 확인할 수 있다)

* 디렉터리

  : 파일의 목록 관리 파일

* 심볼릭 링크

  : 원본 파일을 대신하도록 원본 파일을 다른 파일명으로 지정한 것(윈도의 바로가기 파일)

* 장치 파일

  : 리눅스에서는 각종 장치도 파일로 취급한다.

  : 장치 파일은 리눅스 시스템에 부착된 장치들을 관리하기 위한 특수 파일이다.

  : 대부분의 장치 파일은 /dev 디렉터리 아래에 위치

### 디렉터리의 계층 구조

리눅스에서는 파일을 효율적으로 관리하기 위해 디렉터리를 계층적으로 구성하는데 이를 트리(tree) 구조라고 한다.

리눅스의 모든 디렉터리의 출발점은 루트(root) 디렉터리이다. 루트 디렉터리는 / 로 표시한다.

### 리눅스 디렉터리의 계층 구조 및 기능

**디렉터리의 계층 구조**

![image-20240217223553877](.\assets\image-20240217223553877.png)

**디렉터리의 주요 기능**

| 디렉터리   | 기능                                                         |
| ---------- | ------------------------------------------------------------ |
| dev        | 장치 파일이 담긴 디렉터리<br />![image-20240224004726978](.\assets\image-20240224004726978.png) |
| home       | 사용자 홈 디렉터리<br />![image-20240224004758246](.\assets\image-20240224004758246.png) |
| media      | DVD/CD나 USB 같은 외부 장치를 연결(마운트라고 한다)하는 디렉터리<br />![image-20240224004815278](.\assets\image-20240224004815278.png) |
| opt        | 추가 패키지가 설치되는 디렉터리<br />![image-20240224004831980](.\assets\image-20240224004831980.png) |
| root       | root 계정의 홈 디렉터리, 루트(/) 디렉터리와는 다른 것이므로 혼동X<br />![image-20240224004935006](.\assets\image-20240224004935006.png) |
| sys        | 리눅스 커널과 관련된 파일이 있는 디렉터리<br />![image-20240224004951936](.\assets\image-20240224004951936.png) |
| usr        | 기본 실행 파일, 라이브러리 파일, 헤더 파일 등 이 있다. usr는 'Unix System Resource'의 약자<br />![image-20240224005008762](.\assets\image-20240224005008762.png) |
| boot       | 부팅에 필요한 커널 파일을 가지고 있다.<br />![image-20240224005034518](.\assets\image-20240224005034518.png) |
| etc        | 리눅스 설정을 위한 각종 파일을 가지고 있다.<br />![image-20240224005158575](.\assets\image-20240224005158575.png) |
| lost+found | 파일 시스템에 문제가 발생하여 복구할 경우, 문제가 되는 파일이 저장되는 디렉터리로 보통은 비어 있다.<br />![image-20240224005238806](.\assets\image-20240224005238806.png) |
| mnt        | 파일 시스템을 임시로 마운트하는 디렉터리<br />![image-20240224005300413](.\assets\image-20240224005300413.png) |
| proc       | 프로세스 정보 등 커널 관련 정보가 저장되는 디렉터리<br />![image-20240224005318878](.\assets\image-20240224005318878.png) |
| run        | 실행 중인 서비스와 관련된 파일이 저장<br />![image-20240224005340968](.\assets\image-20240224005340968.png) |
| srv        | FTP나 Web 등 시스템에 제공하는 서비스의 데이터가 저장된다.<br />![image-20240224005407110](.\assets\image-20240224005407110.png) |
| tmp        | 시스템 사용 중에 발생하는 임시 데이터가 저장된다. 이 디렉터리에 있는 파일은 재시작하면 모두 삭제된다.<br />![image-20240224005424048](.\assets\image-20240224005424048.png) |
| var        | 시스템 운영 중에 발생하는 데이터나 로그 등 내용이 자주 바뀌는 파일이 주로 저장된다.<br />![image-20240224005434944](.\assets\image-20240224005434944.png) |



### 절대 경로명과 상대 경로명

경로명에서 가장 앞에 있는 /는 루트 디렉터리를, 중간의 /는 구분자로 사용된다.

**※ 절대 경로명과 상대 경로명의 특징**

| 구분        | 특징                                                         |
| ----------- | ------------------------------------------------------------ |
| 절대 경로명 | 루트 디렉터리가 기준이 된다.<br />ex) /home/Desktop/test.txt |
| 상대 경로명 | 현재 디렉터리가 기준이 된다.<br />ex) ../../etc/hosts        |

## 디렉터리 관련 명령

### 현재 디렉터리 확인 : pwd

### 디렉터리 이동 : cd

### 디렉터리 내용 확인 : ls

| 옵션                 | 설명                                                      |
| -------------------- | --------------------------------------------------------- |
| -a(all)              | 숨김 파일을 포함하여 모든 파일 목록                       |
| -d(directory)        | 디렉터리 자체의 정보<br />-ld 로 써야 자체 정보가 나온다. |
| -i(inode)            | inode 번호                                                |
| -l(long list format) | 파일의 상세 정보                                          |
| -A(almost all)       | .와 ..를 제외한 모든 파일 목록                            |
| -F(classify)         | 파일의 종류(* 실행파일, / 디렉터리, @ 심볼릭 링크)        |
| -L(dereference)      | 심볼릭 링크 파일의 경우 원본 파일의 정보 출               |
| -R(recursive)        | 하위 디렉터리의 목록까지 출력                             |
| -h(human readable)   | with -l and -s, print sizes like 1K 234M 2G etc.          |
| -S(sort)             | sort by file size, largest first                          |
| -t(time)             | sort by time, newest first; see --time                    |

**파일의 상세 정보**

ex) drwxr-xr-x 2 root root 4096 Feb 17 22:39 watchdog 

| 필드 값      | 의미                                                         |
| ------------ | ------------------------------------------------------------ |
| d            | 다음과 같은 파일 종류를 나타낸다.<br />- : 일반 파일<br />d : 디렉터리 파일<br />l : 심볼릭 링크 파일<br />b : 블록 단위로 읽고 쓰는 블록 장치 파일<br />c : 섹터 단위로 읽고 쓰는 문자 장치 파일<br />p : 파이프 파일(프로세스 간 통신에 사용되는 특수 파일)<br />s : 소켓(네트워크 통신에 사용되는 특수 파일) |
| rwxr-xr-x    | 파일의 사용자에 따른 접근 권한                               |
| 2            | 하드 링크의 개수                                             |
| root         | 파일 소유자                                                  |
| root         | 파일이 속한 그룹                                             |
| 4096         | 파일 크기(바이트 단위)                                       |
| Feb 17 22:39 | 파일이 마지막으로 수정된 시간                                |
| watchdog     | 파일명                                                       |

이밖에도 파일이 있는지 없는지 확인하는 용도로도 사용이 된다.

ex) ls .bashrc

### 디렉터리 생성 : mkdir

| 옵션 | 설명                                                   |
| ---- | ------------------------------------------------------ |
| -p   | 중간 단계의 디렉터리를 생성하고 지정한 디렉터리를 생성 |

**디렉터리 여러 개 만들기**

![image-20240217234741682](.\assets\image-20240217234741682.png)

**중간 디렉터리 자동으로 만들기 : -p**

![image-20240217234925912](.\assets\image-20240217234925912.png)

### 디렉터리 삭제 : rmdir

| 옵션 | 설명                                                         |
| ---- | ------------------------------------------------------------ |
| -p   | 지정한 디렉터리를 삭제하고 그 디렉터리의 부모 디렉터리가 빈 디렉터리일 경우 부모 디렉터리도 삭제 |

## 파일 관련 명령

### 파일 내용 출력

**cat : 파일 내용 연속 출력**

| 옵션 | 설명                  |
| ---- | --------------------- |
| -n   | 행 번호를 붙여서 출력 |

**more : 파일 내용 화면 단위 출력**

| 옵션     | 설명                       |
| -------- | -------------------------- |
| +행 번호 | 출력을 시작할 행 번호 지정 |

**less : 파일 내용 화면 단위 출력**

**tail : 파일 내용의 뒷부분 출력**

| 옵션     | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| +행 번호 | 지정한 행부터 끝까지 출력                                    |
| -숫자    | 화면에 출력할 행의 수를 지정(기본값은 10)                    |
| -f       | 파일 출력을 종료하지 않고 주기적으로 계속 출력한다(파일 내용의 변화를 확인할 때 편리). |

### cp : 파일 복사

| 옵션   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| -i     | 파일2가 이미 존재하면 덮어쓸 것인지 물어본다.                |
| -r, -R | 디렉터리를 재귀적으로 복사한다. 만약 소유자, 퍼미션까지 원본과 동일하게 복사하려면 -a를 사용한다. |

### mv : 파일 이동과 파일명 변경

| 옵션 | 설명                                             |
| ---- | ------------------------------------------------ |
| -i   | 동일명의 파일이 존재하면 덮어쓸 것인지 물어본다. |

### rm : 파일 삭제

| 옵션 | 설명                            |
| ---- | ------------------------------- |
| -i   | 파일을 삭제할 것인지 확인한다.  |
| -r   | 디렉터리를 재귀적으로 삭제한다. |

### 파일 링크

파일의 구성 : 파일명 + inode + 데이터 블록

* 파일명 : 사용자가 파일에 접근할 때 사용하는 파일 이름
* inode : 파일 정보가 담긴 구조체이다. 외부적으로는 번호로 표시되고 내부적으로는 파일의 종류와 크기, 소유자, 파일 변경 시간, 파일명 등 파일 상세 정보와 데이터 블록 주소가 저장되어 있다.
* 데이터 블록 : 

### ln : 하드 링크 만들기

| 옵션 | 설명                  |
| ---- | --------------------- |
| -s   | 심볼릭 링크 파일 생성 |

### touch : 빈 파일 만들기, 접근/수정 시간 변경하기

| 옵션                     | 설명             |
| ------------------------ | ---------------- |
| -a                       | 접근 시간만 변경 |
| -m                       | 수정 시간만 변경 |
| -t [[CC]YY]MMDDhhmm[.ss] | 시간을 직접 입력 |

### grep : 파일 내용 검색

| 옵션 | 설명                               |
| ---- | ---------------------------------- |
| -i   | 대소문자를 모두 검색               |
| -l   | 지정한 패턴이 포함된 파일명을 출력 |
| -n   | 행 번호를 출력                     |

### find : 파일 찾기

* 형식 : find [경로] [검색 조건] [동작]
* 검색 조건
  * -name filename : 파일명으로 검색한다.
  * -type 파일 종류 : 파일 종류로 검색한다.
  * -user loginID : 지정한 사용자가 소유한 모든 파일을 검색한다.
  * -perm 접근 권한 : 지정한 사용 권한과 일치하는 파일을 검색한다.
* 동작
  * -exec 명령 {} \; : 검색된 파일에 명령을 실행한다.
  * -ok 명령 {} \; : 사용자의 확인을 받아서 명령을 실행한다.
  * -print : 검색된 파일의 절대 경로명을 화면에 출력한다(기본 동작).
  * -ls : 검색 결과를 긴 목록 형식으로 출력한다.

### whereis : 명령의 위치 찾기

| 옵션 | 설명                 |
| ---- | -------------------- |
| -b   | 바이너리 파일만 검색 |
| -m   | 메뉴얼 파일만 검색   |
| -s   | 소스 파일만 검색     |

### which : 명령의 위치 찾기

# 문서 편집

## vi 사용법

### vi 동작 모드

![image-20240218203005425](.\assets\image-20240218203005425.png)

**vi 파일 저장 및 종료**

| 명령키          | 기능                                                         |
| --------------- | ------------------------------------------------------------ |
| :q              | 작업한 내용을 저장하지 않고 종료                             |
| :q!             | 작업한 내용을 저장하지 않고 종료                             |
| :w or :w 파일명 | 작업한 내용을 저장만 한다. 파일명을 지정하면 다른 파일로 저장한다. |
| :wq, :wq!       | 작업한 내용을 저장하고 종료                                  |
| ZZ(shift + zz)  | 작업한 내용을 저장하고 종료                                  |

### vi 모드 전환

| 명령키      | 기능             |
| ----------- | ---------------- |
| i           | 현재 자리        |
| a           | 다음 자리        |
| o           | 다음 행          |
| I(대문자 i) | 행의 첫 칼럼     |
| A           | 행의 마지막 칼럼 |
| O           | 행의 이전 행     |

### 커서와 화면 이동

| 명령키         | 기능                      |
| -------------- | ------------------------- |
| k / j          | 위 / 아래                 |
| l / h          | 오른쪽 / 왼쪽             |
| 0 / $          | 현재 행의 처음 / 마지막   |
| - / + or Enter | 앞 / 다음 행의 처음       |
| H / M / L      | 맨 위 / 중간 / 맨 아래    |
| w / e          | 다음 단어의 처음 / 마지막 |
| b              | 앞 단어의 첫 글자         |

| 명령키 | 기능           |
| ------ | -------------- |
| ^u     | 반 화면 위로   |
| ^d     | 반 화면 아래로 |
| ^b     | 한 화면 위로   |
| ^f     | 한 화면 아래로 |
| ^y     | 한 행만 위로   |
| ^e     | 한 행만 아래로 |

| 명령키   | 기능                           |
| -------- | ------------------------------ |
| G        | 마지막 행으로 커서 이동        |
| 행 번호G | 지정한 행 번호로 커서 이동     |
| :행 번호 | 지정한 행 번호로 커서 이동     |
| :$       | 파일의 마지막 행으로 커서 이동 |

### 내용 수정

| 명령키  | 기능                                                |
| ------- | --------------------------------------------------- |
| r       | 다른 글자로 수정                                    |
| cw, #cw | 단어 수정. #에는 수정할 단어의 수를 지정            |
| s, #s   | Esc를 입력할 때까지 수정. #에는 수정할 글자 수 지정 |
| cc      | 행의 내용 모두 수정                                 |
| C       | 행의 끝까지 수정                                    |

### 내용 삭제

| 명령키  | 기능             |
| ------- | ---------------- |
| x, #x   | 글자 삭제        |
| dw, #dw | 단어 삭제        |
| dd, #dd | 행 삭제          |
| D       | 행의 끝까지 삭제 |

### 명령 취소

| 명령키 | 기능                                                |
| ------ | --------------------------------------------------- |
| u      | 명령 취소                                           |
| U      | 해당 행에서의 모든 명령 취소                        |
| :e!    | 마지막으로 저장한 내용 이후의 것을 버리고 새로 작업 |

### 복사 및 잘라 붙이기

| 명령키  | 기능                 |
| ------- | -------------------- |
| yy, #yy | 행 복사              |
| p       | 행의 아래쪽에 붙인다 |
| P       | 행의 위쪽에 붙인다   |
| dd, #dd | 행을 잘라둔다        |

### 검색 및 바꾸기

| 명령키  | 기능                                |
| ------- | ----------------------------------- |
| /문자열 | 아래 방향으로 검색                  |
| ?문자열 | 위 방향으로 검색                    |
| n       | 원래 찾던 방향으로 다음 문자열 검색 |
| N       | 역방향으로 다음 문자열 검색         |

| 명령키  | 기능                                                         |
| ------- | ------------------------------------------------------------ |
| :r 파일 | 지정한 파일을 읽어들여 현재 커서 위치에 삽입                 |
| :e 파일 | 지정한 파일로 전환한다(기존 파일을 :w로 저장한 뒤에 실행)    |
| :n      | vi 시작 시 여러 파일을 지정했을 경우 다음 파일로 작업을 이동 |

| 명령키     | 기능                                                         |
| ---------- | ------------------------------------------------------------ |
| :! 셸 명령 | vi 작업 중단 및 셸 명령 실행(돌아오려면 Enter)               |
| :sh        | vi를 잠시 빠져나가서 셸 명령 실행(vi로 돌아오려면 exit 명령 실행) |

## vi 환경 설정

| set 명령과 옵션 | 기능                             |
| --------------- | -------------------------------- |
| set nu          | 행 번호 표시                     |
| set nonu        | 행 번호 표시X                    |
| set list        | 특수문자 표시                    |
| set nolist      | 특수문자 감추기                  |
| set showmode    | 현재 모드 표시                   |
| set noshowmode  | 현재 모드 감추기                 |
| set             | vi 환경 설정 값 출력             |
| set all         | 모든 vi 환경 변수와 현재 값 출력 |

# 셸 사용법

## 셸 기본 사용법

### 특수문자 사용 방법

**특수문자 * **

| 사용예                                      | 의미                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| ls *                                        | 현재 디렉터리의 모든 파일과 서브 디렉터리 나열. 서브 디렉터리 내용도 출력<br />![image-20240219210708375](.\assets\image-20240219210708375.png) |
| cp * /temp<br />sudo cp -a * ~/Desktop/temp | 현재 디렉터리의 모든 파일을 /tmp 디렉터리 아래로 복사<br />![image-20240219211038744](.\assets\image-20240219211038744.png) |
| ls -F s*                                    | 파일명이 t로 시작하는 모든 파일의 이름과 파일 종류를 출력<br />![image-20240219211215343](.\assets\image-20240219211215343.png) |
| cp *.py ../copypy                           | 확장자가 .py인 모든 파일을 상위 디렉터리 아래의 copypy 디렉터리로 복사<br />![image-20240219211403104](.\assets\image-20240219211403104.png) |
| ls -l a*y                                   | 파일명이 h로 시작하고 d로 끝나는 모든 파일의 상세 정보를 출력<br />![image-20240219211519885](.\assets\image-20240219211519885.png) |

**특수문자 ? 와 []**

| 사용예                   | 의미                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ls -l test[135abcde].txt | 숫자 1, 3, 5 문자 a, b, c, d, e <br />![image-20240221201654339](.\assets\image-20240221201654339.png) |
| ls -l test[1-3].txt      | 숫자 1-3 사이<br />![image-20240221201811803](.\assets\image-20240221201811803.png) |
| ls [0-9]*                | 숫자 0-9 사이<br />![image-20240221202045091](.\assets\image-20240221202045091.png) |

**특수문자 ~와 -**

| 사용 예         | 의미                                                         |
| --------------- | ------------------------------------------------------------ |
| cp *.txt ~/temp | ![image-20240221202604156](.\assets\image-20240221202604156.png) |
| cd -            | ![image-20240221203123696](.\assets\image-20240221203123696.png) |

**특수문자 ;과 |**

| 사용 예          | 의미                                                         |
| ---------------- | ------------------------------------------------------------ |
| date; ls; pw     | ![image-20240221203310973](.\assets\image-20240221203310973.png) |
| ls -al / \| more | ![image-20240221203403068](.\assets\image-20240221203403068.png) |

**특수문자 ' '와 " "**

' ' : 모든 특수문자 무효화

" " : $, `, \ 를 제외한 특수문자 무효화

| 사용 예       | 의미                                                         |
| ------------- | ------------------------------------------------------------ |
| echo '$SHELL' | ![image-20240221203713942](.\assets\image-20240221203713942.png) |
| echo "$SHELL" | ![image-20240221204021183](.\assets\image-20240221204021183.png) |

**특수문자 ``**

| 사용 예                                           | 의미                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| echo "Today is `date`(원래는 ``로 date를 감싼것)" | ![image-20240221204312501](.\assets\image-20240221204312501.png) |
| ls /usr/bin/`uname -m`                            |                                                              |

![image-20240221205056127](.\assets\image-20240221205056127.png)

**특수문자 \ **

| 사용 예                  | 의미                                                         |
| ------------------------ | ------------------------------------------------------------ |
| touch t\*<br />ls -l t\* | ![image-20240221205442271](.\assets\image-20240221205442271.png) |
| echo \$SHELL             | ![image-20240221205526479](.\assets\image-20240221205526479.png) |

**특수문자 >, <, >>**

`>` : 덮어쓰기
명령 [파일 디스크립터]> 파일명 ([파일 디스크립터]와 > 사이에 공백X)
ex) ls -l 0> res.txt 

| 사용 예          | 의미                                                         |
| ---------------- | ------------------------------------------------------------ |
| ls -l > res.txt  | ![image-20240221205719684](.\assets\image-20240221205719684.png) |
| ls -l >> res.txt | ![image-20240221205829814](.\assets\image-20240221205829814.png)<br /><br />![image-20240221205842102](.\assets\image-20240221205842102.png) |
| cat < text.txt   | ![image-20240221211040986](.\assets\image-20240221211040986.png) |

## 입출력 방향 변경

입력도 키보드로 하는 것이 아니라 파일에서 읽어오도록 할 수 있다.

리눅스에서 입력과 출력으로 사용하는 장치를 바꾸면 출력을 화면이 아닌 파일에 하고 입력도 파일에서 받을 수 있다.

입출력 장치를 바꾼다.

### 표준 입출력 장치

표준 출력과 별도로 오류 메시지를 내보내는 장치를 표준 오류 장치라고 한다.

리눅스는 장치도 파일로 관리한다.

셸은 작업 중 필요한 파일에 일련번호를 붙여서 관리하며 이를 '파일 디스크립터'라고 한다.

표준 입출력 장치도 파일로 관리되기 때문에 파일 디스크립터가 부여되어 있다.

입출력 장치를 변경할 때는 이 파일 디스크립터를 사용한다.

표준 입출력 장치를 파일로 바꾸는 것을 '리다이렉션'이라고 한다.

| ㅁ파일 디스크립터 | 파일 디스크립터 대신 사용하는 이름 | 정의             |
| ----------------- | ---------------------------------- | ---------------- |
| 0                 | stdin                              | 명령의 표준 입력 |
| 1                 | stdout                             | 명령의 표준 출력 |
| 2                 | stderr                             | 명령의 표준 오류 |

### 출력 리다이렉션

**> (Overwrite)**

![image-20240221211501262](.\assets\image-20240221211501262.png)

![image-20240221211728857](.\assets\image-20240221211728857.png)

![image-20240221211814051](.\assets\image-20240221211814051.png)

![image-20240221211933332](.\assets\image-20240221211933332.png)

*194p [240221수2224]*

**set 명령**

![image-20240223223102657](.\assets\image-20240223223102657.png)

```
set: set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]
```

```
Set or unset values of shell options and positional parameters.

Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.
```

```
-C  If set, disallow existing regular files to be overwritten
          by redirection of output.
```

**>> (append)**

![image-20240223223648585](.\assets\image-20240223223648585.png)

### 오류 리다이렉션

표준 출력은 1번, 표준 오류는 2번 장치 파일이다.

![image-20240223224125140](.\assets\image-20240223224125140.png)

![image-20240223224214513](.\assets\image-20240223224214513.png)

### 입력 리다이렉션

https://ehpub.co.kr/15-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%95%84%EC%9A%94/

```c
// demo2.c

#include <stdio.h>

int main(void) {
    int num;
    char name[20] = "";

    printf("번호입력 : \n");
    scanf("%d", &num);
    printf("이름입력 : \n");
    scanf("%s", &name);

    printf("번호 : %d, 이름 : %s\n", num, name);

    return 0;
}
```

```
// input
3
홍길동
```

![image-20240223230511292](.\assets\image-20240223230511292.png)

```
3
홍길동
```

![image-20240223230538437](.\assets\image-20240223230538437.png)

## 배시셸 환경 설정

### 셸 변수와 환경 변수

셸 변수는 현재 셸에서만 사용할 수 있고 서브 셸로는 전달되지 않지만, 환경 변수는 현재 셸뿐만 아니라 서브 셸로도 전달된다.

**주요 셸 환경 변수**

| 환경 변수 | 의미                           |
| --------- | ------------------------------ |
| HISTSIZE  | 히스토리 저장 크기             |
| HOME      | 사용자 홈 디렉토리의 절대 경로 |
| LANG      | 사용하는 언어                  |
| LOGNAME   | 사용자 계정 이름               |
| PATH      | 명령을 탐색할 경로             |
| PWD       | 작업 디렉토리의 절대 경로      |
| SHELL     | 로그인 셸                      |

![image-20240223231531832](.\assets\image-20240223231531832.png)

### 셸 변수와 환경 변수 설정

변수명=문자열

셸 변수로는 설정했지만 환경 변수로는 설정하지 않았다.

환경 변수로 설정하면 셸 변수로도 설정이 된다.

환경 변수 : 전역 변수 / 셸 변수 : 지역 변수

![image-20240223234145459](.\assets\image-20240223234145459.png)

### 변수 해제

![image-20240223234223599](.\assets\image-20240223234223599.png)

## 앨리어스와 히스토리

![image-20240223234335036](.\assets\image-20240223234335036.png)

![image-20240223234546373](.\assets\image-20240223234546373.png)

![image-20240223234555843](.\assets\image-20240223234555843.png)

![image-20240223234603618](.\assets\image-20240223234603618.png)

![image-20240223235231868](.\assets\image-20240223235231868.png)

![image-20240223235323282](.\assets\image-20240223235323282.png)

![image-20240224000214141](.\assets\image-20240224000214141.png)

배시셸에서는 앨리어스로 인자를 전달할 수 없다.

배시셸에서 인자를 전달하려면 프로그래밍 기능에서 함수를 사용해야 한다.

함수를 제거하려면 셸을 종료하면 된다.

![image-20240224000448989](.\assets\image-20240224000448989.png)

### 히스토리

![image-20240224000732007](.\assets\image-20240224000732007.png)

![image-20240224000906837](.\assets\image-20240224000906837.png)

## 환경 설정 파일

| 파일                | 기능                                                         |
| ------------------- | ------------------------------------------------------------ |
| /etc/profile        | * 본셸이나 본셸과 호환되는 모든 셸에 공통으로 적용되는 환경 설정 파일이다.<br />* 배시셸의 경우 /etc/bash.bashrc 파일을 실행한다.<br />* 배시셸이 아닌 경우 프롬프트를 #(root 사용자)나 $(일반 사용자)로 설정한다.<br />* /etc/profile.d/*.sh 파일을 실행한다.<br />![image-20240224004049052](.\assets\image-20240224004049052.png) |
| /etc/bash.bashrc    | * 시스템에 공통으로 적용되는 .bashrc 파일이다.<br />* 기본 프롬프트를 설정한다.<br />* sudo 명령과 관련된 힌트를 설정한다.<br />![image-20240224004121885](.\assets\image-20240224004121885.png) |
| /etc/profile.d/*.sh | * 언어나 명령별로 각각 필요한 환경을 설정한다.<br />* 필요시 설정 파일을 추가한다.<br />![image-20240224004157477](.\assets\image-20240224004157477.png) |



### 사용자 환경 설정 파일

| 파일            | 기능                                                         |
| --------------- | ------------------------------------------------------------ |
| ~/.profile      | * .bashrc 파일이 있으면 실행한다.<br />![image-20240224010054991](.\assets\image-20240224010054991.png)<br />* 경로 추가 등 사용자가 정의하는 환경 설정 파일이다.<br />![image-20240224010134583](.\assets\image-20240224010134583.png) |
| ~/.bashrc       | * 히스토리의 크기를 설정한다.<br />![image-20240224005937166](.\assets\image-20240224005937166.png)<br />* 기본 앨리어스나 함수 등을 설정한다.<br />![image-20240224005958215](.\assets\image-20240224005958215.png) |
| ~/.bash_logout  | * 로그아웃 시 실행할 필요가 있는 함수 등을 설정한다.<br />![image-20240224010255848](\assets\image-20240224010255848.png)<br />$SHLVL은 쉘의 깊이. 1은 최상위 레벨을 의미한다. |
| ~/.bash_aliases | * 사용자가 정의한 앨리어스를 별도 파일로 저장한다.           |

# 파일 접근 권한 관리

## 파일 속성

file : 지정한 파일의 종류를 알려준다.

![image-20240224214415357](.\assets\image-20240224214415357.png)

groups : 사용자가 속한 그룹을 알려준다.

![image-20240224214548767](.\assets\image-20240224214548767.png)

## 파일 접근 권한

### 접근 권한 종류

| 권한 | 파일                                                         | 디렉터리                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 읽기 | 파일을 읽거나 복사할 수 있다.                                | ls 명령으로 디렉터리 목록을 볼 수 있다(ls 명령의 옵션은 실행 권한이 있어야 사용할 수 있다). |
| 쓰기 | 파일을 수정, 이동, 삭제할 수 있다(디렉터리에 쓰기 권한이 있어야 한다). | 파일을 생성하거나 삭제할 수 있다.                            |
| 실행 | 파일을 실행할 수 있다(셸 스크립트나 실행 파일의 경우).       | cd 명령을 사용할 수 있다. 파일을 디렉터리로 이동하거나 복사할 수 있다. |

### 접근 권한 표기 방법

rwx rwx rwx

### 접근 권한 변경 명령

chmod : 파일이나 디렉터리의 접근 권한을 변경한다.

* 기호 모드
* 숫자 모드

## 기호를 이용한 파일 접근 권한 변경

| 구분                 | 문자/기호 | 의미                             |
| :------------------- | :-------- | :------------------------------- |
| 사용자 카테고리 문자 | u         | 파일 소유자                      |
|                      | g         | 파일 소유 그룹                   |
|                      | o         | 소유자와 그룹 이외의 기타 사용자 |
|                      | a         | 전체 사용자                      |
| 연산자 기호          | +         | 권한 부여                        |
|                      | -         | 권한 제거                        |
|                      | =         | 접근 권한 설정                   |
| 접근 권한 문자       | r         | 읽기 권한                        |
|                      | w         | 쓰기 권한                        |
|                      | x         | 실행 권한                        |

![image-20240224215704156](.\assets\image-20240224215704156.png)

## 숫자를 이용한 파일 접근 권한 변경

### 숫자로 환산하는 방법

Q. 근데 왜 읽기 쓰기 실행 순으로 권한이 큰건가? 읽기가 가장 권한이 높은 이유는 뭔가?

| 접근권한 | 환산             | 숫자 | 의미             |
| -------- | ---------------- | ---- | ---------------- |
| rwx      | 111 -> 4 + 2 + 1 | 7    | 읽기, 쓰기, 실행 |
| rw-      | 110 -> 4 + 2 + 0 | 6    | 읽기, 쓰기       |
| r-x      | 101 -> 4 + 0 + 1 | 5    | 읽기, 실행       |
| r--      | ...              | 4    | 읽기             |
| -wx      | ...              | 3    | 쓰기, 실행       |
| -w-      | ...              | 2    | 쓰기             |
| --x      | ...              | 1    | 실행             |
| ---      | ...              | 0    | 권한X            |

| 접근 권한 | 숫자 모드 |
| --------- | --------- |
| rwxrwxrwx | 777       |
| rwxr-xr-x | 755       |
| rw-rw-rw- | 666       |

### 숫자 모드를 이용한 접근 권한 변경

![image-20240224220415672](.\assets\image-20240224220415672.png)

## 기본 접근 권한 설정

파일이나 디렉터리를 생성할 때 기본 접근 권한이 자동으로 설정된다.

![image-20240224220528058](.\assets\image-20240224220528058.png)

### 기본 접근 권한 확인 및 변경

umask : 기본 접근 권한을 출력하거나 변경한다.

ex) umask 0002 : -------w- 권한을 부여하지 않겠다. 즉 쓰여진 숫자의 권한을 부여하지 않겠다.

![image-20240224220626705](.\assets\image-20240224220626705.png)

![image-20240224220652904](.\assets\image-20240224220652904.png)

![image-20240224221243474](.\assets\image-20240224221243474.png)

### 마스크 값의 적용 과정

뺄셈 연산(마스크 값 적용에서는 0에서 1을 뺀 경우는 0)

![image-20240225004618906](.\assets\image-20240225004618906.png)

ex) 

최대 권한(파일)                 : rw- rw- rw-

최대 권한(디렉터리)         : rwx rwx rwx

umask 077                        :  ---  rwx  rwx

`---------------------------------`

파일 권한			      rw- --- ---		  

디렉터리 권한                      rwx --- ---

![image-20240225010753957](.\assets\image-20240225010753957.png)

## 특수 접근 권한 설정

맨 앞자리로 특수 접근 권한 설정

* SetUID : 맨 앞자리가 4
* SetGID : 맨 앞자리가 2
* 스티키 비트 : 맨 앞자리가 1

### SetUID

![image-20240225011331461](.\assets\image-20240225011331461.png)

![image-20240225011425222](.\assets\image-20240225011425222.png)

→ 소유자의 실행 권한에 s가 표기된다. 

set.exe 파일을 실행하면 항상 user1의 권한을 가진다.

흔히 사용하는 명령 중에 setUID가 설정된 명령은 passwd다.

![image-20240225011724253](.\assets\image-20240225011724253.png)

passwd 명령은 사용자 계정의 암호를 바꾼다.

계정의 암호가 저장된 /etc/shadow 파일은 root 계정으로만 수정 가능 → 일반 사용자 수정 불가

그러나 passwd 명령에는 SetUID가 설정되어 있기 때문에 root 권한으로 실행되어 /etc/shadow 파일을 수정해 암호를 바꿀 수 있다.

### SetGID

SetGID가 설정된 파일을 실행하면 해당 파일이 실행되는 동안에는 파일 소유 그룹의 권한으로 실행된다.

set.exe 파일에 SetGID를 설정하면 다음과 같이 그룹의 실행 권한에 's'가 표시된다.

![image-20240225012349677](.\assets\image-20240225012349677.png)

### 스티키 비트

스티키 비트는 SetUID, SetGID와는 다른 특징이 있다.

스티키 비트는 디렉터리에 설정하며, 디렉터리에 스티키 비트가 설정되어 있으면 이 디렉터리에는 누구나 파일을 생성할 수 있다.

즉 누구나 자유롭게 사용이 가능하다.

단, 스티키 비트가 디렉터리에 적용되면 디렉토리의 소유자나 파일 소유자 또는 슈퍼유저가 아닌 사용자들은 파일을 삭제하거나 변경할 수 없다. 그렇지만 파일 또는 디렉터리를 누구나 생성이 가능하다. 대표적인 디렉터리가 /tmp 디렉터리이다.

스티키 비트가 설정이 되면 실행 권한에 't'가 표시된다.

![image-20240225013732047](.\assets\image-20240225013732047.png)

# 프로세스 관리

## 프로세스의 개념

### 프로세스의 부모-자식 관계

리눅스 시스템을 부팅할 때 스케줄러가 실행한 프로세스인 systemd와 kthreadd 프로세스를 제외하면 모든 프로세스는 부모 프로세스를 가지고 있다.

자식 프로세스는 할 일이 끝나면 부모 프로세스에 결과를 돌려주고 종료된다.

### 프로세스의 번호

각 프로세스는 고유한 번호를 가지고 있는데 이를 PID라고 한다. 

리눅스가 부팅될 때 PID 1번 systemd 프로세스와 2번 kthreadd 프로세스가 차례로 실행된다.

1번 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스가 되고, 2번 프로세스는 모든 스레드의 부모 프로세스가 된다.

> 전통적으로 유닉스에서 1번 프로세스는 init 프로세스다.
>
> 그러나 우분투의 경우 init의 기능을 systemd로 바꾸었다.
>
> 다만, 이전 시스템과 호환되도록 1번 프로세스의 이름은 init을 유지하고 있다.
>
> init은 systemd의 심벌릭 링크이다.

### 프로세스의 종류

* 데몬 프로세스

  특정 서비스를 제공하기 위해 존재하며 리눅스 커널에 의해 실행된다.

  데몬은 평소에는 대기 상태로 있다가 서비스 요청이 들어오면 서비스를 제공한다.

* 고아 프로세스

  자식 프로세스가 실행 중인데 부모 프로세스가 먼저 종료되면 자식 프로세스는 고아 프로세스가 된다.

  이 경우 1번 프로세스가 고아 프로세스의 새로운 부모 프로세스가 되어 고아 프로세스가 작업을 마치고 종료될 수 있게 한다.

* 좀비 프로세스

  자식 프로세스는 종료될 때 부모 프로세스에 종료 정보를 보내고, 부모 프로세스가 이 정보를 받으면 자식 프로세스는 프로세스 테이블 목록에서 삭제된다.

  자식 프로세스가 실행을 종료했는데도 프로세스 테이블 목록에 남아 있는 경우가 있는데 이러한 자식 프로세스를 좀비 프로세스라고 한다.

  자식 프로세스의 종료 정보를 부모 프로세스가 읽어 가기를 기다리고 있는 것

  좀비 프로세스는 프로세스 목록에 defunct 프로세스라고 나오기도 한다.

  좀비 프로세스는 kill 명령으로 제가할 수 없으며, SIGCHLD 시그널을 부모 프로세스에 보내어 부모 프로세스가 자식 프로세스를 정리하도록 하거나 부모 프로세스 자체를 종료해야만 한다.

  부모 프로세스가 종료되면 좀비 프로세스는 고아 프로세스가 되고, 새로운 부모인 1번 프로세스는 주기적으로 자식 프로세스의 종료 정보를 확인하여 정리한다.

## 프로세스 관리 명령

### 프로세스 목록 확인

**ps : 현재 단말기에서 실행 중인 프로세스에 대한 정보를 출력한다.**

![image-20240225024225445](.\assets\image-20240225024225445.png)

**-f 옵션 : 프로세스의 상세 정보 출력하기**

![image-20240225024306781](.\assets\image-20240225024306781.png)

| 항목  | 의미                                   |
| ----- | -------------------------------------- |
| UID   | 프로세스를 실행한 사용자 ID            |
| PID   | 프로세스 번호                          |
| PPID  | 부모 프로세스 번호                     |
| C     | CPU 사용량(%)                          |
| STIME | 프로세스의 시작 날짜나 시간            |
| TTY   | 프로세스가 실행된 터미널의 종류와 번호 |
| TIME  | 프로세스 실행 시간                     |
| CMD   | 실행되고 있는 프로그램 이름(명령)      |

**a 옵션 : 터미널에서 실행시킨 프로세스 정보 출력하기**

![image-20240225024705339](.\assets\image-20240225024705339.png)

| 문자        | 의미                                  | 비고     |
| ----------- | ------------------------------------- | -------- |
| R           | 실행 중(running)                      |          |
| S           | 인터럽트가 가능한 대기(sleep) 상태    |          |
| T           | 작업 제어에 의해 정지된(stopped) 상태 |          |
| Z           | 좀비 프로세스(defunct)                |          |
| STIME       | 프로세스의 시작 날짜나 시간           |          |
| s           | 세션 리더 프로세스                    | BSD 형식 |
| +           | 포그라운드 프로세스 그룹              | BSD 형식 |
| l(소문자 L) | 멀티스레드                            | BSD 형식 |

**a옵션과 u옵션 : 터미널에서 실행시킨 프로세스 상세 정보 출력하기**

![image-20240225025916580](.\assets\image-20240225025916580.png)

| 항목  | 의미                                 |
| ----- | ------------------------------------ |
| USER  | 사용자 계정 이름                     |
| %CPU  | 퍼센트로 표시한 CPU 사용량           |
| %MEM  | 퍼센트로 표시한 물리적 메모리 사용량 |
| VSZ   | 사용 중인 가상 메모리의 크기(kB)     |
| RSS   | 사용 중인 물리적 메모리의 크기(kB)   |
| START | 프로세스 시작 시간                   |

**-e 옵션과 -f 옵션 : 전체 프로세스 목록 출력하기(유닉스 옵션)**

TTY 값이 ?인 것은 대부분 데몬으로 시스템이 실행한 프로세스다.

![image-20240225031424798](.\assets\image-20240225031424798.png)

스레드는 CMD에 [ ]로 표시하여 구분한다.

![image-20240225031524380](.\assets\image-20240225031524380.png)

**ax 옵션과 aux 옵션 : 전체 프로세스 목록 출력하기(BSD 옵션) : ax 옵션과 aux 옵션**

![image-20240225031842584](.\assets\image-20240225031842584.png)

![image-20240225031900522](.\assets\image-20240225031900522.png)

**-u 옵션 : 특정 사용자의 프로세스 목록 출력하기**

![image-20240225031950004](.\assets\image-20240225031950004.png).

![image-20240225032021907](.\assets\image-20240225032021907.png)

**-p 옵션 : 특정 프로세스 정보 출력하기**

![image-20240225032244705](.\assets\image-20240225032244705.png)

### 특정 프로세스 정보 검색

pgrep : 지정한 패턴과 일치하는 프로세스의 PID를 출력한다.

![image-20240225070533231](.\assets\image-20240225070533231.png)

-x(exact) 옵션 : 패턴과 정확히 일치하는 프로세스의 PID를 출력한다.

![image-20240225070650411](.\assets\image-20240225070650411.png)

-n(newset) 옵션 : 패턴을 포함하고 있는 가장 최근 프로세스의 PID를 출력한다.

![image-20240225071405212](.\assets\image-20240225071405212.png)

-u(uid) [사용자 이름] 옵션 : 특정 사용자에 대한 모든 프로세스 PID를 출력한다.

![image-20240225071818213](.\assets\image-20240225071818213.png)

-l(list-name) : PID와 프로세스 이름을 출력한다.

![image-20240225071945586](.\assets\image-20240225071945586.png)

-t(terminal) [term] : 특정 단말기와 관련된 프로세스의 정보를 출력한다.

![image-20240225072132308](.\assets\image-20240225072132308.png)

차후 과제) pgrep -t 명령으로 /dev 디렉토리에 있는 모든 파일의 프로세스를 확인하는 쉘스크립트 작성 후 실행 및 결과물 올리기

![image-20240225083629169](.\assets\image-20240225083629169.png)

![image-20240225084730297](.\assets\image-20240225084730297.png)

![image-20240225084631255](.\assets\image-20240225084631255.png)

리눅스 시스템에서 동시에 여러 사용자가 접속해있을 때

![image-20240225085011483](.\assets\image-20240225085011483.png)

### 프로세스 종료

응답이 없는 프로세스나 불필요한 프로세스를 강제로 종료하려면 해당 프로세스의 PID를 알아야 한다.

프로세스를 종료하는 데는 kill이나 pkill 명령을 사용한다. 

이 명령들은 프로세스에 시그널을 보내 프로세스를 종료한다.

시그널은 프로세스에 무언가 발생했음을 알리는 간단한 메시지다.

이 메시지에는 무엇이 발생했는지를 나타내는, 미리 정의된 상수를 사용한다.

시그널을 받은 프로세스는 기본적으로 종료된다.

다음은 시그널 목록이다.

![image-20240225085613598](.\assets\image-20240225085613598.png)

| 시그널  | 번호 | 기본 처리      | 의미                                                         |
| ------- | ---- | -------------- | ------------------------------------------------------------ |
| SIGHUP  | 1    | 종료           | 터미널과 연결이 끊겼을 때 발생한다.                          |
| SIGINT  | 2    | 종료           | 인터럽트로 사용자가 Ctrl + c를 입력하면 발생한다.            |
| SIGQUIT | 3    | 종료, 코어덤프 | 종료 신호로 사용자가 Ctrl + \를 입력하면 발생한다.           |
| SIGKILL | 9    | 종료           | 이 시그널을 받은 프로세스는 무시할 수 없으며 강제로 종료된다. |
| SIGALRM | 14   | 종료           | 알람에 의해 발생한다.                                        |
| SIGTERM | 15   | 종료           | kill 명령이 보내는 기본 시그널이다.                          |

kill : 지정한 시그널을 프로세스에게 보낸다.

kill [-시그널] PID...

![image-20240225095601531](.\assets\image-20240225095601531.png)

![image-20240225095616668](.\assets\image-20240225095616668.png)

![image-20240225095655634](.\assets\image-20240225095655634.png)

![image-20240225095712529](.\assets\image-20240225095712529.png)

pkill [명령 이름]

![image-20240225095858795](.\assets\image-20240225095858795.png)

![image-20240225095914009](.\assets\image-20240225095914009.png)

![image-20240225100354759](.\assets\image-20240225100354759.png)

※ 따라해보기

![image-20240225100632811](.\assets\image-20240225100632811.png)

![image-20240225100909845](.\assets\image-20240225100909845.png)

![image-20240225101243516](.\assets\image-20240225101243516.png)

![image-20240225101305612](.\assets\image-20240225101305612.png)

![image-20240225101425352](.\assets\image-20240225101425352.png)

![image-20240225101538945](.\assets\image-20240225101538945.png)

※ 혼자해보기

터미널 1에서 cron 프로세스 검색. 사용자 ID와 터미널 번호가 보이도록.

![image-20240225102007545](.\assets\image-20240225102007545.png)

검색한 결과 중 UID가 root인 프로세스를 종료. 종료되지 않는다면 이유는?

![image-20240225102208385](.\assets\image-20240225102208385.png)

: 시스템 프로세스이므로

### 프로세스 관리 도구

**top 명령**

현재 실행 중인 프로세스의 정보를 주기적으로 출력

| 항목                   | 의미                                                 |
| ---------------------- | ---------------------------------------------------- |
| PID(Process ID)        | 프로세스 ID. 각 프로세스를 구별하는 유일한 숫자.     |
| USER                   | 사용자 계정 - 프로세스를 실행하는 사용자의 이름      |
| PR(Priority)           | 프로세스의 실행 우선순위                             |
| NI(Nice Value)         | Nice 값. 프로세스의 실행 우선순위에 영향을 미치는 값 |
| VIRT(Virtual Memory)   | 프로세스가 사용하는 가상 메모리의 크기               |
| RES(Resident Set Size) | 프로세스가 사용하는 실제 물리 메모리의 크기          |
| SHR(Shared Memory)     | 프로세스가 사용하는 공유 메모리의 크기               |
| %CPU                   | 프로세스가 CPU를 사용하는 비율                       |
| TIME+                  | 프로세스가 CPU를 사용한 누적 시간                    |
| COMMAND                | 프로세스를 실행하는 명령어의 이름                    |

![image-20240225103915648](.\assets\image-20240225103915648.png)

![image-20240225103946113](.\assets\image-20240225103946113.png)

| top 명령의 내부 명령 | 기능                                                   |
| -------------------- | ------------------------------------------------------ |
| Enter, Space Bar     | 화면을 다시 출력한다.                                  |
| h, ?                 | 도움말 화면을 출력한다.                                |
| k                    | 프로세스를 종료한다. 종료할 프로세스의 PID를 물어본다. |
| n                    | 출력하는 프로세스의 개수를 바꾼다.                     |
| u                    | u 사용자에 따라 정렬하여 출력한다.                     |
| M                    | 사용하는 메모리 크기에 따라 정렬하여 출력한다.         |
| p                    | CPU 사용량에 따라 정렬하여 출력한다.                   |
| q                    | top 명령을 종료한다.                                   |

**시스템 감시**

[프로그램 표시] - [시스템 감시]

## 포그라운드/백그라운드 프로세스와 작업 제어

[240225일1100]

일단 돌리기. 이후 시사점 적기. 이후 내용 덧붙이기

### 포그라운드 작업과 백그라운드 작업

### 작업 제어

## 작업 예약

### 정해진 시간에 한 번 실행

### 정해진 시간에 반복 실행

