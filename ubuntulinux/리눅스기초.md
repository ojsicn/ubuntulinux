# 리눅스 기초

## 리눅스의 구조

* 커널

  : 프로세스 관리, 메모리 관리, 파일 시스템 관리, 장치 관리 등 컴퓨터의 모든 자원을 초기화, 모니터링, 제어하는 기능을 수행

* 셸

  : 리눅스의 사용자 인터페이스

  : 사용자와 커널 사이의 중간자 역할

  : 셸은 사용자가 입력한 명령을 해석하여 커널에 넘겨준다. 이후 커널은 명령의 수행 결과를 돌려주고 셸은 다시 사용자가 이해할 수 있는 형태로 바꿔 출력한다.

* 응용 프로그램

  : 각종 프로그래밍 개발 도구, 문서 편집 도구, 네트워크 관련 도구 등의 사용자 편의 기능 프로그램

## 리눅스 실습 환경 구축

리눅스 실습 환경은 다음과 같다. VMWare 등 가상환경으로 실습해도 되고 OS를 여러 개 설치한 듀얼부팅을 통해서도 실습해도 된다. 나의 경우에는 라즈베리파이를 통해 실습을 진행하였다. 라즈비안OS를 설치하는 과정은 생략하였다. 다만 해당 링크를 걸어둔다.

[라즈비안OS 설치 링크](https://www.robotstory.co.kr/raspberry/?board_page=6&vid=31)

| 하드웨어      | OS                             | 통신방식 | 코드 에디터 |
| ------------- | ------------------------------ | -------- | ----------- |
| 라즈베리파이3 | 라즈비안OS(우분투와 거의 동일) | SSH      | VSCode      |

실습 환경 구축은 다음과 같다.

1. VSCode 설치

   ![image-20240217212357709](.\assets\image-20240217212357709.png)

2. SSH 연결

   1. 라즈베리파이 SSH 설치

   ![image-20240217212710846](.\assets\image-20240217212710846.png)

   2. VSCode - Extension - Remote-SSH 설치

      ![image-20240217212849641](.\assets\image-20240217212849641.png)

   3. VSCode - F1키 or Ctrl + Shif + p - Remote-SSH: Open SSH Configuration File - 기본경로 - 설정파일 수정

      * Host : 사용할 이름(아무거나 지정)
      * HostName : 접속할 서버의 호스트이름 or ip
      * User : 접속할 서버의 사용자명
      * IdentityFile : pem키의 경로 및 파일명

      ![image-20240217213149768](.\assets\image-20240217213149768.png)

   4. VSCode - F1키 or Ctrl + Shift + p - Connect to Host - 지정한 호스트명

   5. 좌측 중간 모니터 아이콘 클릭 및 ssh 접속

      ![image-20240217213552261](.\assets\image-20240217213552261.png)

## 리눅스 명령 사용법

* 터미널 접속 해제 : exit, ^d
* 문자 지우기 : delete 키
* 단어 지우기 : ctrl + w
* 모두 지우기 : ctrl + u

### 명령의 구조

* 형식

  명령 [옵션] [인자]

  * 명령

    사용자가 리눅스에게 명령을 내리기 위해 사용하는 명령어

  * 옵션

    명령의 세부 기능 

  * 인자

    명령으로 전달되는 값

### 기초 명령 사용법

* date 명령

  * 날짜와 시간을 출력
  * date

* clear 명령

  * 화면을 지운다.
  * clear

* man

  * 명령 사용 방법을 화면에 출력한다.
  * man [명령]

* passwd 

  * 사용자 계정의 비밀번호 변경

    passwd [사용자]

# 디렉터리와 파일 사용법

* 리눅스 파일의 종류와 특징
* 디렉터리 계층 구조
* 절대 경로명과 상대 경로명
* 디렉터리 이동, 디렉터리 내용 확인
* 디렉터리 생성, 삭제
* 파일 내용 확인
* 파일 복사/이동/삭제
* 파일 링크의 특징
* 하드 링크, 심볼릭 링크 생성
* 파일의 내용과 위치 검색

## 리눅스 파일과 디렉터리

### 파일의 종류

* 일반 파일

  : 각종 텍스트 파일, 실행 파일, 이미지 파일 등

  : 실행 파일이나 이미지 파일의 경우 바이너리 형태로 저장(바이너리 파일은 특정 응용 프로그램이 있어야 해당 내용을 확인할 수 있다)

* 디렉터리

  : 파일의 목록 관리 파일

* 심볼릭 링크

  : 원본 파일을 대신하도록 원본 파일을 다른 파일명으로 지정한 것(윈도의 바로가기 파일)

* 장치 파일

  : 리눅스에서는 각종 장치도 파일로 취급한다.

  : 장치 파일은 리눅스 시스템에 부착된 장치들을 관리하기 위한 특수 파일이다.

  : 대부분의 장치 파일은 /dev 디렉터리 아래에 위치

### 디렉터리의 계층 구조

리눅스에서는 파일을 효율적으로 관리하기 위해 디렉터리를 계층적으로 구성하는데 이를 트리(tree) 구조라고 한다.

리눅스의 모든 디렉터리의 출발점은 루트(root) 디렉터리이다. 루트 디렉터리는 / 로 표시한다.

### 리눅스 디렉터리의 계층 구조 및 기능

**디렉터리의 계층 구조**

![image-20240217223553877](.\assets\image-20240217223553877.png)

**디렉터리의 주요 기능**

| 디렉터리   | 기능                                                         |
| ---------- | ------------------------------------------------------------ |
| dev        | 장치 파일이 담긴 디렉터리<br />![image-20240224004726978](.\assets\image-20240224004726978.png) |
| home       | 사용자 홈 디렉터리<br />![image-20240224004758246](.\assets\image-20240224004758246.png) |
| media      | DVD/CD나 USB 같은 외부 장치를 연결(마운트라고 한다)하는 디렉터리<br />![image-20240224004815278](.\assets\image-20240224004815278.png) |
| opt        | 추가 패키지가 설치되는 디렉터리<br />![image-20240224004831980](.\assets\image-20240224004831980.png) |
| root       | root 계정의 홈 디렉터리, 루트(/) 디렉터리와는 다른 것이므로 혼동X<br />![image-20240224004935006](.\assets\image-20240224004935006.png) |
| sys        | 리눅스 커널과 관련된 파일이 있는 디렉터리<br />![image-20240224004951936](.\assets\image-20240224004951936.png) |
| usr        | 기본 실행 파일, 라이브러리 파일, 헤더 파일 등 이 있다. usr는 'Unix System Resource'의 약자<br />![image-20240224005008762](.\assets\image-20240224005008762.png) |
| boot       | 부팅에 필요한 커널 파일을 가지고 있다.<br />![image-20240224005034518](.\assets\image-20240224005034518.png) |
| etc        | 리눅스 설정을 위한 각종 파일을 가지고 있다.<br />![image-20240224005158575](.\assets\image-20240224005158575.png) |
| lost+found | 파일 시스템에 문제가 발생하여 복구할 경우, 문제가 되는 파일이 저장되는 디렉터리로 보통은 비어 있다.<br />![image-20240224005238806](.\assets\image-20240224005238806.png) |
| mnt        | 파일 시스템을 임시로 마운트하는 디렉터리<br />![image-20240224005300413](.\assets\image-20240224005300413.png) |
| proc       | 프로세스 정보 등 커널 관련 정보가 저장되는 디렉터리<br />![image-20240224005318878](.\assets\image-20240224005318878.png) |
| run        | 실행 중인 서비스와 관련된 파일이 저장<br />![image-20240224005340968](.\assets\image-20240224005340968.png) |
| srv        | FTP나 Web 등 시스템에 제공하는 서비스의 데이터가 저장된다.<br />![image-20240224005407110](.\assets\image-20240224005407110.png) |
| tmp        | 시스템 사용 중에 발생하는 임시 데이터가 저장된다. 이 디렉터리에 있는 파일은 재시작하면 모두 삭제된다.<br />![image-20240224005424048](.\assets\image-20240224005424048.png) |
| var        | 시스템 운영 중에 발생하는 데이터나 로그 등 내용이 자주 바뀌는 파일이 주로 저장된다.<br />![image-20240224005434944](.\assets\image-20240224005434944.png) |



### 절대 경로명과 상대 경로명

경로명에서 가장 앞에 있는 /는 루트 디렉터리를, 중간의 /는 구분자로 사용된다.

**※ 절대 경로명과 상대 경로명의 특징**

| 구분        | 특징                                                         |
| ----------- | ------------------------------------------------------------ |
| 절대 경로명 | 루트 디렉터리가 기준이 된다.<br />ex) /home/Desktop/test.txt |
| 상대 경로명 | 현재 디렉터리가 기준이 된다.<br />ex) ../../etc/hosts        |

## 디렉터리 관련 명령

### 현재 디렉터리 확인 : pwd

### 디렉터리 이동 : cd

### 디렉터리 내용 확인 : ls

| 옵션                 | 설명                                                      |
| -------------------- | --------------------------------------------------------- |
| -a(all)              | 숨김 파일을 포함하여 모든 파일 목록                       |
| -d(directory)        | 디렉터리 자체의 정보<br />-ld 로 써야 자체 정보가 나온다. |
| -i(inode)            | inode 번호                                                |
| -l(long list format) | 파일의 상세 정보                                          |
| -A(almost all)       | .와 ..를 제외한 모든 파일 목록                            |
| -F(classify)         | 파일의 종류(* 실행파일, / 디렉터리, @ 심볼릭 링크)        |
| -L(dereference)      | 심볼릭 링크 파일의 경우 원본 파일의 정보 출               |
| -R(recursive)        | 하위 디렉터리의 목록까지 출력                             |
| -h(human readable)   | with -l and -s, print sizes like 1K 234M 2G etc.          |
| -S(sort)             | sort by file size, largest first                          |
| -t(time)             | sort by time, newest first; see --time                    |

**파일의 상세 정보**

ex) drwxr-xr-x 2 root root 4096 Feb 17 22:39 watchdog 

| 필드 값      | 의미                                                         |
| ------------ | ------------------------------------------------------------ |
| d            | 다음과 같은 파일 종류를 나타낸다.<br />- : 일반 파일<br />d : 디렉터리 파일<br />l : 심볼릭 링크 파일<br />b : 블록 단위로 읽고 쓰는 블록 장치 파일<br />c : 섹터 단위로 읽고 쓰는 문자 장치 파일<br />p : 파이프 파일(프로세스 간 통신에 사용되는 특수 파일)<br />s : 소켓(네트워크 통신에 사용되는 특수 파일) |
| rwxr-xr-x    | 파일의 사용자에 따른 접근 권한                               |
| 2            | 하드 링크의 개수                                             |
| root         | 파일 소유자                                                  |
| root         | 파일이 속한 그룹                                             |
| 4096         | 파일 크기(바이트 단위)                                       |
| Feb 17 22:39 | 파일이 마지막으로 수정된 시간                                |
| watchdog     | 파일명                                                       |

이밖에도 파일이 있는지 없는지 확인하는 용도로도 사용이 된다.

ex) ls .bashrc

### 디렉터리 생성 : mkdir

| 옵션 | 설명                                                   |
| ---- | ------------------------------------------------------ |
| -p   | 중간 단계의 디렉터리를 생성하고 지정한 디렉터리를 생성 |

**디렉터리 여러 개 만들기**

![image-20240217234741682](.\assets\image-20240217234741682.png)

**중간 디렉터리 자동으로 만들기 : -p**

![image-20240217234925912](.\assets\image-20240217234925912.png)

### 디렉터리 삭제 : rmdir

| 옵션 | 설명                                                         |
| ---- | ------------------------------------------------------------ |
| -p   | 지정한 디렉터리를 삭제하고 그 디렉터리의 부모 디렉터리가 빈 디렉터리일 경우 부모 디렉터리도 삭제 |

## 파일 관련 명령

### 파일 내용 출력

**cat : 파일 내용 연속 출력**

| 옵션 | 설명                  |
| ---- | --------------------- |
| -n   | 행 번호를 붙여서 출력 |

**more : 파일 내용 화면 단위 출력**

| 옵션     | 설명                       |
| -------- | -------------------------- |
| +행 번호 | 출력을 시작할 행 번호 지정 |

**less : 파일 내용 화면 단위 출력**

**tail : 파일 내용의 뒷부분 출력**

| 옵션     | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| +행 번호 | 지정한 행부터 끝까지 출력                                    |
| -숫자    | 화면에 출력할 행의 수를 지정(기본값은 10)                    |
| -f       | 파일 출력을 종료하지 않고 주기적으로 계속 출력한다(파일 내용의 변화를 확인할 때 편리). |

### cp : 파일 복사

| 옵션   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| -i     | 파일2가 이미 존재하면 덮어쓸 것인지 물어본다.                |
| -r, -R | 디렉터리를 재귀적으로 복사한다. 만약 소유자, 퍼미션까지 원본과 동일하게 복사하려면 -a를 사용한다. |

### mv : 파일 이동과 파일명 변경

| 옵션 | 설명                                             |
| ---- | ------------------------------------------------ |
| -i   | 동일명의 파일이 존재하면 덮어쓸 것인지 물어본다. |

### rm : 파일 삭제

| 옵션 | 설명                            |
| ---- | ------------------------------- |
| -i   | 파일을 삭제할 것인지 확인한다.  |
| -r   | 디렉터리를 재귀적으로 삭제한다. |

### 파일 링크

파일의 구성 : 파일명 + inode + 데이터 블록

* 파일명 : 사용자가 파일에 접근할 때 사용하는 파일 이름
* inode : 파일 정보가 담긴 구조체이다. 외부적으로는 번호로 표시되고 내부적으로는 파일의 종류와 크기, 소유자, 파일 변경 시간, 파일명 등 파일 상세 정보와 데이터 블록 주소가 저장되어 있다.
* 데이터 블록 : 

### ln : 하드 링크 만들기

| 옵션 | 설명                  |
| ---- | --------------------- |
| -s   | 심볼릭 링크 파일 생성 |

cf) : cd [심볼릭 링크] : 해당 심볼릭 링크가 가리키는 디렉터리로 이동한다.

```
user@raspberrypi:/sys/devices/virtual/gpiomem0/gpiomem0/subsystem/gpiomem0 $ ls
dev  power  subsystem  uevent
user@raspberrypi:/sys/devices/virtual/gpiomem0/gpiomem0/subsystem/gpiomem0 $ cd subsystem
user@raspberrypi:/sys/devices/virtual/gpiomem0/gpiomem0/subsystem/gpiomem0/subsystem $ ls
gpiomem0
```

### touch : 빈 파일 만들기, 접근/수정 시간 변경하기

| 옵션                     | 설명             |
| ------------------------ | ---------------- |
| -a                       | 접근 시간만 변경 |
| -m                       | 수정 시간만 변경 |
| -t [[CC]YY]MMDDhhmm[.ss] | 시간을 직접 입력 |

### grep : 파일 내용 검색

| 옵션 | 설명                               |
| ---- | ---------------------------------- |
| -i   | 대소문자를 모두 검색               |
| -l   | 지정한 패턴이 포함된 파일명을 출력 |
| -n   | 행 번호를 출력                     |

### find : 파일 찾기

* 형식 : find [경로] [검색 조건] [동작]
* 검색 조건
  * -name filename : 파일명으로 검색한다.
  * -type 파일 종류 : 파일 종류로 검색한다.
  * -user loginID : 지정한 사용자가 소유한 모든 파일을 검색한다.
  * -perm 접근 권한 : 지정한 사용 권한과 일치하는 파일을 검색한다.
* 동작
  * -exec 명령 {} \; : 검색된 파일에 명령을 실행한다.
  * -ok 명령 {} \; : 사용자의 확인을 받아서 명령을 실행한다.
  * -print : 검색된 파일의 절대 경로명을 화면에 출력한다(기본 동작).
  * -ls : 검색 결과를 긴 목록 형식으로 출력한다.

### whereis : 명령의 위치 찾기

| 옵션 | 설명                 |
| ---- | -------------------- |
| -b   | 바이너리 파일만 검색 |
| -m   | 메뉴얼 파일만 검색   |
| -s   | 소스 파일만 검색     |

### which : 명령의 위치 찾기

# 문서 편집

## vi 사용법

### vi 동작 모드

![image-20240218203005425](.\assets\image-20240218203005425.png)

**vi 파일 저장 및 종료**

| 명령키          | 기능                                                         |
| --------------- | ------------------------------------------------------------ |
| :q              | 작업한 내용을 저장하지 않고 종료                             |
| :q!             | 작업한 내용을 저장하지 않고 종료                             |
| :w or :w 파일명 | 작업한 내용을 저장만 한다. 파일명을 지정하면 다른 파일로 저장한다. |
| :wq, :wq!       | 작업한 내용을 저장하고 종료                                  |
| ZZ(shift + zz)  | 작업한 내용을 저장하고 종료                                  |

### vi 모드 전환

| 명령키      | 기능             |
| ----------- | ---------------- |
| i           | 현재 자리        |
| a           | 다음 자리        |
| o           | 다음 행          |
| I(대문자 i) | 행의 첫 칼럼     |
| A           | 행의 마지막 칼럼 |
| O           | 행의 이전 행     |

### 커서와 화면 이동

| 명령키         | 기능                      |
| -------------- | ------------------------- |
| k / j          | 위 / 아래                 |
| l / h          | 오른쪽 / 왼쪽             |
| 0 / $          | 현재 행의 처음 / 마지막   |
| - / + or Enter | 앞 / 다음 행의 처음       |
| H / M / L      | 맨 위 / 중간 / 맨 아래    |
| w / e          | 다음 단어의 처음 / 마지막 |
| b              | 앞 단어의 첫 글자         |

| 명령키 | 기능           |
| ------ | -------------- |
| ^u     | 반 화면 위로   |
| ^d     | 반 화면 아래로 |
| ^b     | 한 화면 위로   |
| ^f     | 한 화면 아래로 |
| ^y     | 한 행만 위로   |
| ^e     | 한 행만 아래로 |

| 명령키   | 기능                           |
| -------- | ------------------------------ |
| G        | 마지막 행으로 커서 이동        |
| 행 번호G | 지정한 행 번호로 커서 이동     |
| :행 번호 | 지정한 행 번호로 커서 이동     |
| :$       | 파일의 마지막 행으로 커서 이동 |

### 내용 수정

| 명령키  | 기능                                                |
| ------- | --------------------------------------------------- |
| r       | 다른 글자로 수정                                    |
| cw, #cw | 단어 수정. #에는 수정할 단어의 수를 지정            |
| s, #s   | Esc를 입력할 때까지 수정. #에는 수정할 글자 수 지정 |
| cc      | 행의 내용 모두 수정                                 |
| C       | 행의 끝까지 수정                                    |

### 내용 삭제

| 명령키  | 기능             |
| ------- | ---------------- |
| x, #x   | 글자 삭제        |
| dw, #dw | 단어 삭제        |
| dd, #dd | 행 삭제          |
| D       | 행의 끝까지 삭제 |

### 명령 취소

| 명령키 | 기능                                                |
| ------ | --------------------------------------------------- |
| u      | 명령 취소                                           |
| U      | 해당 행에서의 모든 명령 취소                        |
| :e!    | 마지막으로 저장한 내용 이후의 것을 버리고 새로 작업 |

### 복사 및 잘라 붙이기

| 명령키  | 기능                 |
| ------- | -------------------- |
| yy, #yy | 행 복사              |
| p       | 행의 아래쪽에 붙인다 |
| P       | 행의 위쪽에 붙인다   |
| dd, #dd | 행을 잘라둔다        |

### 검색 및 바꾸기

| 명령키  | 기능                                |
| ------- | ----------------------------------- |
| /문자열 | 아래 방향으로 검색                  |
| ?문자열 | 위 방향으로 검색                    |
| n       | 원래 찾던 방향으로 다음 문자열 검색 |
| N       | 역방향으로 다음 문자열 검색         |

| 명령키  | 기능                                                         |
| ------- | ------------------------------------------------------------ |
| :r 파일 | 지정한 파일을 읽어들여 현재 커서 위치에 삽입                 |
| :e 파일 | 지정한 파일로 전환한다(기존 파일을 :w로 저장한 뒤에 실행)    |
| :n      | vi 시작 시 여러 파일을 지정했을 경우 다음 파일로 작업을 이동 |

| 명령키     | 기능                                                         |
| ---------- | ------------------------------------------------------------ |
| :! 셸 명령 | vi 작업 중단 및 셸 명령 실행(돌아오려면 Enter)               |
| :sh        | vi를 잠시 빠져나가서 셸 명령 실행(vi로 돌아오려면 exit 명령 실행) |

## vi 환경 설정

| set 명령과 옵션 | 기능                             |
| --------------- | -------------------------------- |
| set nu          | 행 번호 표시                     |
| set nonu        | 행 번호 표시X                    |
| set list        | 특수문자 표시                    |
| set nolist      | 특수문자 감추기                  |
| set showmode    | 현재 모드 표시                   |
| set noshowmode  | 현재 모드 감추기                 |
| set             | vi 환경 설정 값 출력             |
| set all         | 모든 vi 환경 변수와 현재 값 출력 |

# 셸 사용법

## 셸 기본 사용법

### 특수문자 사용 방법

**특수문자 * **

| 사용예                                      | 의미                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| ls *                                        | 현재 디렉터리의 모든 파일과 서브 디렉터리 나열. 서브 디렉터리 내용도 출력<br />![image-20240219210708375](.\assets\image-20240219210708375.png) |
| cp * /temp<br />sudo cp -a * ~/Desktop/temp | 현재 디렉터리의 모든 파일을 /tmp 디렉터리 아래로 복사<br />![image-20240219211038744](.\assets\image-20240219211038744.png) |
| ls -F s*                                    | 파일명이 t로 시작하는 모든 파일의 이름과 파일 종류를 출력<br />![image-20240219211215343](.\assets\image-20240219211215343.png) |
| cp *.py ../copypy                           | 확장자가 .py인 모든 파일을 상위 디렉터리 아래의 copypy 디렉터리로 복사<br />![image-20240219211403104](.\assets\image-20240219211403104.png) |
| ls -l a*y                                   | 파일명이 h로 시작하고 d로 끝나는 모든 파일의 상세 정보를 출력<br />![image-20240219211519885](.\assets\image-20240219211519885.png) |

**특수문자 ? 와 []**

| 사용예                   | 의미                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ls -l test[135abcde].txt | 숫자 1, 3, 5 문자 a, b, c, d, e <br />![image-20240221201654339](.\assets\image-20240221201654339.png) |
| ls -l test[1-3].txt      | 숫자 1-3 사이<br />![image-20240221201811803](.\assets\image-20240221201811803.png) |
| ls [0-9]*                | 숫자 0-9 사이<br />![image-20240221202045091](.\assets\image-20240221202045091.png) |

**특수문자 ~와 -**

| 사용 예         | 의미                                                         |
| --------------- | ------------------------------------------------------------ |
| cp *.txt ~/temp | ![image-20240221202604156](.\assets\image-20240221202604156.png) |
| cd -            | ![image-20240221203123696](.\assets\image-20240221203123696.png) |

**특수문자 ;과 |**

| 사용 예          | 의미                                                         |
| ---------------- | ------------------------------------------------------------ |
| date; ls; pw     | ![image-20240221203310973](.\assets\image-20240221203310973.png) |
| ls -al / \| more | ![image-20240221203403068](.\assets\image-20240221203403068.png) |

**특수문자 ' '와 " "**

' ' : 모든 특수문자 무효화

" " : $, `, \ 를 제외한 특수문자 무효화

| 사용 예       | 의미                                                         |
| ------------- | ------------------------------------------------------------ |
| echo '$SHELL' | ![image-20240221203713942](.\assets\image-20240221203713942.png) |
| echo "$SHELL" | ![image-20240221204021183](.\assets\image-20240221204021183.png) |

**특수문자 ``**

| 사용 예                                           | 의미                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| echo "Today is `date`(원래는 ``로 date를 감싼것)" | ![image-20240221204312501](.\assets\image-20240221204312501.png) |
| ls /usr/bin/`uname -m`                            |                                                              |

![image-20240221205056127](.\assets\image-20240221205056127.png)

**특수문자 \ **

| 사용 예                  | 의미                                                         |
| ------------------------ | ------------------------------------------------------------ |
| touch t\*<br />ls -l t\* | ![image-20240221205442271](.\assets\image-20240221205442271.png) |
| echo \$SHELL             | ![image-20240221205526479](.\assets\image-20240221205526479.png) |

**특수문자 >, <, >>**

`>` : 덮어쓰기
명령 [파일 디스크립터]> 파일명 ([파일 디스크립터]와 > 사이에 공백X)
ex) ls -l 0> res.txt 

| 사용 예          | 의미                                                         |
| ---------------- | ------------------------------------------------------------ |
| ls -l > res.txt  | ![image-20240221205719684](.\assets\image-20240221205719684.png) |
| ls -l >> res.txt | ![image-20240221205829814](.\assets\image-20240221205829814.png)<br /><br />![image-20240221205842102](.\assets\image-20240221205842102.png) |
| cat < text.txt   | ![image-20240221211040986](.\assets\image-20240221211040986.png) |

## 입출력 방향 변경

입력도 키보드로 하는 것이 아니라 파일에서 읽어오도록 할 수 있다.

리눅스에서 입력과 출력으로 사용하는 장치를 바꾸면 출력을 화면이 아닌 파일에 하고 입력도 파일에서 받을 수 있다.

입출력 장치를 바꾼다.

### 표준 입출력 장치

표준 출력과 별도로 오류 메시지를 내보내는 장치를 표준 오류 장치라고 한다.

리눅스는 장치도 파일로 관리한다.

셸은 작업 중 필요한 파일에 일련번호를 붙여서 관리하며 이를 '파일 디스크립터'라고 한다.

표준 입출력 장치도 파일로 관리되기 때문에 파일 디스크립터가 부여되어 있다.

입출력 장치를 변경할 때는 이 파일 디스크립터를 사용한다.

표준 입출력 장치를 파일로 바꾸는 것을 '리다이렉션'이라고 한다.

| ㅁ파일 디스크립터 | 파일 디스크립터 대신 사용하는 이름 | 정의             |
| ----------------- | ---------------------------------- | ---------------- |
| 0                 | stdin                              | 명령의 표준 입력 |
| 1                 | stdout                             | 명령의 표준 출력 |
| 2                 | stderr                             | 명령의 표준 오류 |

### 출력 리다이렉션

**> (Overwrite)**

![image-20240221211501262](.\assets\image-20240221211501262.png)

![image-20240221211728857](.\assets\image-20240221211728857.png)

![image-20240221211814051](.\assets\image-20240221211814051.png)

![image-20240221211933332](.\assets\image-20240221211933332.png)

*194p [240221수2224]*

**set 명령**

![image-20240223223102657](.\assets\image-20240223223102657.png)

```
set: set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]
```

```
Set or unset values of shell options and positional parameters.

Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.
```

```
-C  If set, disallow existing regular files to be overwritten
          by redirection of output.
```

**>> (append)**

![image-20240223223648585](.\assets\image-20240223223648585.png)

### 오류 리다이렉션

표준 출력은 1번, 표준 오류는 2번 장치 파일이다.

![image-20240223224125140](.\assets\image-20240223224125140.png)

![image-20240223224214513](.\assets\image-20240223224214513.png)

### 입력 리다이렉션

https://ehpub.co.kr/15-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%95%84%EC%9A%94/

```c
// demo2.c

#include <stdio.h>

int main(void) {
    int num;
    char name[20] = "";

    printf("번호입력 : \n");
    scanf("%d", &num);
    printf("이름입력 : \n");
    scanf("%s", &name);

    printf("번호 : %d, 이름 : %s\n", num, name);

    return 0;
}
```

```
// input
3
홍길동
```

![image-20240223230511292](.\assets\image-20240223230511292.png)

```
3
홍길동
```

![image-20240223230538437](.\assets\image-20240223230538437.png)

## 배시셸 환경 설정

### 셸 변수와 환경 변수

셸 변수는 현재 셸에서만 사용할 수 있고 서브 셸로는 전달되지 않지만, 환경 변수는 현재 셸뿐만 아니라 서브 셸로도 전달된다.

**주요 셸 환경 변수**

| 환경 변수 | 의미                           |
| --------- | ------------------------------ |
| HISTSIZE  | 히스토리 저장 크기             |
| HOME      | 사용자 홈 디렉토리의 절대 경로 |
| LANG      | 사용하는 언어                  |
| LOGNAME   | 사용자 계정 이름               |
| PATH      | 명령을 탐색할 경로             |
| PWD       | 작업 디렉토리의 절대 경로      |
| SHELL     | 로그인 셸                      |

![image-20240223231531832](.\assets\image-20240223231531832.png)

### 셸 변수와 환경 변수 설정

변수명=문자열

셸 변수로는 설정했지만 환경 변수로는 설정하지 않았다.

환경 변수로 설정하면 셸 변수로도 설정이 된다.

환경 변수 : 전역 변수 / 셸 변수 : 지역 변수

![image-20240223234145459](.\assets\image-20240223234145459.png)

### 변수 해제

![image-20240223234223599](.\assets\image-20240223234223599.png)

## 앨리어스와 히스토리

![image-20240223234335036](.\assets\image-20240223234335036.png)

![image-20240223234546373](.\assets\image-20240223234546373.png)

![image-20240223234555843](.\assets\image-20240223234555843.png)

![image-20240223234603618](.\assets\image-20240223234603618.png)

![image-20240223235231868](.\assets\image-20240223235231868.png)

![image-20240223235323282](.\assets\image-20240223235323282.png)

![image-20240224000214141](.\assets\image-20240224000214141.png)

배시셸에서는 앨리어스로 인자를 전달할 수 없다.

배시셸에서 인자를 전달하려면 프로그래밍 기능에서 함수를 사용해야 한다.

함수를 제거하려면 셸을 종료하면 된다.

![image-20240224000448989](.\assets\image-20240224000448989.png)

### 히스토리

![image-20240224000732007](.\assets\image-20240224000732007.png)

![image-20240224000906837](.\assets\image-20240224000906837.png)

## 환경 설정 파일

| 파일                | 기능                                                         |
| ------------------- | ------------------------------------------------------------ |
| /etc/profile        | * 본셸이나 본셸과 호환되는 모든 셸에 공통으로 적용되는 환경 설정 파일이다.<br />* 배시셸의 경우 /etc/bash.bashrc 파일을 실행한다.<br />* 배시셸이 아닌 경우 프롬프트를 #(root 사용자)나 $(일반 사용자)로 설정한다.<br />* /etc/profile.d/*.sh 파일을 실행한다.<br />![image-20240224004049052](.\assets\image-20240224004049052.png) |
| /etc/bash.bashrc    | * 시스템에 공통으로 적용되는 .bashrc 파일이다.<br />* 기본 프롬프트를 설정한다.<br />* sudo 명령과 관련된 힌트를 설정한다.<br />![image-20240224004121885](.\assets\image-20240224004121885.png) |
| /etc/profile.d/*.sh | * 언어나 명령별로 각각 필요한 환경을 설정한다.<br />* 필요시 설정 파일을 추가한다.<br />![image-20240224004157477](.\assets\image-20240224004157477.png) |



### 사용자 환경 설정 파일

| 파일            | 기능                                                         |
| --------------- | ------------------------------------------------------------ |
| ~/.profile      | * .bashrc 파일이 있으면 실행한다.<br />![image-20240224010054991](.\assets\image-20240224010054991.png)<br />* 경로 추가 등 사용자가 정의하는 환경 설정 파일이다.<br />![image-20240224010134583](.\assets\image-20240224010134583.png) |
| ~/.bashrc       | * 히스토리의 크기를 설정한다.<br />![image-20240224005937166](.\assets\image-20240224005937166.png)<br />* 기본 앨리어스나 함수 등을 설정한다.<br />![image-20240224005958215](.\assets\image-20240224005958215.png) |
| ~/.bash_logout  | * 로그아웃 시 실행할 필요가 있는 함수 등을 설정한다.<br />![image-20240224010255848](\assets\image-20240224010255848.png)<br />$SHLVL은 쉘의 깊이. 1은 최상위 레벨을 의미한다. |
| ~/.bash_aliases | * 사용자가 정의한 앨리어스를 별도 파일로 저장한다.           |

# 파일 접근 권한 관리

## 파일 속성

file : 지정한 파일의 종류를 알려준다.

![image-20240224214415357](.\assets\image-20240224214415357.png)

groups : 사용자가 속한 그룹을 알려준다.

![image-20240224214548767](.\assets\image-20240224214548767.png)

## 파일 접근 권한

### 접근 권한 종류

| 권한 | 파일                                                         | 디렉터리                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 읽기 | 파일을 읽거나 복사할 수 있다.                                | ls 명령으로 디렉터리 목록을 볼 수 있다(ls 명령의 옵션은 실행 권한이 있어야 사용할 수 있다). |
| 쓰기 | 파일을 수정, 이동, 삭제할 수 있다(디렉터리에 쓰기 권한이 있어야 한다). | 파일을 생성하거나 삭제할 수 있다.                            |
| 실행 | 파일을 실행할 수 있다(셸 스크립트나 실행 파일의 경우).       | cd 명령을 사용할 수 있다. 파일을 디렉터리로 이동하거나 복사할 수 있다. |

### 접근 권한 표기 방법

rwx rwx rwx

### 접근 권한 변경 명령

chmod : 파일이나 디렉터리의 접근 권한을 변경한다.

* 기호 모드
* 숫자 모드

## 기호를 이용한 파일 접근 권한 변경

| 구분                 | 문자/기호 | 의미                             |
| :------------------- | :-------- | :------------------------------- |
| 사용자 카테고리 문자 | u         | 파일 소유자                      |
|                      | g         | 파일 소유 그룹                   |
|                      | o         | 소유자와 그룹 이외의 기타 사용자 |
|                      | a         | 전체 사용자                      |
| 연산자 기호          | +         | 권한 부여                        |
|                      | -         | 권한 제거                        |
|                      | =         | 접근 권한 설정                   |
| 접근 권한 문자       | r         | 읽기 권한                        |
|                      | w         | 쓰기 권한                        |
|                      | x         | 실행 권한                        |

![image-20240224215704156](.\assets\image-20240224215704156.png)

## 숫자를 이용한 파일 접근 권한 변경

### 숫자로 환산하는 방법

Q. 근데 왜 읽기 쓰기 실행 순으로 권한이 큰건가? 읽기가 가장 권한이 높은 이유는 뭔가?

| 접근권한 | 환산             | 숫자 | 의미             |
| -------- | ---------------- | ---- | ---------------- |
| rwx      | 111 -> 4 + 2 + 1 | 7    | 읽기, 쓰기, 실행 |
| rw-      | 110 -> 4 + 2 + 0 | 6    | 읽기, 쓰기       |
| r-x      | 101 -> 4 + 0 + 1 | 5    | 읽기, 실행       |
| r--      | ...              | 4    | 읽기             |
| -wx      | ...              | 3    | 쓰기, 실행       |
| -w-      | ...              | 2    | 쓰기             |
| --x      | ...              | 1    | 실행             |
| ---      | ...              | 0    | 권한X            |

| 접근 권한 | 숫자 모드 |
| --------- | --------- |
| rwxrwxrwx | 777       |
| rwxr-xr-x | 755       |
| rw-rw-rw- | 666       |

### 숫자 모드를 이용한 접근 권한 변경

![image-20240224220415672](.\assets\image-20240224220415672.png)

## 기본 접근 권한 설정

파일이나 디렉터리를 생성할 때 기본 접근 권한이 자동으로 설정된다.

![image-20240224220528058](.\assets\image-20240224220528058.png)

### 기본 접근 권한 확인 및 변경

umask : 기본 접근 권한을 출력하거나 변경한다.

ex) umask 0002 : -------w- 권한을 부여하지 않겠다. 즉 쓰여진 숫자의 권한을 부여하지 않겠다.

![image-20240224220626705](.\assets\image-20240224220626705.png)

![image-20240224220652904](.\assets\image-20240224220652904.png)

![image-20240224221243474](.\assets\image-20240224221243474.png)

### 마스크 값의 적용 과정

뺄셈 연산(마스크 값 적용에서는 0에서 1을 뺀 경우는 0)

![image-20240225004618906](.\assets\image-20240225004618906.png)

ex) 

최대 권한(파일)                 : rw- rw- rw-

최대 권한(디렉터리)         : rwx rwx rwx

umask 077                        :  ---  rwx  rwx

`---------------------------------`

파일 권한			      rw- --- ---		  

디렉터리 권한                      rwx --- ---

![image-20240225010753957](.\assets\image-20240225010753957.png)

## 특수 접근 권한 설정

맨 앞자리로 특수 접근 권한 설정

* SetUID : 맨 앞자리가 4
* SetGID : 맨 앞자리가 2
* 스티키 비트 : 맨 앞자리가 1

### SetUID

![image-20240225011331461](.\assets\image-20240225011331461.png)

![image-20240225011425222](.\assets\image-20240225011425222.png)

→ 소유자의 실행 권한에 s가 표기된다. 

set.exe 파일을 실행하면 항상 user1의 권한을 가진다.

흔히 사용하는 명령 중에 setUID가 설정된 명령은 passwd다.

![image-20240225011724253](.\assets\image-20240225011724253.png)

passwd 명령은 사용자 계정의 암호를 바꾼다.

계정의 암호가 저장된 /etc/shadow 파일은 root 계정으로만 수정 가능 → 일반 사용자 수정 불가

그러나 passwd 명령에는 SetUID가 설정되어 있기 때문에 root 권한으로 실행되어 /etc/shadow 파일을 수정해 암호를 바꿀 수 있다.

### SetGID

SetGID가 설정된 파일을 실행하면 해당 파일이 실행되는 동안에는 파일 소유 그룹의 권한으로 실행된다.

set.exe 파일에 SetGID를 설정하면 다음과 같이 그룹의 실행 권한에 's'가 표시된다.

![image-20240225012349677](.\assets\image-20240225012349677.png)

### 스티키 비트

스티키 비트는 SetUID, SetGID와는 다른 특징이 있다.

스티키 비트는 디렉터리에 설정하며, 디렉터리에 스티키 비트가 설정되어 있으면 이 디렉터리에는 누구나 파일을 생성할 수 있다.

즉 누구나 자유롭게 사용이 가능하다.

단, 스티키 비트가 디렉터리에 적용되면 디렉토리의 소유자나 파일 소유자 또는 슈퍼유저가 아닌 사용자들은 파일을 삭제하거나 변경할 수 없다. 그렇지만 파일 또는 디렉터리를 누구나 생성이 가능하다. 대표적인 디렉터리가 /tmp 디렉터리이다.

스티키 비트가 설정이 되면 실행 권한에 't'가 표시된다.

![image-20240225013732047](.\assets\image-20240225013732047.png)

# 프로세스 관리

## 프로세스의 개념

### 프로세스의 부모-자식 관계

리눅스 시스템을 부팅할 때 스케줄러가 실행한 프로세스인 systemd와 kthreadd 프로세스를 제외하면 모든 프로세스는 부모 프로세스를 가지고 있다.

자식 프로세스는 할 일이 끝나면 부모 프로세스에 결과를 돌려주고 종료된다.

### 프로세스의 번호

각 프로세스는 고유한 번호를 가지고 있는데 이를 PID라고 한다. 

리눅스가 부팅될 때 PID 1번 systemd 프로세스와 2번 kthreadd 프로세스가 차례로 실행된다.

1번 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스가 되고, 2번 프로세스는 모든 스레드의 부모 프로세스가 된다.

> 전통적으로 유닉스에서 1번 프로세스는 init 프로세스다.
>
> 그러나 우분투의 경우 init의 기능을 systemd로 바꾸었다.
>
> 다만, 이전 시스템과 호환되도록 1번 프로세스의 이름은 init을 유지하고 있다.
>
> init은 systemd의 심벌릭 링크이다.

### 프로세스의 종류

* 데몬 프로세스

  특정 서비스를 제공하기 위해 존재하며 리눅스 커널에 의해 실행된다.

  데몬은 평소에는 대기 상태로 있다가 서비스 요청이 들어오면 서비스를 제공한다.

* 고아 프로세스

  자식 프로세스가 실행 중인데 부모 프로세스가 먼저 종료되면 자식 프로세스는 고아 프로세스가 된다.

  이 경우 1번 프로세스가 고아 프로세스의 새로운 부모 프로세스가 되어 고아 프로세스가 작업을 마치고 종료될 수 있게 한다.

* 좀비 프로세스

  자식 프로세스는 종료될 때 부모 프로세스에 종료 정보를 보내고, 부모 프로세스가 이 정보를 받으면 자식 프로세스는 프로세스 테이블 목록에서 삭제된다.

  자식 프로세스가 실행을 종료했는데도 프로세스 테이블 목록에 남아 있는 경우가 있는데 이러한 자식 프로세스를 좀비 프로세스라고 한다.

  자식 프로세스의 종료 정보를 부모 프로세스가 읽어 가기를 기다리고 있는 것

  좀비 프로세스는 프로세스 목록에 defunct 프로세스라고 나오기도 한다.

  좀비 프로세스는 kill 명령으로 제가할 수 없으며, SIGCHLD 시그널을 부모 프로세스에 보내어 부모 프로세스가 자식 프로세스를 정리하도록 하거나 부모 프로세스 자체를 종료해야만 한다.

  부모 프로세스가 종료되면 좀비 프로세스는 고아 프로세스가 되고, 새로운 부모인 1번 프로세스는 주기적으로 자식 프로세스의 종료 정보를 확인하여 정리한다.

## 프로세스 관리 명령

### 프로세스 목록 확인

**ps : 현재 단말기에서 실행 중인 프로세스에 대한 정보를 출력한다.**

![image-20240225024225445](.\assets\image-20240225024225445.png)

**-f 옵션 : 프로세스의 상세 정보 출력하기**

![image-20240225024306781](.\assets\image-20240225024306781.png)

| 항목  | 의미                                   |
| ----- | -------------------------------------- |
| UID   | 프로세스를 실행한 사용자 ID            |
| PID   | 프로세스 번호                          |
| PPID  | 부모 프로세스 번호                     |
| C     | CPU 사용량(%)                          |
| STIME | 프로세스의 시작 날짜나 시간            |
| TTY   | 프로세스가 실행된 터미널의 종류와 번호 |
| TIME  | 프로세스 실행 시간                     |
| CMD   | 실행되고 있는 프로그램 이름(명령)      |

**a 옵션 : 터미널에서 실행시킨 프로세스 정보 출력하기**

![image-20240225024705339](.\assets\image-20240225024705339.png)

| 문자        | 의미                                  | 비고     |
| ----------- | ------------------------------------- | -------- |
| R           | 실행 중(running)                      |          |
| S           | 인터럽트가 가능한 대기(sleep) 상태    |          |
| T           | 작업 제어에 의해 정지된(stopped) 상태 |          |
| Z           | 좀비 프로세스(defunct)                |          |
| STIME       | 프로세스의 시작 날짜나 시간           |          |
| s           | 세션 리더 프로세스                    | BSD 형식 |
| +           | 포그라운드 프로세스 그룹              | BSD 형식 |
| l(소문자 L) | 멀티스레드                            | BSD 형식 |

**a옵션과 u옵션 : 터미널에서 실행시킨 프로세스 상세 정보 출력하기**

![image-20240225025916580](.\assets\image-20240225025916580.png)

| 항목  | 의미                                 |
| ----- | ------------------------------------ |
| USER  | 사용자 계정 이름                     |
| %CPU  | 퍼센트로 표시한 CPU 사용량           |
| %MEM  | 퍼센트로 표시한 물리적 메모리 사용량 |
| VSZ   | 사용 중인 가상 메모리의 크기(kB)     |
| RSS   | 사용 중인 물리적 메모리의 크기(kB)   |
| START | 프로세스 시작 시간                   |

**-e 옵션과 -f 옵션 : 전체 프로세스 목록 출력하기(유닉스 옵션)**

TTY 값이 ?인 것은 대부분 데몬으로 시스템이 실행한 프로세스다.

![image-20240225031424798](.\assets\image-20240225031424798.png)

스레드는 CMD에 [ ]로 표시하여 구분한다.

![image-20240225031524380](.\assets\image-20240225031524380.png)

**ax 옵션과 aux 옵션 : 전체 프로세스 목록 출력하기(BSD 옵션) : ax 옵션과 aux 옵션**

![image-20240225031842584](.\assets\image-20240225031842584.png)

![image-20240225031900522](.\assets\image-20240225031900522.png)

**-u 옵션 : 특정 사용자의 프로세스 목록 출력하기**

![image-20240225031950004](.\assets\image-20240225031950004.png).

![image-20240225032021907](.\assets\image-20240225032021907.png)

**-p 옵션 : 특정 프로세스 정보 출력하기**

![image-20240225032244705](.\assets\image-20240225032244705.png)

### 특정 프로세스 정보 검색

pgrep : 지정한 패턴과 일치하는 프로세스의 PID를 출력한다.

![image-20240225070533231](.\assets\image-20240225070533231.png)

-x(exact) 옵션 : 패턴과 정확히 일치하는 프로세스의 PID를 출력한다.

![image-20240225070650411](.\assets\image-20240225070650411.png)

-n(newset) 옵션 : 패턴을 포함하고 있는 가장 최근 프로세스의 PID를 출력한다.

![image-20240225071405212](.\assets\image-20240225071405212.png)

-u(uid) [사용자 이름] 옵션 : 특정 사용자에 대한 모든 프로세스 PID를 출력한다.

![image-20240225071818213](.\assets\image-20240225071818213.png)

-l(list-name) : PID와 프로세스 이름을 출력한다.

![image-20240225071945586](.\assets\image-20240225071945586.png)

-t(terminal) [term] : 특정 단말기와 관련된 프로세스의 정보를 출력한다.

![image-20240225072132308](.\assets\image-20240225072132308.png)

차후 과제) pgrep -t 명령으로 /dev 디렉토리에 있는 모든 파일의 프로세스를 확인하는 쉘스크립트 작성 후 실행 및 결과물 올리기

![image-20240225083629169](.\assets\image-20240225083629169.png)

![image-20240225084730297](.\assets\image-20240225084730297.png)

![image-20240225084631255](.\assets\image-20240225084631255.png)

리눅스 시스템에서 동시에 여러 사용자가 접속해있을 때

![image-20240225085011483](.\assets\image-20240225085011483.png)

### 프로세스 종료

응답이 없는 프로세스나 불필요한 프로세스를 강제로 종료하려면 해당 프로세스의 PID를 알아야 한다.

프로세스를 종료하는 데는 kill이나 pkill 명령을 사용한다. 

이 명령들은 프로세스에 시그널을 보내 프로세스를 종료한다.

시그널은 프로세스에 무언가 발생했음을 알리는 간단한 메시지다.

이 메시지에는 무엇이 발생했는지를 나타내는, 미리 정의된 상수를 사용한다.

시그널을 받은 프로세스는 기본적으로 종료된다.

다음은 시그널 목록이다.

![image-20240225085613598](.\assets\image-20240225085613598.png)

| 시그널  | 번호 | 기본 처리      | 의미                                                         |
| ------- | ---- | -------------- | ------------------------------------------------------------ |
| SIGHUP  | 1    | 종료           | 터미널과 연결이 끊겼을 때 발생한다.                          |
| SIGINT  | 2    | 종료           | 인터럽트로 사용자가 Ctrl + c를 입력하면 발생한다.            |
| SIGQUIT | 3    | 종료, 코어덤프 | 종료 신호로 사용자가 Ctrl + \를 입력하면 발생한다.           |
| SIGKILL | 9    | 종료           | 이 시그널을 받은 프로세스는 무시할 수 없으며 강제로 종료된다. |
| SIGALRM | 14   | 종료           | 알람에 의해 발생한다.                                        |
| SIGTERM | 15   | 종료           | kill 명령이 보내는 기본 시그널이다.                          |

kill : 지정한 시그널을 프로세스에게 보낸다.

kill [-시그널] PID...

![image-20240225095601531](.\assets\image-20240225095601531.png)

![image-20240225095616668](.\assets\image-20240225095616668.png)

![image-20240225095655634](.\assets\image-20240225095655634.png)

![image-20240225095712529](.\assets\image-20240225095712529.png)

pkill [명령 이름]

![image-20240225095858795](.\assets\image-20240225095858795.png)

![image-20240225095914009](.\assets\image-20240225095914009.png)

![image-20240225100354759](.\assets\image-20240225100354759.png)

※ 따라해보기

![image-20240225100632811](.\assets\image-20240225100632811.png)

![image-20240225100909845](.\assets\image-20240225100909845.png)

![image-20240225101243516](.\assets\image-20240225101243516.png)

![image-20240225101305612](.\assets\image-20240225101305612.png)

![image-20240225101425352](.\assets\image-20240225101425352.png)

![image-20240225101538945](.\assets\image-20240225101538945.png)

※ 혼자해보기

터미널 1에서 cron 프로세스 검색. 사용자 ID와 터미널 번호가 보이도록.

![image-20240225102007545](.\assets\image-20240225102007545.png)

검색한 결과 중 UID가 root인 프로세스를 종료. 종료되지 않는다면 이유는?

![image-20240225102208385](.\assets\image-20240225102208385.png)

: 시스템 프로세스이므로

### 프로세스 관리 도구

**top 명령**

현재 실행 중인 프로세스의 정보를 주기적으로 출력

| 항목                   | 의미                                                 |
| ---------------------- | ---------------------------------------------------- |
| PID(Process ID)        | 프로세스 ID. 각 프로세스를 구별하는 유일한 숫자.     |
| USER                   | 사용자 계정 - 프로세스를 실행하는 사용자의 이름      |
| PR(Priority)           | 프로세스의 실행 우선순위                             |
| NI(Nice Value)         | Nice 값. 프로세스의 실행 우선순위에 영향을 미치는 값 |
| VIRT(Virtual Memory)   | 프로세스가 사용하는 가상 메모리의 크기               |
| RES(Resident Set Size) | 프로세스가 사용하는 실제 물리 메모리의 크기          |
| SHR(Shared Memory)     | 프로세스가 사용하는 공유 메모리의 크기               |
| %CPU                   | 프로세스가 CPU를 사용하는 비율                       |
| TIME+                  | 프로세스가 CPU를 사용한 누적 시간                    |
| COMMAND                | 프로세스를 실행하는 명령어의 이름                    |

![image-20240225103915648](.\assets\image-20240225103915648.png)

![image-20240225103946113](.\assets\image-20240225103946113.png)

| top 명령의 내부 명령 | 기능                                                   |
| -------------------- | ------------------------------------------------------ |
| Enter, Space Bar     | 화면을 다시 출력한다.                                  |
| h, ?                 | 도움말 화면을 출력한다.                                |
| k                    | 프로세스를 종료한다. 종료할 프로세스의 PID를 물어본다. |
| n                    | 출력하는 프로세스의 개수를 바꾼다.                     |
| u                    | u 사용자에 따라 정렬하여 출력한다.                     |
| M                    | 사용하는 메모리 크기에 따라 정렬하여 출력한다.         |
| p                    | CPU 사용량에 따라 정렬하여 출력한다.                   |
| q                    | top 명령을 종료한다.                                   |

**시스템 감시**

[프로그램 표시] - [시스템 감시]

## 포그라운드/백그라운드 프로세스와 작업 제어

### 포그라운드 작업과 백그라운드 작업

**포그라운드 작업**

![image-20240228195446674](.\assets\image-20240228195446674.png)

**백그라운드 작업**

![image-20240228195513000](.\assets\image-20240228195513000.png)

![image-20240228195658066](.\assets\image-20240228195658066.png)

### 작업 제어

jobs : 백그라운드 작업을 모두 보여준다. 특정 작업 번호를 지정하면 해당 작업의 정보만 보여준다.

![image-20240228195825767](.\assets\image-20240228195825767.png)

**작업 전환하기**

| 명령           | 기능                                                         |
| -------------- | ------------------------------------------------------------ |
| Ctrl + z       | 포그라운드 작업을 중지한다(종료하는 것이 아니라 잠시 중단하는 것) |
| bg % 작업 번호 | 작업 번호가 지시하는 작업을 백그라운드 작업으로 전환한다.    |
| fg % 작업 번호 | 작업 번호가 지시하는 작업을 포그라운드 작업으로 전환한다.    |

![image-20240228200049053](.\assets\image-20240228200049053.png)

![image-20240228200218320](.\assets\image-20240228200218320.png)

**작업 종료하기 : Ctrl + c**

![image-20240228200248701](.\assets\image-20240228200248701.png)

![image-20240228200324722](.\assets\image-20240228200324722.png)

**로그아웃 후에도 백그라운드 작업 계속 실행하기**

nohup : 로그아웃한 후에도 백그라운드 작업을 계속 실행한다.

![image-20240228200604365](.\assets\image-20240228200604365.png)

![image-20240228200830227](.\assets\image-20240228200830227.png)

![image-20240228200904707](.\assets\image-20240228200904707.png)

**※ 따라해보기 : 작업 전환하기**

1. 실습 디렉터리를 만들고 이동한다.

   ![image-20240228201122341](.\assets\image-20240228201122341.png)

2. 다음과 같이 백그라운드 작업을 만든다.

   * 파일을 하나 복사하고 vi 명령을 실행한다.

   * Ctrl + z를 실행하여 vi 작업을 일시 정지한다.

     ![image-20240228201342064](.\assets\image-20240228201342064.png)

3. jobs 명령으로 백그라운드 작업을 확인한다.

   ![image-20240228201419869](.\assets\image-20240228201419869.png)

4. 정지 중인 작업을 fg 명령을 사용하여 복구한다.

   ![image-20240228201542204](.\assets\image-20240228201542204.png)

5. q!로 vi를 종료한다.

   ![image-20240228201518679](.\assets\image-20240228201518679.png)

## 작업 예약

### 정해진 시간에 한 번 실행

at : 예약한 명령을 정해진 시간에 실행한다.

at 명령이 설치되지 않았다면 설치한다.

![image-20240228201715535](.\assets\image-20240228201715535.png)

at 명령의 결과를 파일로 저장하도록 설정하지 않으면 메일로 보내지므로 메일이 설치되어 있어야 한다. 다음과 같이 메일 패키지를 설치한다.

![image-20240228202039623](.\assets\image-20240228202039623.png)

**at 명령 설정하기**

(at 작업 종료는 Ctrl + d이다.)

* at 4pm + 3 days : 지금부터 3일 후 오후 4시에 작업을 수행한다.
* at 10am Jul 31 : 7월 31일 오전 10시에 작업을 수행한다.
* at 1am tomorrow : 내일 오전 1시에 작업을 수행한다.
* at 10:00am today : 오늘 오전 10시에 작업을 수행한다.

![image-20240228202918269](.\assets\image-20240228202918269.png)

![image-20240228203029273](.\assets\image-20240228203029273.png)

**at 작업 목록 확인하기 : -l 옵션과 atq 명령**

![image-20240228203246261](.\assets\image-20240228203246261.png)

atq : 현재 사용자의 등록된 작업 목록을 보여준다. 슈퍼유저일 경우 모든 사용자의 작업 목록을 보여준다.

![image-20240228203405717](.\assets\image-20240228203405717.png)

**at 작업 삭제하기 : -d 옵션과 atrm 명령**

at 명령으로 설정한 작업이 실행되기 전에 삭제하려면 -d 옵션을 사용하고 삭제할 작업 번호를 지정한다. atrm 명령은 at -d와 같은 기능을 수행한다.

atrm : 지정된 작업 번호와 작업을 삭제한다.

![image-20240228203807240](.\assets\image-20240228203807240.png)

![image-20240228203903216](.\assets\image-20240228203903216.png)

**at 명령 사용 제한하기**

시스템 관리자는 일반 사용자들이 at 명령을 사용하도록 허용하거나 사용하지 못하도록 제한할 수 있다.

이와 관련된 파일은 /etc/at.allow 파일어 지정하고, at 명령의 사용이 금지된 사용자들은 /etc/at.deny 파일에 지정한다.

at.deny 파일은 기본적으로 있지만 at.allow 파일은 없으므로 필요할 때에 관리자가 만들어야 한다.

/etc/at.allow 파일과 /etc/at.deny 파일은 기본적으로 있지만 at.allow 파일은 없으므로 필요할 때에 관리자가 만들어야 한다.

/etc/at.allow 파일과 /etc/at.deny 파일에는 사용자 이름을 한 줄에 하나씩만 입력한다. 두 파일의 적용 기준은 다음과 같다.

* /etc/at.allow 파일이 있으면 이 파일에 지정된 사용자만 at 명령을 사용할 수 있다. 이 경우 /etc/at.deny 파일은 무시된다.
* /etc/at.allow 파일이 없으면 /etc/at.deny 파일에 지정된 사용자를 제외한 모든 사용자가 at 명령을 사용할 수 있다.
* 만약 두 파일이 모두 없다면 root만 at 명령을 사용할 수 있다.
* 사용자가 두 파일 모두에 속해 있다면 at 명령을 사용할 수 있다. /etc/at.allow 파일이 적용되기 때문이다.
* /ect/at.deny를 빈 파일로 두면 모든 사용자가 at 명령을 사용할 수 있는데, 이것이 초기 설정이다.

### 정해진 시간에 반복 실행

crontab :  사용자의 crontab 파일을 관리한다.

**crontab 파일 형식**

![image-20240228230345320](.\assets\image-20240228230345320.png)

**crontab 파일 생성하고 편집하기 : crontab -e**

![image-20240228232255819](.\assets\image-20240228232255819.png)

![image-20240228232726189](.\assets\image-20240228232726189.png)

![image-20240228232806585](.\assets\image-20240228232806585.png)

![image-20240228232818803](.\assets\image-20240228232818803.png)

**crontab -l : crontab 파일 내용 확인하기**

![image-20240228232903324](.\assets\image-20240228232903324.png)

**crontab -r : crontab 파일 삭제하기**

![image-20240228232947473](.\assets\image-20240228232947473.png)

**crontab 명령 사용 제한하기**

at 명령과 마찬가지로 crontab 명령도

* /etc/cron.allow 파일과
* /etc/cron.deny 파일로

crontab 명령 사용 권한을 제한할 수 있다.

# 파일 시스템과 디스크 관리

## 리눅스 파일 시스템 종류

### 디스크 기반 파일 시스템

리눅스는 초기에 미닉스의 파일 시스템을 사용했으나 곧 ext 파일 시스템으로 알려진 리눅스 고유의 파일 시스템을 만들어 사용하게 되었다.

현재는 ex4 파일 시스템을 사용 중이다.

### 특수 용도의 가상 파일 시스템

| 파일 시스템 | 기능                                                         |
| ----------- | ------------------------------------------------------------ |
| swap        | 스왑 영역을 관리하기 위한 스왑 파일 시스템이다.              |
| tmpfs       | * Temporary File System으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며, 시스템이 재시작할 때마다 기존 내용이 없어진다.<br />* /tmp 디렉터리를 예로 들 수 있다. |
| proc        | * proc 파일 시스템으로 /proc 디렉터리이다.<br />* 커널의 현재 상태를 나타내는 파일을 가지고 있다. |
| ramfs       | 램디스크를 지원하는 파일 시스템이다.                         |
| rootfs      | * Root File System으로 / 디렉터리다.<br />* 시스템 초기화 및 관리에 필요한 내용을 관리한다. |

### 현재 시스템이 지원하는 파일 시스템 확인

![image-20240301083652359](.\assets\image-20240301083652359.png)

## 리눅스 파일 시스템 구조

### ex4 파일 시스템의 구조

ex4 파일 시스템은 효율적으로 디스크를 관리하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분한다.

일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 달라질 수 있다. 

블록 그룹의 개수는 장치의 크기를 블록 그룹의 크기로 나눈 값이다.

블록 그룹에는 세 가지 유형이 있다.

* 블록 그룹 0 : 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 슈퍼 블록, 그룹 디스크립터를 가지고 있다.
* 블록 그룹 a : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩이 없으나 슈퍼 블록과 그룹 디스크립터의 복사본을 가지고 있다.
* 블록 그룹 b : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩, 슈퍼 블록, 그룹 디스크립터가 없고 바로 데이터 블록 비트맵으로 시작한다.

![image-20240301180528688](.\assets\image-20240301180528688.png)

**그룹 0 패딩**

블록 그룹 0의 첫 1024B는 특별한 목적으로 사용되는데, x86 부트 섹터와 부가 정보를 저장하기 위한 것이다.

**슈퍼 블록**

슈퍼 블록에는 파일 시스템과 관련된 다양한 정보가 저장된다.

* 전체 inode 개수
* 전체 블록의 개수
* 할당되지 않은 블록(free block)의 개수
* 할당되지 않은 inode(free inode)의 개수
* 첫 번째 데이터 블록의 주소
* 블록의 크기
* 그룹당 블록의 개수
* 마운트 시간
* 파일 시스템의 상태
* 그룹 디스크립터의 크기

**그룹 디스크립터와 GDT 예약 블록**

그룹 디스크립터도 블록 그룹 0에 있는 것으로 슈퍼 블록 다음에 위치한다.

* 블록 비트맵 주소
* inode 비트맵의 주소
* inode 테이블의 주소
* 할당되지 않은 블록의 개수
* 할당되지 않은 inode의 개수
* 디렉터리의 개수
* 블록 비트맵, inode 비트맵 체크섬

**데이터 블록 비트맵과 inode 비트맵**

cf) : 비트맵(영어: BMP file format, DIB file format 또는 bitmap, 문화어: 비트매프, 이진 숫자 배렬표)은 컴퓨터 분야에서 디지털 이미지를 저장하는 데 쓰이는 이미지 파일 포맷 또는 메모리 저장 방식의 한 형태이다.

데이터 블록 비트맵은 블록 그룹에 포함된 데이터 블록의 사용 여부를 확인하는 데 쓰임

inode 비트맵은 inode 테이블의 항목이 사용 중인지를 표시

비트맵에서 각 데이터 블록과 inode 테이블의 항목은 1비트로 표현된다.

**inode 테이블과 데이터 블록**

일반적인 유닉스처럼 리눅스에서도 inode에 파일 정보를 저장한다.

데이터 블록에는 실제 데이터가 저장된다.

일반 파일은 데이터 블록에 파일 내용을 저장하고, 

디렉터리는 데이터 블록에 해당 디렉터리에 있는 파일이나 서브 디렉터리의 정보(이름, inode)를 저장한다.

### inode 구조

![image-20240302004122976](.\assets\image-20240302004122976.png)

inode는 크게 두 부분,

* **파일 정보**를 저장하는 부분과
* 실제 파일 내용이 저장된 **데이터 블록의 주소**를 저장하는 부분으로 나뉜다.

inode에서 데이터 블록의 주소를 저장하는 부분은

* 직접 블록(direct block),
* 간접 블록(indirect block),
* 이중 간접 블록(double indirect block)으로 구분된다.

직접 블록은 데이터 블록에 대한 주소를 직접 가지고 있다.

간접 블록과 이중 간접 블록에는 데이터 블록에 대한 주소를 가지고 있는 블록의 주소가 저장된다.

데이터 블록의 크기는 시스템 설정에 따라 1~8KB 까지 지정할 수 있다.

### 파일 시스템과 디렉터리 계층 구조

실제 파일이 저장된 파일 시스템은 디렉터리 계층 구조에 연결되어야 사용자가 접근하여 사용할 수 있다.

**한 파일 시스템으로 구성하기**

디렉터리 계층 구조에서 보이는 모든 디렉터리와 파일은 하나의 파일 시스템에 둘 수도 있고 여러 파일 시스템에 나누어 구성할 수도 있다.

하나의 파일 시스템으로 구성할 경우 아래와 같이 / 디렉터리에 해당 파일 시스템을 연결한다.

![image-20240302010241406](.\assets\image-20240302010241406.png)

**여러 파일 시스템으로 구성하기**

디렉터리의 계층 구조를 여러 파일 시스템으로 구분하여 구성할 수도 있다.

/ 디렉터리에 연결된 파일 시스템을 루트 파일 시스템이라고 한다.

여러 파일 시스템으로 나누어 디렉터리 계층 구조를 구성할 경우, 일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템은 안전하다.

![image-20240302011447920](.\assets\image-20240302011447920.png)

## 파일 시스템 마운트

### 마운트 포인트

디렉터리 계층 구조에서 각각의 파일 시스템이 연결되는 디렉터리를 마운트 포인트라고 한다.

### 파일 시스템 마운트 설정 파일

리눅스에서 시스템이 부팅될 때 자동으로 파일 시스템이 마운트 되게 하려면 /etc/fstab 파일에 관련 사항을 설정해야 한다.

**/etc/fstab 파일의 기능**

/etc/fstab 파일은 파일 시스템의 마운트 설정 정보를 가지고 있다.

리눅스 시스템은 부팅할 때 이 파일을 읽고 설정 내용에 따라 파일 시스템을 자동으로 마운트하며,

이 파일에 오류가 있으면 시스템 부팅이 중지될 수도 있다.

/etc/fstab 파일에는 파일 시스템의 장치명과 마운트 포인트, 마운트할 때 설정할 옵션을 지정한다.

**/etc/fstab 파일의 구조**

![image-20240302012219324](.\assets\image-20240302012219324.png)

![image-20240302011841452](.\assets\image-20240302011841452.png)

* 장치명 : PARTUUID=cca89262-02
* 마운트 포인트 : /
* 파일 시스템 종류 : ext4
* 옵션 : defaults, noatime
* 덤프 관련 설정 : 0
* 파일 점검 옵션 : 1

1. 장치명

   /dev/sda1과 같이 특정 디스크를 지정하는 것이다.

   앞서 본 파일 시스템 3개가 마운트된 그림을 보면 파일 시스템에 구축된 물리적인 디스크 장치가 3개 있고,

   그 장치의 이름을 첫 번째 항목으로 설정하는 것이다.

   UUID는 시스템의 하드웨어 정보와 시간 정보가 조합되어 랜덤으로 생성되며,

   디스크가 추가될 때 부트 로더가 있는 부트 장치의 이름이 바뀌는 것을 방지하기 위해 사용된다.

2. 마운트 포인트

   앞서 본 파일 시스템 3개가 마운트된 그림을 보면 파일 시스템 3의 마운트 포인트는 /home이 된다.

   마운트 포인트가 /인 것은 / 디렉터리이므로 이는 루트 파일 시스템이라는 뜻이다.

3. 파일 시스템의 종류

   위의 파일 시스템을 보면 첫 번째 파일 시스템은 vfat, 두 번째 파일 시스템은 ex4임을 알 수 있다.

4. 옵션

   이 항목에 올 수 있는 값은 파일 시스템에 따라 다르며 일반적으로 사용하는 옵션은 아래의 표와 같다.

   | 옵션     | 의미                                                         |
   | -------- | ------------------------------------------------------------ |
   | defaults | 일반적인 파일 시스템에 지정하는 속성이다. rw, nouser, auto, exec, suid 속성을 모두 포함한다. |
   | auto     | 부팅 시 자동으로 마운트한다.                                 |
   | exec     | 실행 파일이 실행되는 것을 허용한다.                          |
   | suid     | setuid, setgid의 사용을 허용한다.                            |
   | ro       | 읽기 전용 파일이다.                                          |
   | rw       | 읽기, 쓰기가 가능한 파일 시스템이다.                         |
   | user     | 일반 사용자도 마운트가 가능하다.                             |
   | nouser   | 일반 사용자는 마운트가 불가능하다. root만 마운트할 수 있다.  |
   | noauto   | 부팅 시 자동으로 마운트하지 않는다.                          |
   | noexec   | 실행 파일이 실행되는 것을 허용하지 않는다.                   |
   | nosuid   | setuid, setgid의 사용을 금지한다.                            |
   | usrquota | 사용자별로 디스크 쿼터 설정이 가능하다.                      |
   | grpquota | 그룹별로 디스크 쿼터 설정이 가능하다.                        |

5. 덤프 관련 설정

   0의 경우 dump 명령으로 파일 시스템의 내용이 덤프되지 않는 파일 시스템이고,

   1의 경우 데이터 백업 등을 위해 dump 명령의 사용이 가능한 파일 시스템이다.

6. 파일 점검 옵션

   0은 부팅할 때 fsck 명령으로 파일 시스템을 점검하지 않도록 하는 설정이고

   1은 루트 파일 시스템을,

   2는 루트 파일 시스템 이외의 파일 시스템을 의미한다.

   즉 부팅할 때 0으로 지정된 파일 시스템은 fsck 명령을 실행하지 않으며, 

   다음으로 1번인 루트 파일 시스템이 fsck 명령으로 파일 시스템 점검을 수행하고,

   나머지 2로 설정된 파일 시스템들은 나열된 순서대로 fsck 명령을 사용하여 점검하게 된다.

### 마운트 관련 명령

mount : 파일 시스템을 마운트한다.

umount : 파일 시스템을 언마운트한다.

**mount 명령만 사용하는 경우**

옵션이나 인자를 지정하지 않고 mount 명령을 사용하면 다음과 같이 현재 마운트되어 있는 정보가 출력된다.

![image-20240302014950031](.\assets\image-20240302014950031.png)

mount 명령으로 출력되는 정보는 /etc/mtab 파일 내용과 동일하다.

![image-20240302015124324](.\assets\image-20240302015124324.png)

/etc/mtab 파일에는 현재 시스템에 마운트되어 있는 파일 시스템의 정보가 저장되어 있다.

이 파일은 /proc/mounts에 대한 심볼릭 링크로 읽기 전용 파일이므로 내용을 수정할 수 없다.

**장치 연결하기 : mount**

하드디스크를 디렉터리 계층 구조에 연결할 때는 기본적으로 다음과 같은 형태로 mount 명령을 사용한다.

/dev/sdb1은 하드 디스크 장치의 이름이고 /mnt는 마운트 포인트이다.

![image-20240302015800067](.\assets\image-20240302015800067.png)

이외에 다른 종류의 파일 시스템이나 CD-ROM, USB 메모리 같은 이동식 저장 장치와 윈도 포맷의 디스크 등 다양한 장치를 디렉터리 계층 구조에 연결하려면 mount 명령을 사용한다.

**※ 따라해보기 : 리눅스용 USB 메모리 연결**

USB 메모리를 마운트할 때 고려해야 할 사항은 이 메모리가 리눅스용인지 윈도용인지를 구분하는 것이다.

리눅스용 USB 메모리는 리눅스에서 포맷하고 리눅스 파일 시스템을 생성한 메모리를 의미한다.

1. USB 메모리를 리눅스 시스템에 인식시키기

   USB를 꽂고 mount 명령을 통해 USB 메모리가 추가 됨을 알 수 있다.

   가장 아래의 /dev/sda1이 USB 장치가 추가 됨을 알 수 있다.

   ![image-20240302020527473](.\assets\image-20240302020527473.png)

2. USB 메모리의 장치명 확인하기

   USB의 장치명은 맨 밑의 /dev/sda1 임을 알 수 있다.

   세부 내용은 USB 상태에 따라 다르게 나타날 수 있다.

   아래 USB Type을 보면 Microsoft 즉, 리눅스용이 아닌 윈도용 USB임을 알 수 있다.

![image-20240302020613450](.\assets\image-20240302020613450.png)

![image-20240302020625280](.\assets\image-20240302020625280.png)

3. USB 메모리에 파티션 생성하기

   파티션작업은 일반 하드디스크에서 수행하는 것과 동일하게 fdisk 명령을 사용한다.

   ![image-20240302025339294](.\assets\image-20240302025339294.png)

   m을 입력하여 사용할 수 있는 명령을 알아본다.

   ![image-20240302025412602](.\assets\image-20240302025412602.png)

   새로운 파티션을 생성하려는 것이므로 n을 입력한다.

   n을 입력하면 파티션을 기본(primary) 파티션으로 할 것인지, 확장(extended) 파티션으로 할 것인지 선택해야 한다.

   기본값은 기본(p) 파티션이다.

   ![image-20240302025533281](.\assets\image-20240302025533281.png)

   기본으로 선택하고 파티션 번호를 1로 지정한다.

   ![image-20240302025733775](.\assets\image-20240302025733775.png)

   ![image-20240302025809609](.\assets\image-20240302025809609.png)

   모두 기본값으로 지정하였고 새로운 파티션이 생성되었다.

   p 명령을 사용하여 파티션이 제대로 설정되었는지 확인한다.

   ![image-20240302025901876](.\assets\image-20240302025901876.png)

   w를 입력하여 설정한 파티션 정보를 파티션 테이블에 기록한다.

   파티션 테이블에 기록되면 이전에 있던 정보가 없어진다.

   이제 USB 파티션이 생성되었다.

4. 생성한 파티션 포맷하고 파일 시스템 생성하기

   파일 시스템을 생성하는 데는 mke2fs 명령을 사용한다.

   ![image-20240302030142007](.\assets\image-20240302030142007.png)

5. USB 파일 시스템 마운트하기

   /mnt 디렉터리에 마운트하였다.

   ![image-20240302030249492](.\assets\image-20240302030249492.png)

6. 디렉터리 사용하기

   ![image-20240302030405240](.\assets\image-20240302030405240.png)

   ![image-20240302030512440](.\assets\image-20240302030512440.png)

7. 장치연결 해제하기 : umount

   ![image-20240302030635929](.\assets\image-20240302030635929.png)

   해당 디렉터리를 사용중이므로 마운트 해제가 안된다.

   다른 디렉터리로 이동 후 마운트 해제한다.

   ![image-20240302030710984](.\assets\image-20240302030710984.png)

**※ 따라해보기 : 윈도용 USB 메모리 연결**

1. USB 메모리를 USB 슬롯에 꽂고 리눅스 시스템에 인식시킨다.

2. USB 메모리가 인식되었으면, USB 메모리의 장치명을 확인한다.

   fdisk -l 명령의 실행 결과를 보면 USB 메모리의 장치명은 /dev/sdb1 임을 알 수 있다.

   ![image-20240302030956734](.\assets\image-20240302030956734.png)

3. USB 메모리를 마운트한다.

   fdisk -l의 결과를 보면 포맷이 Microsoft basic data이다.

   윈도의 파일 시스템은 ntfs이므로 ntfs로 지정하여 마운트한다.

   ![image-20240302031334475](.\assets\image-20240302031334475.png)

   ntfs가 아니라는 오류..

   ext4로 변경 후 마운트한다.

   ![image-20240302031407019](.\assets\image-20240302031407019.png)

   순조롭게 잘된다. 이유가 뭔지...

## 디스크 추가 설치

### 가상 머신에 디스크를 추가하는 방법

### 디스크 파티션을 나누는 방법

### 파일 시스템을 생성하는 방법

### 디스크를 마운트하는 방법

### 여러 디스크를 하나의 디스크로 사용하는 방법

## 디스크 관리

### 디스크 사용량 확인

**df : 파일 시스템별 디스크 사용량 확인하기**

df : 디스크의 남은 공간에 대한 정보를 출력한다.

![image-20240302031803441](.\assets\image-20240302031803441.png)

df 명령으로 출력되는 항목은 다음과 같다.

* 파일 시스템 장치명
* 파일 시스템의 전체 용량
* 파일 시스템의 사용량
* 파일 시스템의 사용 가능한 남은 용량
* 퍼센트로 나타낸 사용량
* 마운트 포인트

**-h : 파일 시스템 사용량을 이해하기 쉬운 단위로 표시하기**

![image-20240302031931057](.\assets\image-20240302031931057.png)

**-T : 파일 시스템의 종류 출력하기**

![image-20240302032006717](.\assets\image-20240302032006717.png)

**du : 디렉터리나 사용자별 디스크 사용량 확인하기**

du : 디스크의 사용 공간에 대한 정보를 출력한다.

![image-20240302032238045](.\assets\image-20240302032238045.png)

**-s : 전체 디스크 사용량 출력하기**

![image-20240302032314560](.\assets\image-20240302032314560.png)

**특정 사용자의 디스크 용량 출력**

![image-20240302032407350](.\assets\image-20240302032407350.png)

**※ 따라해보기**

1. 파일 시스템의 디스크 사용량을 MB 단위로 출력한다.

   ![image-20240302032449878](.\assets\image-20240302032449878.png)

2. ext4 파일 시스템의 디스크 사용량을 출력한다.

   ![image-20240302032513686](.\assets\image-20240302032513686.png)

3. 전체 파일 시스템의 디스크 사용량 출력

   -a 옵션을 사용하면 용량이 0인 파일 시스템의 정보도 출력한다.

   크기가 0인 파일 시스템은 대부분 내부 관리용으로 사용된다.

   ![image-20240302032635999](.\assets\image-20240302032635999.png)

4. /usr 디렉터리가 사용하고 있는 디스크 사용량을 출력한다.

   ![image-20240302032731978](.\assets\image-20240302032731978.png)

### 파일 시스템 검사 및 복구

**fsck : 파일 시스템 검사하기**

fsck : 리눅스의 파일 시스템을 검사한다.

* 일반적인 파일 시스템 검사

  ![image-20240302043939959](.\assets\image-20240302043939959.png)

* 파일 시스템 강제 검사

  ![image-20240302043901052](.\assets\image-20240302043901052.png)

* 파일 시스템 종류를 지정한 검사

  ![image-20240302044245453](.\assets\image-20240302044245453.png)

**e2fsck : 파일 시스템 검사하기**

e2fsck : 리눅스의 확장 파일 시스템(ext2, ext3, ext4)을 점검한다.

* 일반적인 파일 시스템으로 검사

  ![image-20240302044410517](.\assets\image-20240302044410517.png)

* 파일 시스템 강제 검사

  ![image-20240302044457149](.\assets\image-20240302044457149.png)

**badblocks : 배드 블록 검사하기**

디스크에 발생하는 심각한 문제 중 하나는 배드 블록으로 인한 데이터 유실이다.

물론 백업이나 이중화 구성 등으로 대비하겠지만 주기적으로 배드 블록을 검사하는 것도 매우 중요하다.

badblocks : 장치의 배드 블록을 검사한다.

**배드 블록 검색하기**

![image-20240302045035208](.\assets\image-20240302045035208.png)

**백업 슈퍼 블록을 이용하여 파일 시스템 복구하기**

* dumpe2fs : 백업 슈퍼 블록의 위치 파악하기

  dumpe2fs : 파일 시스템의 정보를 출력한다.

  ![image-20240302045708503](.\assets\image-20240302045708503.png)

  ![image-20240302045851700](.\assets\image-20240302045851700.png)

* **파일 시스템 복구하기**

  dd : 지정한 블록 크기만큼 파일을 복사한다.

  ex) dd if=/dev/zero of=/dev/sda1 bs=4096 count=20

  여기서 if은 조건문이 아닌 input file의 약자이며 of는 out file의 약자이다.

  /dev/zero는 메모리를 null(혹은 0)로 채울 때 사용하는 파일이다.

  bs는 블록 당 바이트 사이즈를 의미하며

  count는 블록의 수를 의미한다.

  ![image-20240302050502181](.\assets\image-20240302050502181.png)

  이제 /dev/sda1 파일 시스템의 기본 슈퍼 블록이 지워졌다.

  따라서 /dev/sda1 파일 시스템을 마운트하면 오류 메시지가 출력된다.

  ![image-20240302050714945](.\assets\image-20240302050714945.png)

  앞에서 dumpe2fs로 확인한 백업 슈퍼 블록을 이용하여 /dev/sda1 파일 시스템을 복구하려면 다음과 같이 한다.

  ![image-20240302050835818](.\assets\image-20240302050835818.png)

  파일 시스템이 복구되었으므로 정상적으로 마운트가 된다.

  ![image-20240302050934331](.\assets\image-20240302050934331.png)

# 리눅스 부팅과 종료

## 리눅스 시스템의 부팅

리눅스의 부팅은 PC의 전원을 켜는 순간부터 리눅스가 완전히 동작하여 로그인 프롬프트가 출력될 때까지를 말한다.

리눅스 시스템의 부팅 과정은 크게

1. PC 부팅(하드웨어 부팅)과
2. 리눅스 부팅(운영체제 부팅)으로 나뉜다.

리눅스는 부팅 과정을 다음과 같은 단계로 나누어 관리한다.

![image-20240302051613658](.\assets\image-20240302051613658.png)

### 1. 바이오스 단계

PC 전원 스위치를 켜면 제일 먼저 바이오스(BIOS, Basic Input Output System)가 동작한다.

바이오스는 보통 ROM에 저장되어 있어 ROM-BIOS라고 부른다.

바이오스는 PC에 장착된 기본적인 하드웨어(키보드, 디스크 등)의 상태를 확인한 후 부팅 장치를 선택하여 부팅 디스크의 첫 섹터에 512B를 로딩한다.

이 512B를 마스터 부트 레코드(MBR, Master Boot Record)라 하며 여기에는 디스크의 어느 파티션에 2차 부팅 프로그램(부트 로더)이 있는지에 대한 정보가 저장되어 있다.

메모리에 로딩된 MBR은 부트 로더를 찾아 메모리에 로딩하는 작업까지 수행한다.

이를 정리하면 아래와 같다.

![image-20240302052336045](.\assets\image-20240302052336045.png)

### 2. 부트 로더 단계

바이오스 단계에서 MBR은 부트 로더를 찾아 메모리에 로딩한다.

부팅할 때 GRUB 메뉴를 출력하려면 /etc/default/grub 파일을 수정해야 한다.

### 3. 커널 초기화 단계

1. 부트 로더에 의해 메모리에 로딩된 커널은 가장 먼저 시스템에 연결된 메모리, 디스크, 키보드, 마우스 등의 장치를 검사한다.

리눅스를 처음 시스템에 설치할 때 사용 가능한 하드웨어의 정보를 미리 확인했다가, 부팅할 때 이러한 장치들이 사용 가능한 상태로 유지되고 있는지 확인하는 것이다.

2. 장치 검사 등 기본적인 초기화 과정이 끝나면 커널은 일반적으로 프로세스를 만드는 방식인 fork를 사용하지 않고 프로세스와 스레드를 생성한다.

   이 프로세스들은 메모리 관리 같은 커널의 여러 가지 동작을 수행한다.

   이 프로세스들은 일반적인 프로세드와 구분되도록 대괄호([ ])로 표시되며, 주로 PID 번호가 낮게 배정되어 있다.

   ![image-20240302185906985](.\assets\image-20240302185906985.png)

3. 커널 프로세스가 생성되면 커널이 수행할 작업이 끝난다.

   이제 systemd 서비스를 동작시킨다.

### 4. systemd 서비스 단계

systemd 서비스 단계에 이르면 리눅스가 본격적으로 동작하기 시작한 것이다.

우분투에서 systemd 서비스는 기존의 init 스크립트를 대체한 것으로 다양한 서비스를 동작시킨다.

부팅할 때 메시지가 출력되게 하려면 /etc/default/grub 파일의 GRUB_CMDLINE_LINUX_DEFAULT="quiet splash" 에서 quiet를 삭제하고 sudo update-grup를 실행하여 변경된 내용을 적용하면 된다.

이 메시지는 부팅 후 demesg 명령이나 more /var/log/boot.log 명령으로 확인할 수 있다.

cf) : dmesg - print or control the kernel ring buffer

전통적으로 유닉스에서는 init 프로세스가 서비스를 실행했다. 따라서 init 프로세스는 처음 생성된 프로세스로서 PID가 1번이다. 우분투에서는 init 대신 시스템과 서비스 관리자로 systemd를 사용하고 있다.

![image-20240304005147128](.\assets\image-20240304005147128.png)

1번 프로세스가 여전히 init인 것처럼 보이지만 사실은 systemd 파일의 심볼릭 링크다.

![image-20240304005228498](.\assets\image-20240304005228498.png)

## systemd 서비스

systemd는 리눅스의 시스템과 서버의 관리자로서 유닉스의 init 프로세스가 하던 작업을 대신 수행한다.

즉 systemd는

* 다양한 서비스 데몬을 시작하고,
* 프로세스들의 상태를 유지하며,
* 시스템의 상태를 관리한다.

우선 init 프로세스의 동작을 살펴본다.

### init 프로세스와 런레벨

기존에는 init 프로세스가 스크립트를 순차적으로 실행하여 다른 프로세스를 동작시켰다. 

현재 init 서비스는 systemd 서비스로 대체되었다. 

![image-20240304005535610](.\assets\image-20240304005535610.png)

전통적으로 init와 관련된 스크립트 파일은 /etc/init.d 디렉터리에 있으며 아직 일부 서비스의 스크립트 파일이 남아 있다.

init 프로세스는 없어졌지만, 전통적으로 사용해온 init 프로세스의 런레벨 개념은 이해할 필요가 있다.

init은 시스템 상태를 7개로 정의하여 구분하고 각 상태에 따라 셸 스크립트를 실행하는데, 이러한 상태를 런레벨이라 한다.

![image-20240304005940330](.\assets\image-20240304005940330.png)

각 런레벨의 기능은 다음과 같다.

* 0
  * Power Off
  * 시스템 종료를 의미한다.
  * 기본값으로 설정 불가
* 1
  * Rescue
  * 시스템 복구 모드이며 Windows의 안전모드를 생각할 수 있다.
  * 기본적으로 관리자 권한을 얻어 수행된다.
  * 로그인 과정 없이 root 계정으로 로그온
  * 네트워크, 서버, 파일 공유 등과 같은 서비스 사용X
  * 시스템 점검/복구, root 계정 패스워드 초기화 등에 사용
    (즉, 시스템 관리 목적으로 사용)
* 2
  * Multi-User
  * 네트워크를 사용하지 않는 다중 사용자 모드
  * 여러 계정으로 로그온할 수 있다.
  * 네트워크를 사용하지 않는 런레벨 3과 동일하다
* 3
  * Multi-User
  * 네트워크를 지원하는 CLI(텍스트 기반) 다중 사용자 모드이다.
  * 여러 계정으로 로그온할 수 있다.
* 4
  * Multi-User
  * 사용하지 않음(사용자가 정의해서 사용은 가능)
* 5
  * Graphical
  * X Window를 사용하는 GUI(그래픽 모드) 다중 사용자 모드이다.
* 6
  * Reboot
  * 시스템 재시작을 의미한다.
  * 기본값으로 설정 불가

### systemd 기본 개념

systemd는 init 방식에 비해 다음과 같은 장점이 있다.

* 소켓 기반으로 동작하여 inetd와 호환성을 유지한다.
* 셸과 독립적으로 부팅이 가능하다.
* 마운트 제어가 가능하다
* fsck 제어가 가능하다.
* 시스템 상태에 대한 스냅숏을 유지한다.
* 서비스에 시그널을 전달할 수 있다.
* 셧다운 전에 사용자 세션의 안전한 종료가 가능하다.

**systemd 유닛**

systemd는 전체 시스템을 시작하고 관리하는 데 유닛이라 부르는 구성 요소를 사용한다.

systemd는 아래의 표와 같은 유닛들을 구분하여 관리한다.

systemd는 관리 대상의 이름을 '서비스명.유닛 종류'의 형태로 관리한다.

각 유닛은 같은 이름과 종류로 구성된 설정 파일과 동일한 이름을 사용한다. 
예를 들어 atd.service 유닛의 경우 같은 이름의 설정 파일을 가지며, atd 데몬을 관리한다.

| 유닛      | 기능                                                         | 예                                |
| --------- | ------------------------------------------------------------ | --------------------------------- |
| service   | 시스템 서비스 유닛으로 데몬을 시작, 종료, 재시작, 로드한다.  | atd.service                       |
| target    | 유닛을 그루핑한다( ex) multi-user.target → 런레벨 5에 해당하는 유닛 ) | basic.target                      |
| automount | 디렉터리 계층 구조에서 자동 마운트 포인트를 관리한다.        | proc-sys-fs-binfmt_misc.automount |
| device    | 리눅스 장치 트리에 있는 장치를 관리한다.                     | sys-module-fuse.device            |
| mount     | 디렉터리 계층 구조의 마운트 포인트를 관리한다.               | boot.mount                        |
| path      | 파일 시스템의 파일이나 디렉터리 등 경로를 관리한다.          | cups.path                         |
| scope     | 외부에서 생성된 프로세스를 관리한다.                         | init.scope                        |
| slice     | 시스템의 프로세스를 계층적으로 관리한다                      | system-getty.slice                |
| socket    | 소켓을 관리하는 유닛으로 AF_INET, AF_INET6, AF_UNIX 소켓 스트림과 데이터그램, FIFO를 지원한다. | dbus.socket                       |
| swap      | 스왑 장치를 관리한다.                                        | dev-mapper-fedora\x2dswap.swap    |
| timer     | 타이머와 관련된 기능을 관리한다.                             | dnf-makecache.timer               |

### systemd 관련 명령

systemd 기반으로 서비스를 시작하거나 종료할 때 사용하는 명령은 systemctl이다.

systemctl 명령에서 유닛을 지정할 때 유닛의 종류는 제외해도 된다.

예를 들면 sshd.service를 지정할 때 sshd만 지정해도 된다.

systemctl : systemd 서비스를 제어한다.

**동작 중인 유닛 출력하기**

옵션이나 명령 없이 systemctl 명령만 사용하면 현재 동작 중인 유닛이 출력된다.

**전체 유닛 출력하기 -a**

![image-20240304011911825](.\assets\image-20240304011911825.png)

**특정 유닛 출력하기 -t**

![image-20240304011924571](.\assets\image-20240304011924571.png)

**유닛 서비스 시작하기 : start**

![image-20240304012122913](.\assets\image-20240304012122913.png)

**유닛의 상태 확인하기 : status**

![image-20240304012054224](.\assets\image-20240304012054224.png)

**유닛 서비스 정지하기 : stop**

![image-20240304012204528](.\assets\image-20240304012204528.png)

### systemd와 런레벨

앞서 본 런레벨은 현재 시스템의 상태를 나타내는 한 자리 숫자(문자 S, s 포함)다.

이에 대응하는 systemd의 target 유닛은 아래의 표와 같이 제공된다.

이 파일들은 /usr/lib/systemd/system 디렉터리에 있다.

아래 표를 보면 각 런레벨에 해당하는 runlevelX.target이 제공되는데, 이는 런레벨에 익숙한 사용자의 편의를 위한 심볼릭 링크다.

![image-20240304012742621](.\assets\image-20240304012742621.png)

**현재 target과 런레벨 확인하기**

![image-20240304012823264](.\assets\image-20240304012823264.png)

런레벨을 확인하려면 runlevel 명령을 사용한다. 출력된 'N 5'는 런레벨 5로 부팅했다는 의미다.

![image-20240304012900226](.\assets\image-20240304012900226.png)

**기본 target 지정하기**

부팅할 때 동작하는 기본 런레벨은 예전에는 /etc/inittab 파일에 지정했으나 지금은 default.target이 가리키는 target 유닛으로 바뀌었다.

default.target이 가리키는 기본 target은 다음과 같은 형식으로 지정한다.

```
systemctl set-default <name of target>.target
```

이 명령은 /etc/systemd/system 디렉터리 아래의 심볼릭 링크인 default.target이 가리키는 target 파일을 변경한다.

예를 들어 현재 target인 graphical.target에서 multi-user.target으로 바꾸려면 다음과 같이 한다.

![image-20240304013344952](.\assets\image-20240304013344952.png)

당연한 말이지만 런레벨 0이나, 런레벨 6에 해당하는 target을 기본으로 지정하면 안 된다(시스템에 치명적일 수도 있다).

다시 기본 target을 graphical.target으로 변경한다.

![image-20240304013535901](.\assets\image-20240304013535901.png)

**target 변경하기**

systemd에서 런레벨을 변경하는 것도 isolate 명령으로 간단히 해결할 수 있다.

예를 들어 multi-user.target(런레벨 3)으로 변경하려면 다음 명령 중 하나를 입력한다.

```
systemctl isolate multi-user
```

```
systemctl isolate runlevel3
```

graphical.target(런레벨 5)으로 변경하려면 다음 명령 중 하나를 사용한다.

```
systemctl isolate graphical
```

```
systemctl isolate runlevel5
```

**런레벨 변경하기 : telinit, init**

init은 1번 프로세스의 이름이기도 하지만 init 프로세스의 런레벨을 바꿀 때 사용하기도 한다.

![image-20240304013923769](.\assets\image-20240304013923769.png)

이는 기존의 init 프로세스에 익숙한 사용자들을 위해 명령을 유지하고 있는 것으로 예를 들어 init 3을 입력하면 런레벨 3으로 변경된다.

런레벨을 바꾸는 명령으로 telinit도 있다. telinit은 systemctl에 대한 심볼릭 링크다.

![image-20240304014100840](.\assets\image-20240304014100840.png)

telinit 명령을 실행하면 init 명령과 같은 결과가 출력된다.

![image-20240304014133448](.\assets\image-20240304014133448.png)

**단일 사용자 모드로 전환하기 : rescue.target(런레벨 1)**

시스템에 문제가 있을 경우 시스템을 rescue.target 유닛(런레벨 1, 런레벨 S)으로 변경하여 점검해야 한다.

이는 윈도의 안전모드와 같은 것으로, 다중 사용자 모드에서 시스템 관리자만 사용할 수 있는 단일 사용자 모드로 전환하는 것이다.

따라서 이 모드로 변환하기 전에 다른 사용자들은 로그아웃을 해야 한다.

다음 명령 중 하나를 사용하면 단일 사용자 모드로 전환할 수 있다.

```
systemctl isolate rescue
```

```
systemctl isolate runlevel1
```

```
init
```

```
telinit S
```

단일 사용자 모드로 전환하면 그래픽 환경이었던 리눅스가 텍스트 모드로 바뀐다.

단일 사용자 모드에서는 바로 root 암호를 입력하여 시스템과 관련된 점검 작업을 하고 다시 다중 사용자 모드로 전환한다.

단일 사용자 모드에서 다중 사용자 모드로 전환하려면 reboot 명령이나 systemctl default 명령을 사용한다.

## 리눅스 시스템의 종료

### shutdown 명령

shutdown : 리눅스를 종료한다.

**시스템 즉시 종료**

-h 옵션을 주면 halt 상태로 이동한다.

cf) : halt 상태 :  모든 프로세스는 꺼지지만 시스템 전원은 차단되지 않음

```
sudo shutdown -h now
```

**셧다운 알림 메시지 보내고 종료**

현재 시스템을 사용 중인 사용자들이 있다면 시스템이 종료된다는 메시지를 보내어 작업을 저장하고 정리할 시간을 주어야 한다.

시스템을 종료할 때 shutdown 명령으로 메시지를 보낼 수 있다.

```
sudo shutdown -h +2 "System is going down in 2 min"
```

**시스템 재시작하기**

```
sudo shutdown -r +3
```

**명령 취소하기**

```
sudo shutdown -c
```

**메시지만 보내기**

실제로 shutdown 명령을 실행하지는 않고 사용자들에게 메시지만 보내려면 -k 옵션을 사용한다.

```
sudo shutdown -k 2
```

### 런레벨 변경

**런레벨 변경하기**

시스템 종료하기

```
sudo init 0
```

시스템 재시작하기

```
sudo init 6
```

**systemd로 종료하기**

```
sudo systemctl isolate poweroff.target
```

```
sudo systemctl isolate runlevel0.target
```

**systemd로 재시작하기**

```
sudo systemctl isolate reboot.target
```

```
sudo systemctl isolate runlevel6.target
```

## 데몬 프로세스

데몬은 리눅스의 백그라운드에서 동작하며 특정한 서비스를 제공하는 프로세스를 의미한다.

리눅스 시스템에서 동작하는 웹 서버나 데이터베이스 서버, 원격 접속 서버 등 각종 서비스를 제공하는 프로세스가 데몬이다.

### 데몬의 동작 방식

데몬은 두 가지 동작 방식,

* 데몬 혼자서 스스로 동작하는 독자형과
* 데몬을 관리하는 슈퍼데몬에 의해 동작하는 방식이 있다.

독자형의 경우 시스템의 백그라운드에서 항상 동작하고 있는데, 자주 호출되는 데몬이 아니라면 시스템의 자원을 낭비할 우려가 있다.

슈퍼데몬에 의한 동작 방식은, 평소에는 슈퍼데몬만 동작하다가 서비스 요청이 오면 슈퍼데몬이 해당 데몬을 동작시키는 것이다.

독자형보다는 서비스 응답 시간이 길지만 자원을 효율적으로 사용한다는 장점이 있다(trade off).

### 슈퍼데몬

네트워크 서비스를 제공하는 데몬을 관리하는 데몬

사용자가 네트워크 서비스를 요청하면 슈퍼데몬이 이를 받아서 해당하는 서비스 데몬을 동작시킨다.

### 데몬의 조상

대부분의 데몬을 동작시키는 조상 데몬이 있다.

systemd와 kthreadd(커널 스레드 데몬)이다.

**systemd 데몬**

systemd는 1번 프로세스로서 프로세스 대부분의 조상 프로세스이며, 시스템의 상태를 종합적으로 관리하는 역할을 수행한다.

pstree 명령으로 프로세스의 실행 구조를 확인해보면 systemd가 다른 데몬들의 조상임을 알 수 있다.

![image-20240305200020969](.\assets\image-20240305200020969.png)

**kthreadd(커널 스레드 데몬)**

커널 일부분을 프로세스처럼 관리하는 데몬이다.

이는 ps 명령으로 확인했을 때 대괄호([ ])에 들어 있는 프로세스들이다.

커널 데몬은 대부분 입출력이나 메모리 관리, 디스크 동기화 등을 수행하며 대체로 낮은 PID가 할당되어 있다.

일반 프로세스의 조상 데몬이 sytstemd라면 커널 데몬을 동작시키는 조상 데몬은 커널 스레드 데몬이다.

ps 명령으로 확인해보면 모든 커널 데몬의 PPID가 2번임을 알 수 있다(PID 2번은 kthreadd 데몬이다).

![image-20240305200433021](.\assets\image-20240305200433021.png)

## 부트 로더

부트 로더는 커널을 메모리에 로딩하는 역할을 수행한다.

### GRUB의 개요

### GRUB2 관련 디렉터리 파일

**/boot/grub/grub.cfg 파일**

**/etc/grub.d 디렉터리**

**/etc/default/grub 파일**

### 암호 복구하기

root 계정의 암호 복구를 위해 단일 사용자 모드로 부팅한다.

1. 시스템 재시작하기

2. GRUB 편집 모드로 전환하기

   GRUB Boot Menu가 출력될 때 E 키를 눌러 편집 모드로 전환한다.

3. 단일 사용자 모드로 수정하기

   리눅스 커널 정보가 있는 행에서 'ro splash $vt_handoff'를 'rw init=/bin/bash'로 수정한다.

4. 재시작하기

   F10 키를 눌러 재시작한다.

   그러면 root 계정으로 동작한다.

   이 상태에서 원하는 작업을 수행한다.

5. 재부팅하기

   작업이 끝나면 reboot -f 명령으로 시스템을 재시작한다.

### 복구 모드로 부팅하기

우분투가 부팅되지 않는다면 복구 모드로 부팅하는 것이 유용할 수 있다.

복구 모드는 가장 기본적인 서비스만 제공하며 명령 모드로 작업할 수 있다.

복구 모드에서는 root 계정으로 로그인하여 시스템의 복구에 필요한 작업을 수행한다.

1. 복구 모드 선택하기

   시스템을 재시작하면 GRUB 메뉴 초기 화면이 나타난다.

   'Ubuntu용 고급 설정'을 선택한다.

   이후 recovery mode를 선택한다.

2. root 항목 선택하기

3. root로 로그인하기

4. 다시 마운트하기

   root 프롬프트가 출력되면 복구 작업을 할 수 있다.

   이때 root 파일 시스템이 읽기 전용으로 마운트되었으므로 읽기 및 쓰기가 가능하도록 다시 마운트하고 작업해야 한다.

   ```
   mount -o remount,rw /
   ```

5. 재시작하기

   reboot -f 명령으로 재시작한다.

# 소프트웨어 관리

## 우분투 패키지의 개요

## 우분투 패키지 설치

### APT 명령으로 패키지 관리하기

### dpkg 명령으로 패키지 관리하기

### aptitude 명령으로 패키지 관리하기

## 스냅 피키지 설치

### 스냅의 개념

### 스냅 사용하기

## 파일 아카이브와 압축

### 파일 아카이브

### 파일 압축

## 소프트웨어 컴파일

### 컴파일 설치

### 간단한 C 프로그램 컴파일 및 실행

### make 명령 사용하기

실제 패키지는 많은 파일로 복잡하게 구성되어 있다.

따라서 이를 gcc로 일일이 컴파일하여 하나의 실행 파일로 만드는 것은 번거로운 작업인데,

이를 간단하게 해결할 수 있도록 해주는 것이 make 명령이다.

make 명령은 makefile(또는 Makefile)에 설정된 정보를 읽어서 여러 소스 파일을 컴파일하고 링크하여 최종 실행 파일을 만들어준다.

# 사용자 관리

## 사용자 계정 관련 파일

### /etc/passwd 파일

사용자 계정 정보가 저장된 기본 파일이다.

**/etc/passwd 파일 구조**

로그인ID : x : UID : GID : 설명 : 홈 디렉터리 : 로그인 셸

* 로그인 ID : 사용자 계정 이름
* x : 초기 유닉스 시스템에서 사용자 암호를 저장하던 항목. 현재는 보안상 이유로 사용자 암호를 /ect/shadow 파일에 별도로 저장
* UID : 사용자 ID 번호로 시스템이 사용자를 구별하기 위해 사용하는 번호
  * 0(root) : root 사용자 계정
  * 1(daemon) : 시스템 데몬 계정
  * 2(bin) : 명령어 관리를 위한 계정
  * 7(lp) : 프린트 서비스와 관련된 계정
  * 65534(nobody) : 사용자의 UID로 NFS와 관련된 계정
* GID : 그룹 ID
* 설명 : 사용자의 일반적인 정보가 기록되는 항목
* 홈 디렉터리 : 사용자 계정에 할당된 홈 디렉터리의 절대 경로
* 로그인 셸 : 사용자의 로그인 셸

### /etc/shadow 파일

사용자 암호에 관한 정보를 별도로 관리한다.

**/etc/shadow 파일의 구조**

로그인ID : 암호(패스워드) : 최종 변경일 : MIN : MAX : WARNING : INACTIVE : EXPIRE : Flag

### /etc/login.defs 파일

사용자 계정의 설정과 관련된 기본값을 정의한 파일이다.

### /etc/group 파일

그룹의 정보가 저장된 파일이다.

**/etc/group 파일의 구조**

그룹 이름 : x : GID : 그룹 멤버

### /etc/gshadow 파일

그룹 암호가 저장된 파일이다.

**/etc/gshadow 파일의 구조**

그룹 이름 : 그룹 암호 : 관리자 : 그룹 멤버

## 사용자 계정 관리 명령

### 사용자 계정 생성

**useradd 명령으로 사용자 계정 생성하기**

useradd : 사용자 계정 생성

**옵션 없이 계정 생성하기**

![image-20240306034146712](.\assets\image-20240306034146712.png)

**기본 설정 값 확인하기 : -D 옵션**

![image-20240306034223057](.\assets\image-20240306034223057.png)

* GROUP : 기본 등록 그룹의 GID로 100은 users 그룹이다.
* HOME : 홈 디렉터리의 생성 위치다.
* INACTIVE : -1이면 INACTIVE 기능이 비활성화된다. 0이면 암호가 만료되자마자 바로 계정이 잠긴다.
* EXPIRE : 계정 종료일을 지정한다.
* SHELL : 기본 로그인 셸을 지정한다.
* SKEL : 홈 디렉터리에 복사할 기본 환경 파일의 위치다.
* CREATE_MAIL_SPOOL : 메일 디렉터리 생성 여부를 지정한다.

**/etc/skel 디렉터리의 역할**

사용자 계정을 생성할 때 사용자 계정의 홈 디렉터리에 공통으로 배포할 파일을 설정한다.

예를 들어 .bash_profile 같은 초기화 파일을 공통으로 작성해놓고 사용자 계정에 복사하는 것이다.

이런 경우 /etc/skel 디렉터리에 파일을 만들어놓으면 사용자 계정 생성 시 자동으로 복사된다.

**옵션을 지정하여 사용자 계정 생성하기**

```
sudo useradd -s /bin/bash -m -d /home/user3 -u 2000 -g 1000 -G 3 user3
```

```
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ grep user3 /etc/passwd
user3:x:2000:1000::/home/user3:/bin/bash
```

![image-20240307231126738](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307231126738.png)

**adduser 명령으로 사용자 계정 생성하기**

adduser : 사용자 계정을 생성한다.

1. 옵션 없이 사용자 계정 생성하기

   ```
   ojs@ojs-950XBE:~/Desktop/ubuntulinux$ sudo adduser user5
   'user5' 사용자를 추가 중...
   새 그룹 'user5' (1001) 추가 ...
   새 사용자 'user5' (1001) 을(를) 그룹 'user5' (으)로 추가 ...
   '/home/user5' 홈 디렉터리를 생성하는 중...
   '/etc/skel'에서 파일들을 복사하는 중...
   새 UNIX 암호 입력: 
   새 UNIX 암호 재입력: 
   passwd: 암호를 성공적으로 업데이트했습니다
   user5의 사용자의 정보를 바꿉니다
   새로운 값을 넣거나, 기본값을 원하시면 엔터를 치세요
   	이름 []: user5
   	방 번호 []: 
   	직장 전화번호 []: 
   	집 전화번호 []: 
   	기타 []: 
   정보가 올바릅니까? [Y/n] y
   ```

   ```
   ojs@ojs-950XBE:~/Desktop/ubuntulinux$ tail -1 /etc/passwd
   user5:x:1001:1001:user5,,,:/home/user5:/bin/bash
   ```

   ![image-20240307231501699](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307231501699.png)

2. 옵션을 지정하여 사용자 계정 생성하기

   ```
   ojs@ojs-950XBE:~/Desktop/ubuntulinux$ sudo adduser --uid 2002 user6
   'user6' 사용자를 추가 중...
   새 그룹 'user6' (2002) 추가 ...
   새 사용자 'user6' (2002) 을(를) 그룹 'user6' (으)로 추가 ...
   '/home/user6' 홈 디렉터리를 생성하는 중...
   '/etc/skel'에서 파일들을 복사하는 중...
   새 UNIX 암호 입력: 
   새 UNIX 암호 재입력: 
   암호가 없음
   새 UNIX 암호 입력: 
   새 UNIX 암호 재입력: 
   passwd: 암호를 성공적으로 업데이트했습니다
   user6의 사용자의 정보를 바꿉니다
   새로운 값을 넣거나, 기본값을 원하시면 엔터를 치세요
   	이름 []: 
   	방 번호 []: 
   	직장 전화번호 []: 
   	집 전화번호 []: 
   	기타 []: 
   정보가 올바릅니까? [Y/n] y
   ```

   ![image-20240307231633928](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307231633928.png)

```
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ tail -1 /etc/passwd
user6:x:2002:2002:,,,:/home/user6:/bin/bash
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ tail -1 /etc/group
user6:x:2002:
```

![image-20240307231726484](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307231726484.png)

3. 기본 설정 값 확인하기

   adduser 명령의 기본 설정은 /etc/adduser.conf에 저장되어 있다.

   ```
   ojs@ojs-950XBE:~/Desktop/ubuntulinux$ more /etc/adduser.conf
   # /etc/adduser.conf: `adduser' configuration.
   # See adduser(8) and adduser.conf(5) for full documentation.
   
   # The DSHELL variable specifies the default login shell on your
   # system.
   DSHELL=/bin/bash
   
   # The DHOME variable specifies the directory containing users' home
   # directories.
   DHOME=/home
   
   # If GROUPHOMES is "yes", then the home directories will be created as
   # /home/groupname/user.
   GROUPHOMES=no
   
   # If LETTERHOMES is "yes", then the created home directories will have
   # an extra directory - the first letter of the user name. For example:
   # /home/u/user.
   LETTERHOMES=no
   
   ...
   ```

### 사용자 계정 정보 수정

usermod : 사용자 계정 정보를 수정한다.

**UID 변경하기 : -u 옵션**

```
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ sudo usermod -u 1003 user3
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ grep user3 /etc/passwd
user3:x:1003:1000::/home/user3:/bin/bash
```

![image-20240307232156680](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307232156680.png)

**홈 디렉터리 변경하기 : -d 옵션**

```
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ sudo usermod -d /home/user31 user3
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ grep user3 /etc/passwd
user3:x:1001:1000::/home/user31:/bin/bash
```

![image-20240307232350092](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307232350092.png)

**로그인 ID 변경하기 : -l 옵션**

```
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ sudo usermod -d /home/user55 -l user55 user5
ojs@ojs-950XBE:~/Desktop/ubuntulinux$ grep user55 /etc/passwd
user55:x:1001:1001:user5,,,:/home/user55:/bin/bash
```

![image-20240307232543080](/home/ojs/Desktop/ubuntulinux/ubuntulinux/assets/image-20240307232543080.png)

### 패스워드 에이징 관련 명령

| 항목     | useradd, usermod, passwd 명령                               | chage 명령         |
| -------- | ----------------------------------------------------------- | ------------------ |
| MIN      | passwd -n 날수                                              | chage -m           |
| MAX      | passwd -x 날수                                              | chage -M           |
| WARNING  | passwd -w 날수                                              | chage -W           |
| INACTIVE | useradd -f 날수<br />usermod -f 날수                        | chage -I(대문자 i) |
| EXPIRE   | useradd -e 날짜(YYYY-MM-DD)<br />usermod -e 날짜(YYYY-MM-DD | chage -E           |

**기존 명령으로 패스워드 에이징 변경하기**

```
ojs@ojs-950XBE:~$ sudo grep user3 /etc/shadow
[sudo] ojs의 암호: 
user3:!:19789:0:99999:7:::
ojs@ojs-950XBE:~$ sudo usermod -f 10 -e 2024-03-08 user3
ojs@ojs-950XBE:~$ sudo passwd -n 2 -x 100 -w 5 user3
passwd: password expiry information changed.
ojs@ojs-950XBE:~$ sudo grep user3 /etc/shadow
user3:!:19789:2:100:5:10:19790:
```

**패스워드 에이징 변경 및 설정 내용 확인하기 : change**

```
ojs@ojs-950XBE:~$ sudo chage -m 2 -M 100 -W 5 -I 10 -E 2024-03-08 user55
ojs@ojs-950XBE:~$ sudo grep user55 /etc/shadow
user55:$6$saTJTH/d$a5XNW6kcXLGKE6gGBZ/P6xUwUJAe4riaRxrrQ14MV0ixL2U8a89/33OZSyIv5xcEGGRYtAuBUPJvxSV8RbJJy0:19789:2:100:5:10:19790:
```

### 사용자 계정 삭제

userdel : 사용자 계정을 삭제한다.

```
ojs@ojs-950XBE:~$ sudo userdel user3
ojs@ojs-950XBE:~$ ls /home
ojs  user3  user5  user6  workspace
```

user3 사용자 계정은 삭제되었지만 user3 홈 디렉터리는 남아있다.

**사용자 꼐정과 홈 디렉터리 삭제하기**

```
ojs@ojs-950XBE:~$ sudo userdel -r user6
userdel: user6 mail spool (/var/mail/user6) not found
ojs@ojs-950XBE:~$ ls /home
ojs  user3  user5  workspace
```

## 그룹 관리 명령

### 그룹 생성

**groupadd 명령으로 그룹 생성하기**

groupadd : 그룹을 생성한다.

1. 옵션 없이 그룹 생성하기
2. GID를 지정하여 그룹 생성하기
3. GID를 중복하여 지정하기

**addgroup 명령으로 그룹 생성하기**

addgroup : 그룹을 생성한다.

1. 옵션 없이 그룹 생성하기
2. GID를 지정하여 그룹 생성하기

### 그룹 정보 수정

groupmod : 그룹 정보를 수정한다.

**GID 바꾸기**

**그룹명 바꾸기**

### 그룹 삭제

groupdel : 그룹을 삭제한다.

### 그룹 암호 설정하고 사용하기

gpasswd : /etc/group와 /etc/gshadow 파일을 관리한다.

**그룹에 멤버 추가하기**

**그룹에 멤버 삭제하기**

**그룹 암호 설정하고 제거하기**

* 소속 그룹 변경하기 : newgrp

  newgrp : 소속 그룹을 다른 그룹으로 바꾼다.

* 그룹 암호 삭제하기 : -r 옵션

## 사용자 정보 관리 명령

### UID와 EUID

### 사용자 확인 명령

**사용자 로그인 정보 확인하기 : who, w 명령**

* who 명령

  who : 현재 시스템을 사용하는 사용자의 정보를 출력한다.

* w 명령

  w : 현재 시스템을 사용하는 사용자 정보와 작업 정보를 출력한다.

* last 명령

  last : 시스템에 로그인하고 로그아웃한 정보를 출력한다.

**UID와 EUID 확인하기 : whoami, who am i, id 명령**

**소속 그룹 확인하기 : groups 명령**

groups : 사용자 계정이 속한 그룹을 출력한다.

### root 권한 사용 방법

**sudo 권한 설정하기**

**sudo 명령 사용하기**

**sudo 명령 사용 시 주의 사항**

### passwd 명령 활용하기

passwd : 사용자 계정의 암호를 수정한다.

**암호 잠그고 해제하기 : -l 옵션과 -u 옵션**

**암호 삭제하기 : -d 옵션**

### 파일 및 디렉터리의 소유자와 소유 그룹 변경하기

**chown 명령**

chown : 파일과 디렉터리의 소유자와 소유 그룹을 변경한다.

## 디스크 사용량(쿼터) 설정

특정 사용자가 과도하게 디스크를 사용하지 않도록 제한

* 하드 리미트

  : 사용자가 절대로 넘을 수 없는 최대치

* 소프트 리미트

  : 일정 시간 내에는 넘을 수 있는 한계치

**quota 패키지 설치**

```
sudo apt install quota
```

### 쿼터 설정을 위한 사전 준비

**쿼터 속성 지정**

* userquota : 개별 사용자의 쿼터를 제한할 수 있는 속성
* grpgquota : 개별 그룹의 쿼터를 제한할 수 있는 속성

```
ojs@ojs-950XBE:~$ sudo rmdir /home2
ojs@ojs-950XBE:~$ sudo mkdir /home2
ojs@ojs-950XBE:~$ sudo mount /dev/sdb1 /home2
ojs@ojs-950XBE:~$ df -h /dev/sdb1
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdb1        29G   28K   27G   1% /home2
ojs@ojs-950XBE:~$ sudo vi /etc/fstab

...

UUID=c2617797-ea7a-4668-a855-3496280b709a /               ext4    errors=remount-ro 0       1
# /boot/efi was on /dev/nvme0n1p1 during installation
UUID=400C-67D8  /boot/efi       vfat    umask=0077      0       1
/swapfile                                 none            swap    sw              0       0
/dev/sdd2       /home2          ext3    defaults                                1       1

...

:wq!

ojs@ojs-950XBE:~$ sudo useradd -m -d /home2/qtest1 qtest1
ojs@ojs-950XBE:~$ sudo useradd -m -d /home2/qtest2 qtest2
ojs@ojs-950XBE:~$ ls /home2
hosts  lost+found  qtest1  qtest2
ojs@ojs-950XBE:~$ tail -2 /etc/passwd
qtest1:x:1001:1002::/home2/qtest1:/bin/sh
qtest2:x:1002:1003::/home2/qtest2:/bin/sh
```

**쿼터 속성 설정하기**

```
ojs@ojs-950XBE:~$ sudo vi /etc/fstab

...

/dev/sdd2       /home2          ext3    defaults,usrquota                               1       1

...

:wq!
```

**쿼터 속성 적용하기**

```
sudo mount -o remount /home2
```

usrquota 옵션이 설정되었는지 mount 명령으로 확인

```
ojs@ojs-950XBE:~$ mount

...

/dev/sdb1 on /home2 type ext4 (rw,relatime,quota,usrquota)
```

**쿼터 데이터베이스 파일 생성하기 : quotacheck**

quotacheck : 쿼터 파일을 생성, 확인, 수정하기 위해 파일 시스템을 스캔한다.

**쿼터 사용 활성화하기 : quotaon 명령**

quotaon : 파일 시스템의 쿼터 기능을 활성화한다.

### 쿼터 설정 및 확인

**쿼터 설정하기 : edquota 명령**

edquota :  쿼터를 설정한다.

**쿼터 정보 확인하기 : quota 명령**

quota : 쿼터 정보를 출력한다.

**쿼터 정보 요약 출력하기 : repquota 명령**

repquota : 쿼터 정보를 요약하여 출력한다.

# 네트워크 설정

## 네트워크 기초

### TCP/IP 프로토콜

프로토콜 : 정의한 통신 규약

인터넷 네트워크는 TCP/IP라는 프로토콜에 따라 데이터를 주고받는다.

**프로토콜의 5계층**

| 계층          | 기능                                                         | 프로토콜                    | 전송 단위 |
| ------------- | ------------------------------------------------------------ | --------------------------- | --------- |
| 응용 계층     | 서비스 제공 응용 프로그램                                    | DNS, FTP, SSH, HTTP, Telnet | 메시지    |
| 전송 계층     | * 응용 프로그램으로 데이터 전달<br />* 데이터 흐름 제어 및 전송 신뢰성 담당 | TCP, UDP                    | 세그먼트  |
| 네트워크 계층 | 주소 관리 및 경로 탐색                                       | IP, ICMP                    | 패킷      |
| 링크 계층     | 네트워크 장치 드라이버                                       | ARP                         | 프레임    |
| 물리 계층     | 케이블 등 전송 매체                                          | 구리선, 광케이블, 무선      | 비트      |

### 주소

**MAC 주소**

media access control

하드웨어 주소, 물리 주소, 이더넷 주소

네트워크 인터페이스 카드(랜 카드)에 저장된 주소

6개의 16진수로 구성되며 총 48bit
ex) 00:50:56:3e:3c:fe

* 앞의 세 자리 : 제조사 번호(IEEE에서 지정한다)
* 뒤의 세 자리 : 일련 번호

**IP 주소**

인터넷 네트워크에서 각 컴퓨터를 구분하기 위해 사용

1바이트 크기의 숫자 네 개로 구성(총 4바이트)

네트워크를 구분하는 네트워크 주소 부분과 해당 네트워크 안에서 특정 컴퓨터를 식별하는 호스트 주소 부분으로 나누어짐

네트워크 주소 부분과 호스트 주소 부분을 나누는 것의 차이에 따라 A, B, C 클래스로 구분된다.

주로 쓰이는 것은 C 클래스이다.

C 클래스
ex) 192.168.100.5

* 앞의 3바이트 : 네트워크 부분

* 뒤의 1바이트 : 호스트 부분

  호스트 부분으로 사용할 수 있는 자리는 0~255

  0 : 네트워크 주소를 나타내는데 사용

  255 : 브로드캐스트 주소로 사용

  1~254 : 호스트 주소로 할당

이와 같은 주소를 IPv4라고 하는데 이미 이 주소는 고갈

해서 개발된 주소가 IPv6로, 16진수로 표기되며 크기는 128bit이다.

**넷마스크와 브로드캐스트 주소**

* 넷마스크

  시스템이 IP의 네트워크 부분과 호스트 부분을 식별하게 해준다.

  네트워크 부분을 알려주는 역할을 하는 것이 넷마스크다.

  넷마스크는 하나의 네트워크를 다시 작은 네트워크(서브넷)로 분리할 때도 사용하므로 서브넷마스크라고도 불린다.

  C 클래스의 경우 기본 넷마스크 : 255.255.255.0

  해당 IP와 C 클래스의 기본 넷마스크를 2진수 AND 연산을 처리하면 네트워크 부분만 남고 호스트 부분은 0이 된다.

* 브로드캐스트 주소

  같은 네트워크에 있는 모든 컴퓨터에 메시지를 보낼 때 사용하는 것

  호스트 부분을 모두 1로 설정

  ex) 192.168.100.0의 브로드캐스트 주소는 192.168.100.255

**호스트 이름**

`https://www.naver.com`

* https:// : 프로토콜
* www : 호스트 이름
* naver : 도메인 이름
* com : 탑레벨 도메인

**포트 번호**

클라이언트가 어떤 서비스를 요청했는지 구분하는 번호

클라이언트가 네트워크 서비스를 이용할 때 사용자의 패킷은 IP 주소를 보고 해당 서버 컴퓨터를 찾아간다.

서버 컴퓨터에 도착한 사용자의 패킷은 어떤 서비스를 요청했는지 확인한 다음 해당 데몬에 패킷을 전달한다.

ex) 웹 서비스를 요청했으면 웹 서버 데몬(httpd)에 전달

/etc/services 파일에 서비스별 포트 번호가 정의되어 있다.

ex) ssh는 22번, Telnet은 23번 포트이다.

/etc/services 파일에 저장된 포트 번호는 국제 표준으로 합의하여 사용하고 있는 것이다.

```
user1@raspberrypi:~ $ more /etc/services

tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
chargen         19/tcp          ttytst source
chargen         19/udp          ttytst source
ftp-data        20/tcp
ftp             21/tcp
fsp             21/udp          fspd
ssh             22/tcp                          # SSH Remote Login Protocol
telnet          23/tcp
smtp            25/tcp          mail
time            37/tcp          timserver
time            37/udp          timserver
whois           43/tcp          nicname
tacacs          49/tcp                          # Login Host Protocol (TACACS)
tacacs          49/udp
domain          53/tcp                          # Domain Name Server
domain          53/udp
bootps          67/udp
bootpc          68/udp
tftp            69/udp
gopher          70/tcp                          # Internet Gopher
finger          79/tcp
http            80/tcp          www             # WorldWideWeb HTTP
kerberos        88/tcp          kerberos5 krb5 kerberos-sec     # Kerberos v5
kerberos        88/udp          kerberos5 krb5 kerberos-sec     # Kerberos v5
iso-tsap        102/tcp         tsap            # part of ISODE

...

```

## 네트워크 설정

### 네트워크 관리자

| 도구                 | 기능                                                         |
| -------------------- | ------------------------------------------------------------ |
| 네트워크 관리자      | 기본 네트워킹 데몬                                           |
| nmcli 명령           | 네트워크 관리자를 사용하는 명령 기반 도구                    |
| [설정] - [네트워크]  | 그놈에서 제공하는 GUI 기반 도구                              |
| nm-connection-editor | 네트워크 관리자를 사용하는 GUI 기반 도구로, [제어판] - [네트워크]에서 설정할 수 없는 부분도 설정할 수 있다. |
| ip 명령              | 네트워크를 설정하는 명령을 제공한다.                         |

**네트워크 관리자 설치하기**

```
sudo apt install network-manager
```

**네트워크 관리자 실행하기**

```
user1@raspberrypi:~ $ systemctl status NetworkManager
● NetworkManager.service - Network Manager
     Loaded: loaded (/lib/systemd/system/NetworkManager.service; enabled; preset: enabled)
     Active: active (running) since Sun 2024-03-10 03:41:14 KST; 23min ago
       Docs: man:NetworkManager(8)
   Main PID: 841 (NetworkManager)
      Tasks: 3 (limit: 4384)
        CPU: 227ms
     CGroup: /system.slice/NetworkManager.service
             └─841 /usr/sbin/NetworkManager --no-daemon

 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.2914] device (wlan0): state change: config -> ip-config (reason 'none', sys-iface-state: 'managed')
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.2927] policy: set 'test-net' (wlan0) as default for IPv4 routing and DNS
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.2959] device (wlan0): state change: ip-config -> ip-check (reason 'none', sys-iface-state: 'managed')
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.2992] device (wlan0): state change: ip-check -> secondaries (reason 'none', sys-iface-state: 'managed')
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.2994] device (wlan0): state change: secondaries -> activated (reason 'none', sys-iface-state: 'managed')
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.2997] manager: NetworkManager state is now CONNECTED_SITE
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.3020] device (wlan0): Activation: successful, device activated.
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.3025] manager: NetworkManager state is now CONNECTED_GLOBAL
 3월 10 03:41:20 raspberrypi NetworkManager[841]: <info>  [1710009680.8653] manager: startup complete
 3월 10 03:41:21 raspberrypi NetworkManager[841]: <info>  [1710009681.1228] agent-manager: agent[ba817ad3fcaa5f35,:1.35/org.freedesktop.nm-applet/1000]: agent registered
```

**네트워크 관리자와 작업하기**

네트워크 관리자는 네트워크 설정 정보를 연결 프로파일에 저장한다.

### GUI로 네트워크 설정

### nmcli 명령으로 네트워크 설정

nmcli : 명령 기반으로 네트워크 관리자를 설정한다.

nmcli  명령으로 유선 네트워크뿐만 아니라 와이파이 등 무선 네트워크, 보안 등 네트워크와 관련된 거의 모든 설정을 관리할 수 있다.

**네트워크 전체 상태 살펴보기 : general(gen) 명령**

```
user1@raspberrypi:~/Desktop $ nmcli general status
STATE   CONNECTIVITY  WIFI-HW  WIFI  WWAN-HW  WWAN 
연결됨  전체          사용     사용  missing  사용
```

**네트워크를 활성화하거나 비활성화하기 : networking(net) 명령**

네트워크를 활성화 하거나 비활성화 한다.

connectivity 서브 명령으로 네트워크의 연결 상태를 알려준다.

connectivity가 출력하는 네트워크 상태는 다음 중 하나다.

* none : 호스트가 아직 네트워크에 연결되어 있지 않다.
* limited : 호스트가 네트워크에 연결되어 있지만 인터넷과 연결되지는 않았다.
* full : 호스트가 네트워크에 연결되어 있고 인터넷도 사용할 수 있다.
* unknown : 네트워크 연결 상태를 알 수 없다.

**네트워크 설정하기 : connection(con) 명령**

connection은 네트워크 설정과 관련된 거의 대부분의 기능을 수행한다.

| 서브 명령 | 기능                                                         |
| --------- | ------------------------------------------------------------ |
| show      | 메모리와 디스크에 저장된 네트워크 연결 프로파일을 출력한다.<br />서브 명령을 지정하지 않을 경우 기본적으로 show를 실행한다. |
| up        | 네트워크 연결을 시작한다.                                    |
| down      | 네트워크 연결을 중지한다.                                    |
| modify    | 연결 프로파일에서 속성을 추가, 수정, 삭제한다.               |
| add       | 새로운 연결을 생성한다.                                      |
| delete    | 연결의 설정을 삭제한다.                                      |
| reload    | 연결과 관련된 파일을 디스크에서 다시 읽어온다.               |
| load      | 디스크에서 하나 이상의 연결 파일을 읽어온다.                 |

* 네트워크 연결 프로파일 출력하기 : show

  cf) : 연결 프로파일(Connection Profile) : 네트워크 설정 및 구성을 저장하고 관리하는 데 사용되는 설정의 집합

  1. **네트워크 유형 및 프로토콜:** 유선 또는 무선 네트워크, IPv4 또는 IPv6 프로토콜 등.
  2. **네트워크 식별 정보:** SSID(무선 네트워크의 경우), 네트워크 이름, 보안 키 등.
  3. **IP 주소 및 게이트웨이 설정:** IPv4 및 IPv6 주소, 서브넷 마스크, 게이트웨이 주소 등.
  4. **DNS 설정:** DNS 서버 주소, 검색 도메인 등.
  5. **보안 및 인증 설정:** WPA, WPA2, WEP와 같은 보안 프로토콜, 인증 방법 등.
  6. **프록시 설정:** 웹 프록시 서버 설정.
  7. **네트워크 관련 옵션:** DHCP 사용 여부, MTU 크기 등.

  ```
  user1@raspberrypi:~ $ nmcli con show
  NAME      UUID                                  TYPE      DEVICE 
  test-net  848b6da0-a754-4607-ad9a-756f5c823c6a  wifi      wlan0  
  lo        21e8fc2c-79fb-4402-80da-ae0a14e0f274  loopback  lo     
  bb        69cc030c-8698-4465-ad0c-b94a0be462ba  wifi      --     
  iptime    0b07a43f-feae-437a-8e0a-a1a682cbff5e  wifi      --     
  test      20cd14ee-f041-445f-82c5-b456ec8c40b4  wifi      --    
  ```

* 네트워크 연결 중지하기 : down

* 네트워크 연결 시작하기 : up

* 네트워크 연결 추가하기 : add

  ```
  user1@raspberrypi:~ $ sudo nmcli connection add type ethernet con-name test-net0 ifname wlan0 ip4 192.168.0.20 gw4 192.168.0.1
  'test-net0' (02405a5b-08e0-4314-8e7b-1c53aa044287) 연결이 성공적으로 추가되었습니다.
  user1@raspberrypi:~ $ nmcli con show
  NAME       UUID                                  TYPE      DEVICE 
  test-net   848b6da0-a754-4607-ad9a-756f5c823c6a  wifi      wlan0  
  lo         21e8fc2c-79fb-4402-80da-ae0a14e0f274  loopback  lo     
  bb         69cc030c-8698-4465-ad0c-b94a0be462ba  wifi      --     
  iptime     0b07a43f-feae-437a-8e0a-a1a682cbff5e  wifi      --     
  test       20cd14ee-f041-445f-82c5-b456ec8c40b4  wifi      --     
  test-net0  02405a5b-08e0-4314-8e7b-1c53aa044287  ethernet  --    
  ```

* 네트워크 연결 수정하기 : modify(mod)

  ```
  user1@raspberrypi:~ $ sudo nmcli con mod test-net0 ifname ens0
  ```

  modify 명령에서 사용 가능한 setting과 property는 네트워크 관리자의 연결 프로파일에서 사용하는 설정과 속성이다.

  man nm-settings에서 확인할 수 있다.

  * IPv4 주소 변경

  ```
  nmcli con mod test-net0 ipv4.addresses 192.168.0.20
  ```

  * 다른 IP 주소 추가 및 제거( + / -)

  ```
  nmcli con mod test-net0 +ipv4.addresses 192.168.0.21
  ```

  * 게이트웨이 수정

  ```
  nmcli con mod test-net0 ipv4.gateway 192.168.0.1
  ```

  * 특정 네트워크로 가는 경로를 지정

  ```
  nmcli con mod test-net0 +ip4.routes "192.168.0.20/24 192.168.0.1"
  ```

  * 연결 프로파일의 내용 수정

  ```
  nmcli con up test-net0 ifname wlan0
  ```

  ![image-20240310051031778](C:\Users\jungs\Desktop\study\ubuntulinux\assets\image-20240310051031778.png)

* 네트워크 연결 삭제하기 : delete(del)

  ```
  nmcli connection delete test-net0
  ```

* 네트워크 연결 프로파일 읽어오기 : reload, load

  네트워크 관리자는 연결 프로파일이 수정되었는지 자동으로 인식하지 않는다.

  reload는 디스크에서 모든 연결 프로파일을 다시 읽어오고, load는 특정 연결 프로파일을 지정하여 읽어온다.

  연결 프로파일이 수작업으로 수정되었을 경우 네트워크 관리자에게 이를 알려주기 위해 reload나 load 명령을 사용한다.

  ```
  nmcli connection reload
  nmcli connection load test-net
  ```

**네트워크 장치의 상태 보기 : device(dev) 명령**

device 명령은 네트워크 장치의 상태를 출력하고 관리한다.

* 네트워크 장치의 상태 보기 : status

  ```
  user1@raspberrypi:~ $ nmcli dev status
  DEVICE         TYPE      STATE           CONNECTION 
  wlan0          wifi      연결됨          test-net   
  lo             loopback  연결됨 (외부)   lo         
  p2p-dev-wlan0  wifi-p2p  연결 끊겼음     --         
  eth0           ethernet  사용할 수 없음  --  
  ```

* 네트워크 장치의 상세한 정보 보기 : show

  ```
  user1@raspberrypi:~ $ nmcli dev show
  GENERAL.DEVICE:                         wlan0
  GENERAL.TYPE:                           wifi
  GENERAL.HWADDR:                         2C:CF:67:03:DF:BA
  GENERAL.MTU:                            1500
  GENERAL.STATE:                          100 (연결됨)
  GENERAL.CONNECTION:                     test-net
  GENERAL.CON-PATH:                       /org/freedesktop/NetworkManager/ActiveConnection/5
  IP4.ADDRESS[1]:                         192.168.0.20/32
  IP4.GATEWAY:                            192.168.0.1
  IP4.ROUTE[1]:                           dst = 192.168.0.1/32, nh = 0.0.0.0, mt = 600
  IP4.ROUTE[2]:                           dst = 0.0.0.0/0, nh = 192.168.0.1, mt = 600
  IP6.ADDRESS[1]:                         fe80::32ef:68b4:d2bf:911c/64
  IP6.GATEWAY:                            --
  IP6.ROUTE[1]:                           dst = fe80::/64, nh = ::, mt = 1024
  ```

  ```
  user1@raspberrypi:~ $ nmcli dev show eth0
  GENERAL.DEVICE:                         eth0
  GENERAL.TYPE:                           ethernet
  GENERAL.HWADDR:                         2C:CF:67:03:DF:B8
  GENERAL.MTU:                            1500
  GENERAL.STATE:                          20 (사용할 수 없음)
  GENERAL.CONNECTION:                     --
  GENERAL.CON-PATH:                       --
  WIRED-PROPERTIES.CARRIER:               꺼짐
  IP4.GATEWAY:                            --
  IP6.GATEWAY:                            --
  ```

### ip 명령으로 네트워크 설정

ip : IP 주소, 게이트웨이, 네트워크 장치의 상태 등을 출력하고 관리한다.

* 네트워크 장치의 정보 보기 : show

  ```
  user1@raspberrypi:~ $ ip addr show
  1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
      link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
      inet 127.0.0.1/8 scope host lo
         valid_lft forever preferred_lft forever
      inet6 ::1/128 scope host 
         valid_lft forever preferred_lft forever
  2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
      link/ether 2c:cf:67:03:df:b8 brd ff:ff:ff:ff:ff:ff
  3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
      link/ether 2c:cf:67:03:df:ba brd ff:ff:ff:ff:ff:ff
      inet 192.168.0.20/32 scope global noprefixroute wlan0
         valid_lft forever preferred_lft forever
      inet6 fe80::32ef:68b4:d2bf:911c/64 scope link noprefixroute 
         valid_lft forever preferred_lft forever
  ```

  ```
  user1@raspberrypi:~ $ ip addr show eth0
  2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
      link/ether 2c:cf:67:03:df:b8 brd ff:ff:ff:ff:ff:ff
  ```

* IP 주소 설정하기 : add

  ```
  user1@raspberrypi:~ $ sudo ip addr add 192.168.0.21/24 dev wlan0
  ```

  ```
  user1@raspberrypi:~ $ ip addr show wlan0
  3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
      link/ether 2c:cf:67:03:df:ba brd ff:ff:ff:ff:ff:ff
      inet 192.168.0.20/32 scope global noprefixroute wlan0
         valid_lft forever preferred_lft forever
      inet 192.168.0.21/24 scope global wlan0
         valid_lft forever preferred_lft forever
      inet6 fe80::32ef:68b4:d2bf:911c/64 scope link noprefixroute 
         valid_lft forever preferred_lft forever
  ```

* IP 주소 삭제하기 : del

  ```
  user1@raspberrypi:~ $ ip addr show wlan0
  ```

  ```
  user1@raspberrypi:~ $ ip addr show wlan0
  3: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
      link/ether 2c:cf:67:03:df:ba brd ff:ff:ff:ff:ff:ff
      inet 192.168.0.20/32 scope global noprefixroute wlan0
         valid_lft forever preferred_lft forever
      inet6 fe80::32ef:68b4:d2bf:911c/64 scope link noprefixroute 
         valid_lft forever preferred_lft forever
  ```

**라우팅 테이블과 게이트웨이 주소 관리하기 : route 명령**

네트워크를 다른 네트워크와 연결할 때 연결점이 되는 장치를 게이트웨이라고 한다.

게이트웨이도 하나의 컴퓨터로 보통 라우터라고 부른다.

게이트웨이는 패킷을 보고 같은 네트워크로 보내는 것이 아니면 외부로 전송한다.

게이트웨이 주소가 설정되어 있지 않으면 같은 네트워크가 아닌 컴퓨터와는 접속할 수 없다.

같은 네트워크와는 통신이 되는데 외부와 연결이 안된다면 게이트웨이 주소를 올바로 설정했는지 확인해야 한다.

* 라우팅 테이블 보기 : show

  ```
  user1@raspberrypi:~ $ ip route show
  default via 192.168.0.1 dev wlan0 proto static metric 600 
  192.168.0.1 dev wlan0 proto static scope link metric 600
  ```

* 기본 게이트웨이 주소 설정하기 : add

  ```
  sudo ip route add default via 192.168.0.1 dev eth0
  ```

* 라우팅 경로 설정하기 : add

  ```
  sudo ip route add 192.168.0.1/24 via 192.168.1.1 dev eth0
  ```

* 네트워크 인터페이스 비활성화 : down

  ```
  sudo ip link set eth0 down
  ```

* 네트워크 인터페이스 활성화 : up

  ```
  sudo ip link set eth0 up
  ```

### ifconfig 명령으로 네트워크 설정

ifconfig : 네트워크 인터페이스의 IP 주소를 설정한다.

```
sudo apt install net-tools
```

**현재 설치된 네트워크 인터페이스 설정 보기**

```
user1@raspberrypi:~ $ ifconfig
eth0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        ether 2c:cf:67:03:df:b8  txqueuelen 1000  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
        device interrupt 106  

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 101365  bytes 9715136 (9.2 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 101365  bytes 9715136 (9.2 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

wlan0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.20  netmask 255.255.255.255  broadcast 0.0.0.0
        inet6 fe80::32ef:68b4:d2bf:911c  prefixlen 64  scopeid 0x20<link>
        ether 2c:cf:67:03:df:ba  txqueuelen 1000  (Ethernet)
        RX packets 38503  bytes 3500986 (3.3 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 40441  bytes 5939913 (5.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

장착된 네트워크 인터페이스가 다수일 수 있다.

lo의 경우 로컬 루프백으로서 시스템 내부 통신용으로 사용된다.

RX는 부팅 후 현재까지 받은 패킷 수와 바이트 수를 알려주며,

TX는 부팅 후 현재까지 보낸 패킷 수와 바이트 수를 알려준다.

**특정 네트워크 인터페이스 설정보기**

```
user1@raspberrypi:~ $ ifconfig wlan0
wlan0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.0.20  netmask 255.255.255.255  broadcast 0.0.0.0
        inet6 fe80::32ef:68b4:d2bf:911c  prefixlen 64  scopeid 0x20<link>
        ether 2c:cf:67:03:df:ba  txqueuelen 1000  (Ethernet)
        RX packets 38918  bytes 3533546 (3.3 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 40855  bytes 5976477 (5.6 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
```

**네트워크 인터페이스 사용 해제하기 : down 옵션**

```
sudo ifconfig eth0 down
```

**네트워크 인터페이스 활성화하기 : up 옵션**

```
sudo ifconfig ens0 up
```

**네트워크 인터페이스 설정하기**

```
ifconfig 인터페이스명 IP주소 netmask 넷마스크주소 broadcast 브로드캐스트주소
```

```
sudo ifconfig eth0 192.168.0.254 netmask 255.255.255.0 broadcast 192.168.0.255
```

**게이트웨이 설정하기**

route : 라우팅 테이블을 편집하고 출력한다.

| 기능                       | 명령 형식과 사용 예                                          |
| -------------------------- | ------------------------------------------------------------ |
| 라우팅 경로 추가(네트워크) | route add-net 네트워크 주소 netmask 넷마스크 dev 인터페이스명<br />route add-net 192.168.1.0 netmask 255.255.255.0 dev ens33 |
| 라우팅 경로 추가(호스트)   | route add-host 호스트 주소 dev 인터페이스명<br />route add-host 192.168.1.5 dev ens33 |
| 라우팅 경로 제거(네트워크) | route del -net 네트워크 주소 netmask 넷마스크 [dev 인터페이스명]<br />route del -net 192.168.0.1 netmask 255.255.255.0 |
| 라우팅 경로 제거(호스트)   | route del -host 호스트 주소<br />route del -host 192.168.1.5 |
| 기본 게이트웨이 추가       | route add default gw 게이트웨이 주소 dev 인터페이스명<br />route add default gw 192.168.1.1 dev ens33 |
| 기본 게이트웨이 제거       | route del default gw 게이트웨이 주소<br />route del default gw 192.168.1.1 |
| 루프백(lo) 추가            | route add -net 127.0.0.0 netmask 255.0.0.0 dev lo            |

* 라우팅 테이블 보기 : route

  ```
  user1@raspberrypi:~ $ route
  Kernel IP routing table
  Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
  default         192.168.0.1     0.0.0.0         UG    600    0        0 wlan0
  192.168.0.1     0.0.0.0         255.255.255.255 UH    600    0        0 wlan0
  ```

  | 항목        | 기능                                                         |
  | ----------- | ------------------------------------------------------------ |
  | Destination | 라우팅 대상 네트워크나 호스트의 주소                         |
  | Gateway     | 게이트웨이 주소 또는 설정되어 있지 않으면 * 출력             |
  | Genmask     | * 대상 네트워크의 넷마스크<br />* 255.255.255.255 : 대상이 호스트인 경우<br />* 0.0.0.0 : 기본(default) 경로 |
  | Flags       | * U : 경로 활성화(UP)<br />* H : 대상이 호스트<br />* G : 동적 라우팅을 위한 경로 재생성<br />* D : 데몬 또는 리다이렉트에 의해 동적으로 재설치<br />* M : 라우팅 데몬 또는 리다이렉트에 의해 경로 수정<br />* A : addconf에 의해 설치<br />* C : 캐시 항목<br />* ! : 경로 거부 |
  | Metric      | 대상까지의 거리로 최근 커널에서는 사용되지 않지만 라우팅 데몬에서 사용할 수도 있다. |
  | Ref         | 해당 경로에 대한 참조 수이지만 커널에서는 사용되지 않는다.   |
  | Use         | 경로를 탐색한 수                                             |
  | Iface       | 패킷이 전달되는 인터페이스 이름                              |

* 기본 게이트웨이 설정하기 : add

  ```
  sudo route add default gw 192.168.1.1 dev eth0
  ```

* 기본 게이트웨이 삭제하기 : del

  ```
  sudo route del default gw 192.168.1.1
  ```

### DNS 설정

**DNS 서버 지정하기**

리눅스는  DNS 서버의 주소를 /etc/resolv.conf 파일에 저장한다.

```
user1@raspberrypi:~ $ cat /etc/resolv.conf
# Generated by NetworkManager
```

DNS 서버의 정보는 systemd-resolve 명령으로 확인할 수 있다.

systemd-resolve : DNS 서버에 질의하고 응답을 받는다.

```
systemd-resolve --status
```

**nmcli 명령으로 DNS 설정하기**

```
nmcli con mod 'Wired Connection' ipv4.dns "8.8.8.8 8.8.4.4"
```

**DNS 서버에 질의하기**

nslookup : DNS 서버와 대화식으로 질의하고 응답을 받는다.

```
nmlookup
```

## 호스트 이름 설정

**호스트 이름 출력하기 : uname -n 명령**

uname : 시스템 정보를 출력한다.

```
user1@raspberrypi:~ $ uname -n
raspberrypi
```

uname -a : 호스트 이름을 포함하여 시스템 관련 정보가 출력된다.

```
user1@raspberrypi:~ $ uname -a
Linux raspberrypi 6.1.0-rpi8-rpi-v8 #1 SMP PREEMPT Debian 1:6.1.73-1+rpt1 (2024-01-25) aarch64 GNU/Linux
```

**호스트 이름 출력 및 설정하기 : hostname 명령**

hostname : 호스트 이름을 출력하거나 설정한다.

```
user1@raspberrypi:~ $ hostname
raspberrypi
user1@raspberrypi:~ $ nmcli gen host
raspberrypi
user1@raspberrypi:~ $ sudo hostname image.server
user1@raspberrypi:~ $ hostname
image.server
```

**호스트 이름 검색 및 설정하기 : hostnamectl 명령**

```
user1@raspberrypi:~ $ hostnamectl
   Static hostname: raspberrypi
Transient hostname: image.server
         Icon name: computer
        Machine ID: e56cc8b075de42579f582f050d97c805
           Boot ID: ed50e0fd2f4b4373a7ad672599cd28ff
  Operating System: Raspbian GNU/Linux 12 (bookworm)
            Kernel: Linux 6.1.0-rpi8-rpi-v8
      Architecture: arm64
```

```
user1@raspberrypi:~ $ sudo hostnamectl set-hostname raspberrypi
user1@raspberrypi:~ $ hostnamectl
 Static hostname: raspberrypi
       Icon name: computer
      Machine ID: e56cc8b075de42579f582f050d97c805
         Boot ID: ed50e0fd2f4b4373a7ad672599cd28ff
Operating System: Raspbian GNU/Linux 12 (bookworm)
          Kernel: Linux 6.1.0-rpi8-rpi-v8
    Architecture: arm64
```

**호스트 이름 파일에 저장하기**

```
user1@raspberrypi:~ $ cat /etc/hostname
raspberrypi
```

## 네트워크 상태 확인

### 통신 확인

ping : 네트워크 장비에 신호(ECHO-REQUEST)를 보낸다.

**옵션 없이 사용하기**

패킷은 기본적으로 56B 크기로 보낸다. 64B는 56B 데이터에 8B 헤더 정보를 더한 것이다.

```
user1@raspberrypi:~ $ ping 192.168.0.1
PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=3.32 ms
64 bytes from 192.168.0.1: icmp_seq=3 ttl=64 time=4.12 ms
64 bytes from 192.168.0.1: icmp_seq=5 ttl=64 time=267 ms
64 bytes from 192.168.0.1: icmp_seq=8 ttl=64 time=1.93 ms
64 bytes from 192.168.0.1: icmp_seq=10 ttl=64 time=5.71 ms
64 bytes from 192.168.0.1: icmp_seq=11 ttl=64 time=4.82 ms
64 bytes from 192.168.0.1: icmp_seq=13 ttl=64 time=4.12 ms
64 bytes from 192.168.0.1: icmp_seq=14 ttl=64 time=4.29 ms
64 bytes from 192.168.0.1: icmp_seq=15 ttl=64 time=4.12 ms
```

-c 옵션으로 보낼 패킷 수를 지정할 수 있다.

```
user1@raspberrypi:~ $ ping -c 10 192.168.0.1
PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=1.14 ms
64 bytes from 192.168.0.1: icmp_seq=2 ttl=64 time=3.95 ms
64 bytes from 192.168.0.1: icmp_seq=3 ttl=64 time=4.01 ms
64 bytes from 192.168.0.1: icmp_seq=4 ttl=64 time=315 ms
64 bytes from 192.168.0.1: icmp_seq=5 ttl=64 time=0.930 ms
64 bytes from 192.168.0.1: icmp_seq=6 ttl=64 time=3.90 ms
64 bytes from 192.168.0.1: icmp_seq=8 ttl=64 time=6.66 ms
64 bytes from 192.168.0.1: icmp_seq=9 ttl=64 time=4.02 ms

--- 192.168.0.1 ping statistics ---
10 packets transmitted, 8 received, 20% packet loss, time 9054ms
rtt min/avg/max/mdev = 0.930/42.426/314.794/102.959 ms
```

**-q 옵션 사용하기**

-q 옵션을 사용하면 아무 메시지도 출력되지 않다가 Ctrl + C로 종료하면 통계 정보만 출력된다.

```
user1@raspberrypi:~ $ ping -q 192.168.0.1
PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.


^C
--- 192.168.0.1 ping statistics ---
51 packets transmitted, 36 received, 29.4118% packet loss, time 50348ms
rtt min/avg/max/mdev = 0.914/26.878/305.922/65.987 ms
```

**도메인 이름 사용하기**

보안을 강화하기 위해 ping 패킷이 왔을 때 응답하지 않도록 설정하는 경우도 있다.

### 네트워크 상태 정보 출력

netstat : 네트워크의 상태 정보를 출력한다.

**라우팅 테이블 확인하기 : -r 옵션**

```
user1@raspberrypi:~ $ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         192.168.0.1     0.0.0.0         UG        0 0          0 wlan0
192.168.0.1     0.0.0.0         255.255.255.255 UH        0 0          0 wlan0
```

**현재 열려 있는 포트 확인하기**

현재 통신이 진행 중인 서비스는 해당 서비스 포트가 LISTEN 상태이므로 이를 통해 어떤 포트가 열려 있고 서비스 중인지 확인할 수 있다.

```
user1@raspberrypi:~ $ netstat -an | grep LISTEN
tcp        0      0 127.0.0.1:36235         0.0.0.0:*               LISTEN     
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN     
tcp6       0      0 :::22                   :::*                    LISTEN     
tcp6       0      0 :::5900                 :::*                    LISTEN     
tcp6       0      0 ::1:631                 :::*                    LISTEN     
unix  2      [ ACC ]     STREAM     LISTENING     18433    /run/user/1000/systemd/private
unix  2      [ ACC ]     STREAM     LISTENING     18442    /run/user/1000/bus
unix  2      [ ACC ]     STREAM     LISTENING     18444    /run/user/1000/gnupg/S.dirmngr
unix  2      [ ACC ]     STREAM     LISTENING     18446    /run/user/1000/gcr/ssh
unix  2      [ ACC ]     STREAM     LISTENING     18448    /run/user/1000/keyring/control
unix  2      [ ACC ]     STREAM     LISTENING     18450    /run/user/1000/gnupg/S.gpg-agent.browser
unix  2      [ ACC ]     STREAM     LISTENING     18452    /run/user/1000/gnupg/S.gpg-agent.extra
unix  2      [ ACC ]     STREAM     LISTENING     18454    /run/user/1000/gnupg/S.gpg-agent.ssh
unix  2      [ ACC ]     STREAM     LISTENING     18456    /run/user/1000/gnupg/S.gpg-agent
unix  2      [ ACC ]     STREAM     LISTENING     18458    /run/user/1000/pulse/native
unix  2      [ ACC ]     STREAM     LISTENING     18460    /run/user/1000/pipewire-0
unix  2      [ ACC ]     STREAM     LISTENING     18462    /run/user/1000/pk-debconf-socket
unix  2      [ ACC ]     STREAM     LISTENING     17388    /run/user/1000/wayland-1
unix  2      [ ACC ]     STREAM     LISTENING     19888    /run/user/1000/pcmanfm-socket--0
unix  2      [ ACC ]     STREAM     LISTENING     19974    /run/user/1000/keyring/pkcs11
unix  2      [ ACC ]     STREAM     LISTENING     20790    /run/user/1000/menu-cached-:0
unix  2      [ ACC ]     STREAM     LISTENING     19048    /run/user/1000/vscode-ipc-e61bd2d4-f2e7-4ecd-8756-2220a1318cc1.sock
unix  2      [ ACC ]     STREAM     LISTENING     17387    /tmp/.X11-unix/X0
unix  2      [ ACC ]     STREAM     LISTENING     56159    /run/user/1000/vscode-ipc-36bcf1c0-b5e6-4026-8d40-8742f93b4214.sock
unix  2      [ ACC ]     STREAM     LISTENING     57837    /run/user/1000/vscode-git-875b7eb3e2.sock
unix  2      [ ACC ]     STREAM     LISTENING     58664    /run/user/1000/vscode-ipc-199688c9-c895-4ca1-a9c9-af9cb9bc8e5a.sock
unix  2      [ ACC ]     STREAM     LISTENING     82619    /run/user/1000/.lxterminal-socket-wayland-1
unix  2      [ ACC ]     STREAM     LISTENING     18350    /tmp/wayvnc/wayvncctl.sock
unix  2      [ ACC ]     STREAM     LISTENING     14143    /tmp/ssh-XXXXXXWRXOtN/agent.1039
unix  2      [ ACC ]     STREAM     LISTENING     13211    /run/avahi-daemon/socket
unix  2      [ ACC ]     STREAM     LISTENING     13213    /run/cups/cups.sock
unix  2      [ ACC ]     STREAM     LISTENING     13215    /run/dbus/system_bus_socket
unix  2      [ ACC ]     STREAM     LISTENING     13217    /run/thd.socket
unix  2      [ ACC ]     STREAM     LISTENING     11984    /run/systemd/private
unix  2      [ ACC ]     STREAM     LISTENING     11986    /run/systemd/userdb/io.systemd.DynamicUser
unix  2      [ ACC ]     STREAM     LISTENING     11987    /run/systemd/io.system.ManagedOOM
unix  2      [ ACC ]     STREAM     LISTENING     11999    /run/systemd/fsck.progress
unix  2      [ ACC ]     STREAM     LISTENING     12007    /run/systemd/journal/stdout
unix  2      [ ACC ]     SEQPACKET  LISTENING     12009    /run/udev/control
unix  2      [ ACC ]     STREAM     LISTENING     13359    /run/systemd/journal/io.systemd.journal
unix  2      [ ACC ]     STREAM     LISTENING     17386    @/tmp/.X11-unix/X0
unix  2      [ ACC ]     STREAM     LISTENING     20614    @/home/user1/.cache/ibus/dbus-27dAj6Fu
```

**현재 열려 있는 포트를 사용 중인 프로세스 확인하기  : -p 옵션**

```
user1@raspberrypi:~ $ sudo netstat -p
Active Internet connections (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    
tcp        0      0 localhost:36235         localhost:36256         ESTABLISHED 1829/node           
tcp        0      0 localhost:36256         localhost:36235         ESTABLISHED 12800/sshd: user1@n 
tcp        0      0 192.168.0.20:ssh        192.168.0.15:54495      ESTABLISHED 12792/sshd: user1 [ 
tcp        0      0 localhost:36235         localhost:36266         ESTABLISHED 8835/node           
tcp        0      0 localhost:36235         localhost:40830         CLOSE_WAIT  1829/node           
tcp        0      0 localhost:36266         localhost:36235         ESTABLISHED 12800/sshd: user1@n 
Active UNIX domain sockets (w/o servers)
Proto RefCnt Flags       Type       State         I-Node   PID/Program name     Path
unix  3      [ ]         STREAM     CONNECTED     20732    1381/gvfs-afc-volum  
unix  3      [ ]         STREAM     CONNECTED     20001    1389/gvfs-mtp-volum  
unix  3      [ ]         STREAM     CONNECTED     20000    1381/gvfs-afc-volum  
unix  3      [ ]         STREAM     CONNECTED     84705    12879/wireplumber    
unix  3      [ ]         STREAM     CONNECTED     17267    1038/pipewire-pulse  
unix  3      [ ]         STREAM     CONNECTED     18705    1295/ibus-portal     
unix  3      [ ]         STREAM     CONNECTED     16183    896/lightdm          

...

```

**인터페이스별 네트워크 통계 정보 확인하기 : -i 옵션**

```
user1@raspberrypi:~ $ netstat -i
Kernel Interface table
Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
eth0             1500        0      0      0 0             0      0      0      0 BMU
lo              65536   132995      0      0 0        132995      0      0      0 LRU
wlan0            1500    49082      0      0 0         51632      0      0      0 BMRU
```

**프로토콜별 네트워크 통계 정보 확인하기 : -s 옵션**

```
user1@raspberrypi:~ $ netstat -s
Ip:
    Forwarding: 2
    182201 total packets received
    32 with invalid headers
    12 with invalid addresses
    0 forwarded
    0 incoming packets discarded
    182155 incoming packets delivered
    183854 requests sent out
    8696 outgoing packets dropped
    72 dropped because of missing route
Icmp:
    17915 ICMP messages received
    78 input ICMP message failed
    ICMP input histogram:
        destination unreachable: 17757
        redirects: 20
        echo requests: 19
        echo replies: 119
    18086 ICMP messages sent
    0 ICMP messages failed
    ICMP output histogram:
        destination unreachable: 17757
        echo requests: 310
        echo replies: 19
IcmpMsg:
        InType0: 119
        InType3: 17757
        InType5: 20
        InType8: 19
        OutType0: 19
        OutType3: 17757
        OutType8: 310
Tcp:
    21 active connection openings
    20 passive connection openings
    0 failed connection attempts
    4 connection resets received
    5 connections established
    145954 segments received
    148679 segments sent out
    903 segments retransmitted
    0 bad segments received
    2 resets sent
Udp:
    400 packets received
    17588 packets to unknown port received
    0 packet receive errors
    17735 packets sent
    0 receive buffer errors
    0 send buffer errors
    IgnoredMulti: 8
UdpLite:
TcpExt:
    3 ICMP packets dropped because they were out-of-window
    13 TCP sockets finished time wait in fast timer
    10340 delayed acks sent
    3 delayed acks further delayed because of locked socket
    Quick ack mode was activated 83 times
    35 SYNs to LISTEN sockets dropped
    35127 packet headers predicted
    7596 acknowledgments not containing data payload received
    72173 predicted acknowledgments
    TCPSackRecovery: 67
    Detected reordering 3 times using SACK
    TCPDSACKUndo: 43
    56 congestion windows recovered without slow start after partial ack
    TCPLostRetransmit: 130
    67 fast retransmits
    TCPTimeouts: 409
    TCPLossProbes: 438
    TCPLossProbeRecovery: 108
    TCPBacklogCoalesce: 56
    TCPDSACKOldSent: 192
    TCPDSACKRecv: 240
    TCPDSACKOfoRecv: 5
    1 connections aborted due to timeout
    TCPDSACKIgnoredNoUndo: 60
    TCPSackShifted: 2
    TCPSackMerged: 5
    TCPSackShiftFallback: 243
    TCPRcvCoalesce: 2182
    TCPOFOQueue: 217
    TCPSpuriousRtxHostQueues: 17
    TCPAutoCorking: 64
    TCPWantZeroWindowAdv: 1
    TCPSynRetrans: 86
    TCPOrigDataSent: 97865
    TCPHystartTrainDetect: 1
    TCPHystartTrainCwnd: 65
    TCPDelivered: 98031
    TCPAckCompressed: 4
    TcpTimeoutRehash: 351
    TcpDuplicateDataRehash: 12
    TCPDSACKRecvSegs: 245
IpExt:
    InMcastPkts: 692
    OutMcastPkts: 209
    InBcastPkts: 8
    InOctets: 16509406
    OutOctets: 18266678
    InMcastOctets: 64248
    OutMcastOctets: 19352
    InBcastOctets: 3646
    InCsumErrors: 32
    InNoECTPkts: 182201
MPTcpExt:
```

### MAC 주소와 IP 주소 확인

같은 네트워크에 연결된 시스템들의 MAC 주소와 IP 주소를 확인하려면 arp 명령을 사용한다.

apr(address resolution protocol)

arp : ARP 캐시 정보를 확인한다.

```
user1@raspberrypi:~ $ arp
Address                  HWtype  HWaddress           Flags Mask            Iface
192.168.0.15             ether   dc:8b:28:8c:1f:e0   C                     wlan0
192.168.0.1              ether   58:86:94:8c:62:b0   C                     wlan0
```

### 패킷 캡쳐 명령

tcpdump : 네트워크상의 트래픽을 덤프한다.

**옵션 없이 사용하기**

```
sudo tcpdump
```

**캡처할 패킷 개수 지정하기 : -c 옵션**

```
sudo tcpdump -c 3
```

**캡처한 패킷 정보를 파일로 저장하기 : -w 옵션**

```
sudo tcpdump -c 3 -w dump.out
```

```
file dump.out
```

**캡처한 패킷 파일 읽기 : -r 옵션**

```
sudo tcpdump -r dump.out
```

**특정 포트로 송수신되는 패킷 캡처하기 : tcp port 옵션**

```
sudo tcpdump -c 3 tcp port 22
```

**캡처한 내용을 ASCII로 보기 : -X 옵션**

```
sudo tcpdump -Xqr dump.out
```

# 원격 접속과 FTP

## SSH

SSH는 텔넷처럼 원격으로 시스템에 접속할 수 있도록 하지만 모든 통신을 암호화하여 주고 받는다.

**명령 프롬프트로 ssh 접속**

시스템 > 선택적 기능 > OpenSSH 클라이언트 추가 > cmd(명령 프롬프트) > ssh 접속

ssh [사용자계정]@[접속주소] -p [포트번호]

![image-20240310190122803](C:\Users\jungs\Desktop\study\ubuntulinux\assets\image-20240310190122803.png)

![image-20240310190142694](C:\Users\jungs\Desktop\study\ubuntulinux\assets\image-20240310190142694.png)

```
C:\Users\jungs>ssh user1@192.168.0.20 -p 22
ssh: connect to host 192.168.0.20 port 22: Connection timed out

C:\Users\jungs>ssh user1@192.168.0.20 -p 22
user1@192.168.0.20's password:
Linux raspberrypi 6.1.0-rpi8-rpi-v8 #1 SMP PREEMPT Debian 1:6.1.73-1+rpt1 (2024-01-25) aarch64

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Sun Mar 10 07:26:13 2024
user1@raspberrypi:~ $ ls
Bookshelf  Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos
user1@raspberrypi:~ $
```

**!!. ssh 원격 접속 에러 해결(cmd, vscode)**

putty에서는 원격 접속이 가능하나 cmd, vscode에서는 안되는 에러가 발생

git bash로

```
nano /Users/[user-name]/.ssh/known_hosts
```

파일의 접속 ip 부분을 제거

이후 연결을 시도하면 연결 성공

## 파일 송수신

FTP는 TCP/IP 프로토콜 중 5계층에 있는 프로토콜로, 

리눅스뿐만 아니라 이 프로토콜에 따르는 다른 운영체제와도 파일을 주고받을 수 있다.

FTP를 사용하려면 리눅스 시스템에 FTP 서버와 클라이언트가 설치되어 있어야 한다.

cf) : 리눅스 패키지 다운로드도 ftp를 방식이다.

```
sudo vi /etc/apt/sources.list
```

```
sudo vi /usr/share/doc/apt/examples/sources.list
```

```
deb http://ftp.kaist.ac.kr/raspbian/raspbian/ bookworm main contrib non-free
deb-src http://ftp.kaist.ac.kr/raspbian/raspbian/ bookworm main contrib non-free
```

* "deb" are binary package repositories

* "deb-src" are source package repositories, which provide access to the source code of the applications and the files needed to create a ".deb" package out of them.

### FTP 서버 설치 및 설정

리눅스에서 사용하는 대표적인 FTP 서버는 vsFTPD다.

```
sudo apt install vsftpd
```

**FTP 서버 설정하고 동작시키기**

vsFTPD 설정은 /etc/vsftpd.conf 파일에서 한다.

```
more /etc/vsftpd.conf
```

vsFTPD는 systemd 데몬으로 관리한다.

vsftpd를 시작하거나 중지하려면 다음 명령어를 사용

```
sudo systemctl stop vsftpd
sudo systemctl start vsftpd
```

FTP 서버가 정상적으로 동작하는지 확인한다.

FTP 클라이언트를 이용하여 접속할 수도 있지만 간단한 확인은 telnet 명령으로도 할 수 있다.

'220 (vsFTPd 3.0.3)' 이라는 메시지가 출력되면 FTP 서버가 제대로 동작하고 있는 것이다.

```
user1@raspberrypi:~ $ telnet 0 21
Trying 0.0.0.0...
Connected to 0.
Escape character is '^]'.
220 (vsFTPd 3.0.3)
```

### FTP 클라이언트 설치 및 사용

**FTP 서버 접속하기**

FTP 클라이언트를 사용하려면 우선 FTP 서버의 호스트명(또는 IP 주소)과 로그인명, 암호를 알아야 한다.

다른 터미널에서 다른 사용자로 접속하여 ftp 명령으로 리눅스 시스템에 접속하면 다음과 같이 로그인 명을 물어본다.

다음은 윈도의 cmd에서 라즈베리파이의 ftp 서버에 접속한 것이다.

```
C:\Users\jungs>ftp 192.168.0.20
192.168.0.20에 연결되었습니다.
220 (vsFTPd 3.0.3)
200 Always in UTF8 mode.
사용자(192.168.0.20:(none)):
331 Please specify the password.
암호:

230 Login successful.
ftp>
```

**FTP 내부 명령**

| 내부 명령                     | 의미                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| cd 원격 디렉터리              | 원격 호스트의 디렉터리를 이동한다.                           |
| lcd 지역 디렉터리             | 지역 호스트의 디렉터리를 이동한다.                           |
| pwd                           | 원격 호스트의 디렉터리를 출력한다.                           |
| !pwd                          | 지역 호스트의 디렉터리를 출력한다.                           |
| ls 또는 dir                   | 원격 호스트의 파일 목록을 출력한다.<br />dir 명령은 상세한 파일 정보를 출력한다. |
| !ls                           | 지역 호스트의 파일 목록을 출력한다.                          |
| mkdir 원격 디렉터리           | 원격 호스트에 디렉터리를 생성한다.                           |
| rmdir 원격 디렉터리           | 원격 호스트의 디렉터리를 삭제한다.                           |
| get 원격 파일명[지역 파일명]  | 원격 파일 하나를 지역 호스트로 가져온다.<br />지역 파일명을 지정하면 지정한 파일명으로 저장하고,<br />지정하지 않으면 원격 파일명과 동일한 파일명으로 저장한다. |
| mget 원격 파일명              | 원격 호스트에서 여러 개의 파일을 가져온다.                   |
| put 지역 파일명 [원격 파일명] | 지역 파일 하나를 원격 호스트로 보낸다.<br />원격 파일명을 지정하면 지정한 파일명으로 저장하고,<br />지정하지 않으면 지역 파일명과 동일한 파일명으로 저장한다. |
| mput 지역 파일명              | 여러 개의 지역 파일을 보낸다.                                |
| prompt                        | mget이나 mput 명령 사용 시 파일 전송 여부를 물어볼 것인지를 결정한다. |
| hash                          | 파일이 전송되는 동안 #을 출력하여 진행 상황을 알려준다.      |
| bin                           | 바이너리 파일을 송수신할 것임을 지정한다.                    |
| bye                           | ftp를 종료한다.                                              |
| open                          | fpt로 접속할 호스트를 입력하도록 한다.                       |
| user                          | 사용자명을 다시 입력할 수 있도록 한다.                       |
| ? 또는 help [명령]            | 명령에 대한 도움말을 출력한다.                               |

**파일 송수신하기**

* pwd, dir 명령 사용하기

  ```
  ftp> pwd
  257 "/home/user1" is the current directory
  ftp> dir
  200 PORT command successful. Consider using PASV.
  150 Here comes the directory listing.
  drwxr-xr-x    2 1000     1000         4096 Dec 05 04:47 Bookshelf
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Desktop
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Documents
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Downloads
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Music
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Pictures
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Public
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Templates
  drwxr-xr-x    2 1000     1000         4096 Mar 11 13:57 Videos
  226 Directory send OK.
  ftp: 0.01초 42.36KB/초
  ```

* get 명령 사용하기

  ```
  ftp> !chdir
  C:\Users\jungs\Desktop
  ftp> get .profile
  200 PORT command successful. Consider using PASV.
  150 Opening BINARY mode data connection for .profile (807 bytes).
  226 Transfer complete.
  ftp: 0.00초 807000.00KB/초
  ftp> !dir
   C 드라이브의 볼륨에는 이름이 없습니다.
   볼륨 일련 번호: B212-AA48
  
   C:\Users\jungs\Desktop 디렉터리
  
  2024-03-12  오전 01:53    <DIR>          .
  2024-03-12  오전 01:49    <DIR>          ..
  2024-03-12  오전 01:53               807 .profile
  2023-12-08  오전 01:29    <DIR>          Class_FrontEnd
  2023-08-30  오전 12:55            17,010 Day10_뱅킹게시판쇼핑몰시스템.md
  2023-08-30  오전 03:12             2,576 Day11_반복문 활용, 오라클 설치.md
  2024-01-14  오후 11:44    <DIR>          doit
  2024-01-14  오후 11:43            20,092 Doit점프투파이썬.md
  2023-08-12  오후 07:05             1,095 Eclipse IDE for Enterprise Java and Web Developers - 2023-06.lnk
  2023-12-01  오후 05:15    <DIR>          icia
  2023-12-01  오후 01:59    <DIR>          IntelliJ IDEA 2023.2.5
  2023-11-22  오전 02:48    <DIR>          MEMBER
  2023-05-30  오전 02:01             2,336 Microsoft Edge.lnk
  2023-11-11  오후 03:44    <DIR>          oracledb
  2023-11-09  오전 12:12    <DIR>          Spring_Workspace
  2023-12-01  오후 03:42    <DIR>          sqldeveloper
  2023-11-04  오후 07:09             1,319 sqldeveloper - 바로 가기.lnk
  2023-11-11  오후 03:44    <DIR>          sts-bundle
  2024-03-10  오전 05:21    <DIR>          study
  2023-11-26  오후 07:14             1,032 Telegram.lnk
  2023-08-06  오후 08:56             1,410 Visual Studio Code.lnk
  2023-09-17  오후 09:38             3,234 [Spring] 게시판 만들기(1) - 웹개발 환경 다운로드 및 설치.md
  2024-01-14  오후 05:00            18,688 오라클로 배우는 데이터베이스 입문.md
  2023-11-16  오후 02:41    <DIR>          프로젝트
  2023-11-16  오후 02:42    <DIR>          프로젝트자료
  2023-12-06  오전 08:53             2,052 할것.md
  2024-03-05  오후 07:55            21,557 혼공C.md
  2023-11-11  오후 03:44    <DIR>          회사업무
                13개 파일              93,208 바이트
                15개 디렉터리  19,718,426,624 바이트 남음
  ftp>
  ```

  이와 같이 원격 디렉터리에서 지역 디렉터리로 가져온 파일을 확인할 수 있다.

  ![image-20240312015504126](C:\Users\jungs\Desktop\study\ubuntulinux\assets\image-20240312015504126.png)

* mget 명령 사용하기

  여러 파일을 내려받을 때는 mget 명령을 사용하는 것이 편리하다.

  .bashrc, .bash_logout, .bash_history를 가져와본다.

  ```
  ftp> mget .bashrc .bash_logout .bash_history
  200 Switching to ASCII mode.
  mget .bashrc?
  200 PORT command successful. Consider using PASV.
  150 Opening BINARY mode data connection for .bashrc (3523 bytes).
  226 Transfer complete.
  ftp: 0.00초 3523000.00KB/초
  mget .bash_logout?
  200 PORT command successful. Consider using PASV.
  150 Opening BINARY mode data connection for .bash_logout (220 bytes).
  226 Transfer complete.
  ftp: 0.00초 220000.00KB/초
  mget .bash_history?
  200 PORT command successful. Consider using PASV.
  150 Opening BINARY mode data connection for .bash_history (0 bytes).
  226 Transfer complete.
  ftp> !dir
   C 드라이브의 볼륨에는 이름이 없습니다.
   볼륨 일련 번호: B212-AA48
  
   C:\Users\jungs\Desktop 디렉터리
  
  2024-03-12  오전 01:57    <DIR>          .
  2024-03-12  오전 01:49    <DIR>          ..
  2024-03-12  오전 01:57             3,523 .bashrc
  2024-03-12  오전 01:57                 0 .bash_history
  2024-03-12  오전 01:57               220 .bash_logout
  2024-03-12  오전 01:53               807 .profile
  2023-12-08  오전 01:29    <DIR>          Class_FrontEnd
  2023-08-30  오전 12:55            17,010 Day10_뱅킹게시판쇼핑몰시스템.md
  2023-08-30  오전 03:12             2,576 Day11_반복문 활용, 오라클 설치.md
  2024-01-14  오후 11:44    <DIR>          doit
  2024-01-14  오후 11:43            20,092 Doit점프투파이썬.md
  2023-08-12  오후 07:05             1,095 Eclipse IDE for Enterprise Java and Web Developers - 2023-06.lnk
  2023-12-01  오후 05:15    <DIR>          icia
  2023-12-01  오후 01:59    <DIR>          IntelliJ IDEA 2023.2.5
  2023-11-22  오전 02:48    <DIR>          MEMBER
  2023-05-30  오전 02:01             2,336 Microsoft Edge.lnk
  2023-11-11  오후 03:44    <DIR>          oracledb
  2023-11-09  오전 12:12    <DIR>          Spring_Workspace
  2023-12-01  오후 03:42    <DIR>          sqldeveloper
  2023-11-04  오후 07:09             1,319 sqldeveloper - 바로 가기.lnk
  2023-11-11  오후 03:44    <DIR>          sts-bundle
  2024-03-10  오전 05:21    <DIR>          study
  2023-11-26  오후 07:14             1,032 Telegram.lnk
  2023-08-06  오후 08:56             1,410 Visual Studio Code.lnk
  2023-09-17  오후 09:38             3,234 [Spring] 게시판 만들기(1) - 웹개발 환경 다운로드 및 설치.md
  2024-01-14  오후 05:00            18,688 오라클로 배우는 데이터베이스 입문.md
  2023-11-16  오후 02:41    <DIR>          프로젝트
  2023-11-16  오후 02:42    <DIR>          프로젝트자료
  2023-12-06  오전 08:53             2,052 할것.md
  2024-03-05  오후 07:55            21,557 혼공C.md
  2023-11-11  오후 03:44    <DIR>          회사업무
                16개 파일              96,951 바이트
                15개 디렉터리  19,727,159,296 바이트 남음
  ```

  이와 같이 파일을 내려받은 것을 확인할 수 있다.

  ![image-20240312015846134](C:\Users\jungs\Desktop\study\ubuntulinux\assets\image-20240312015846134.png)

* hash 명령 사용하기

  ```
  ftp> get Bookshelf.zip
  200 PORT command successful. Consider using PASV.
  150 Opening BINARY mode data connection for Bookshelf.zip (170 bytes).
  226 Transfer complete.
  ftp: 0.00초 170000.00KB/초
  ftp> get All.tar
  200 PORT command successful. Consider using PASV.
  150 Opening BINARY mode data connection for All.tar (57518080 bytes).
  ##########################################################################226 Transfer complete.
  ftp: 14.98초 3840.94KB/초
  ftp>
  ```

  ![image-20240312020843094](C:\Users\jungs\Desktop\study\ubuntulinux\assets\image-20240312020843094.png)

* bye 명령 사용하기

  ```
  ftp> bye
  221 Goodbye.
  
  C:\Users\jungs\Desktop>
  ```

### 익명 FTP 사용 방법

익명 FTP란 FTP 서비스를 제공하는 호스트에 등록된 로그인명을 몰라도 익명으로 ftp를 이용할 수 있도록 하는 것이다.

이때 사용하는 로그인명은 anonymous이며, 암호에는 자신의 이메일 주소를 입력하면 된다.

익명 FTP 서비스는 시스템 관리자가 이 서비스를 제공하도록 설정해놓은 호스트만 서비스 제공이 가능하다.

익명 FTP의 허용은 /etc/vsftpd.conf 파일에서 한다.

vsFTPD는 기본적으로 익명 FTP를 허용한다.

```
sudo vi /etc/vsftpd.conf

...

# Allow anonymous FTP? (Disabled by default).
anonymous_enable=YES

...

```

```
user1@raspberrypi:~ $ systemctl restart vsftpd
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ====
Authentication is required to restart 'vsftpd.service'.
Authenticating as: ,,, (user1)
Password: 
==== AUTHENTICATION COMPLETE ====
```

```
C:\Users\jungs\Desktop>ftp 192.168.0.20
192.168.0.20에 연결되었습니다.
220 (vsFTPd 3.0.3)
200 Always in UTF8 mode.
사용자(192.168.0.20:(none)): anonymous
331 Please specify the password.
암호:

230 Login successful.
```

## 메일 송수신

