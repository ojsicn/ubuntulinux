# 리눅스 기초

## 리눅스의 구조

* 커널

  : 프로세스 관리, 메모리 관리, 파일 시스템 관리, 장치 관리 등 컴퓨터의 모든 자원을 초기화, 모니터링, 제어하는 기능을 수행

* 셸

  : 리눅스의 사용자 인터페이스

  : 사용자와 커널 사이의 중간자 역할

  : 셸은 사용자가 입력한 명령을 해석하여 커널에 넘겨준다. 이후 커널은 명령의 수행 결과를 돌려주고 셸은 다시 사용자가 이해할 수 있는 형태로 바꿔 출력한다.

* 응용 프로그램

  : 각종 프로그래밍 개발 도구, 문서 편집 도구, 네트워크 관련 도구 등의 사용자 편의 기능 프로그램

## 리눅스 실습 환경 구축

리눅스 실습 환경은 다음과 같다. VMWare 등 가상환경으로 실습해도 되고 OS를 여러 개 설치한 듀얼부팅을 통해서도 실습해도 된다. 나의 경우에는 라즈베리파이를 통해 실습을 진행하였다. 라즈비안OS를 설치하는 과정은 생략하였다. 다만 해당 링크를 걸어둔다.

[라즈비안OS 설치 링크](https://www.robotstory.co.kr/raspberry/?board_page=6&vid=31)

| 하드웨어      | OS                             | 통신방식 | 코드 에디터 |
| ------------- | ------------------------------ | -------- | ----------- |
| 라즈베리파이3 | 라즈비안OS(우분투와 거의 동일) | SSH      | VSCode      |

실습 환경 구축은 다음과 같다.

1. VSCode 설치

   ![image-20240217212357709](.\assets\image-20240217212357709.png)

2. SSH 연결

   1. 라즈베리파이 SSH 설치

   ![image-20240217212710846](.\assets\image-20240217212710846.png)

   2. VSCode - Extension - Remote-SSH 설치

      ![image-20240217212849641](.\assets\image-20240217212849641.png)

   3. VSCode - F1키 or Ctrl + Shif + p - Remote-SSH: Open SSH Configuration File - 기본경로 - 설정파일 수정

      * Host : 사용할 이름(아무거나 지정)
      * HostName : 접속할 서버의 호스트이름 or ip
      * User : 접속할 서버의 사용자명
      * IdentityFile : pem키의 경로 및 파일명

      ![image-20240217213149768](.\assets\image-20240217213149768.png)

   4. VSCode - F1키 or Ctrl + Shift + p - Connect to Host - 지정한 호스트명

   5. 좌측 중간 모니터 아이콘 클릭 및 ssh 접속

      ![image-20240217213552261](.\assets\image-20240217213552261.png)

## 리눅스 명령 사용법

* 터미널 접속 해제 : exit, ^d
* 문자 지우기 : delete 키
* 단어 지우기 : ctrl + w
* 모두 지우기 : ctrl + u

### 명령의 구조

* 형식

  명령 [옵션] [인자]

  * 명령

    사용자가 리눅스에게 명령을 내리기 위해 사용하는 명령어

  * 옵션

    명령의 세부 기능 

  * 인자

    명령으로 전달되는 값

### 기초 명령 사용법

* date 명령

  * 날짜와 시간을 출력
  * date

* clear 명령

  * 화면을 지운다.
  * clear

* man

  * 명령 사용 방법을 화면에 출력한다.
  * man [명령]

* passwd 

  * 사용자 계정의 비밀번호 변경

    passwd [사용자]

# 디렉터리와 파일 사용법

* 리눅스 파일의 종류와 특징
* 디렉터리 계층 구조
* 절대 경로명과 상대 경로명
* 디렉터리 이동, 디렉터리 내용 확인
* 디렉터리 생성, 삭제
* 파일 내용 확인
* 파일 복사/이동/삭제
* 파일 링크의 특징
* 하드 링크, 심볼릭 링크 생성
* 파일의 내용과 위치 검색

## 리눅스 파일과 디렉터리

### 파일의 종류

* 일반 파일

  : 각종 텍스트 파일, 실행 파일, 이미지 파일 등

  : 실행 파일이나 이미지 파일의 경우 바이너리 형태로 저장(바이너리 파일은 특정 응용 프로그램이 있어야 해당 내용을 확인할 수 있다)

* 디렉터리

  : 파일의 목록 관리 파일

* 심볼릭 링크

  : 원본 파일을 대신하도록 원본 파일을 다른 파일명으로 지정한 것(윈도의 바로가기 파일)

* 장치 파일

  : 리눅스에서는 각종 장치도 파일로 취급한다.

  : 장치 파일은 리눅스 시스템에 부착된 장치들을 관리하기 위한 특수 파일이다.

  : 대부분의 장치 파일은 /dev 디렉터리 아래에 위치

### 디렉터리의 계층 구조

리눅스에서는 파일을 효율적으로 관리하기 위해 디렉터리를 계층적으로 구성하는데 이를 트리(tree) 구조라고 한다.

리눅스의 모든 디렉터리의 출발점은 루트(root) 디렉터리이다. 루트 디렉터리는 / 로 표시한다.

### 리눅스 디렉터리의 계층 구조 및 기능

**디렉터리의 계층 구조**

![image-20240217223553877](.\assets\image-20240217223553877.png)

**디렉터리의 주요 기능**

| 디렉터리   | 기능                                                         |
| ---------- | ------------------------------------------------------------ |
| dev        | 장치 파일이 담긴 디렉터리<br />![image-20240224004726978](.\assets\image-20240224004726978.png) |
| home       | 사용자 홈 디렉터리<br />![image-20240224004758246](.\assets\image-20240224004758246.png) |
| media      | DVD/CD나 USB 같은 외부 장치를 연결(마운트라고 한다)하는 디렉터리<br />![image-20240224004815278](.\assets\image-20240224004815278.png) |
| opt        | 추가 패키지가 설치되는 디렉터리<br />![image-20240224004831980](.\assets\image-20240224004831980.png) |
| root       | root 계정의 홈 디렉터리, 루트(/) 디렉터리와는 다른 것이므로 혼동X<br />![image-20240224004935006](.\assets\image-20240224004935006.png) |
| sys        | 리눅스 커널과 관련된 파일이 있는 디렉터리<br />![image-20240224004951936](.\assets\image-20240224004951936.png) |
| usr        | 기본 실행 파일, 라이브러리 파일, 헤더 파일 등 이 있다. usr는 'Unix System Resource'의 약자<br />![image-20240224005008762](.\assets\image-20240224005008762.png) |
| boot       | 부팅에 필요한 커널 파일을 가지고 있다.<br />![image-20240224005034518](.\assets\image-20240224005034518.png) |
| etc        | 리눅스 설정을 위한 각종 파일을 가지고 있다.<br />![image-20240224005158575](.\assets\image-20240224005158575.png) |
| lost+found | 파일 시스템에 문제가 발생하여 복구할 경우, 문제가 되는 파일이 저장되는 디렉터리로 보통은 비어 있다.<br />![image-20240224005238806](.\assets\image-20240224005238806.png) |
| mnt        | 파일 시스템을 임시로 마운트하는 디렉터리<br />![image-20240224005300413](.\assets\image-20240224005300413.png) |
| proc       | 프로세스 정보 등 커널 관련 정보가 저장되는 디렉터리<br />![image-20240224005318878](.\assets\image-20240224005318878.png) |
| run        | 실행 중인 서비스와 관련된 파일이 저장<br />![image-20240224005340968](.\assets\image-20240224005340968.png) |
| srv        | FTP나 Web 등 시스템에 제공하는 서비스의 데이터가 저장된다.<br />![image-20240224005407110](.\assets\image-20240224005407110.png) |
| tmp        | 시스템 사용 중에 발생하는 임시 데이터가 저장된다. 이 디렉터리에 있는 파일은 재시작하면 모두 삭제된다.<br />![image-20240224005424048](.\assets\image-20240224005424048.png) |
| var        | 시스템 운영 중에 발생하는 데이터나 로그 등 내용이 자주 바뀌는 파일이 주로 저장된다.<br />![image-20240224005434944](.\assets\image-20240224005434944.png) |



### 절대 경로명과 상대 경로명

경로명에서 가장 앞에 있는 /는 루트 디렉터리를, 중간의 /는 구분자로 사용된다.

**※ 절대 경로명과 상대 경로명의 특징**

| 구분        | 특징                                                         |
| ----------- | ------------------------------------------------------------ |
| 절대 경로명 | 루트 디렉터리가 기준이 된다.<br />ex) /home/Desktop/test.txt |
| 상대 경로명 | 현재 디렉터리가 기준이 된다.<br />ex) ../../etc/hosts        |

## 디렉터리 관련 명령

### 현재 디렉터리 확인 : pwd

### 디렉터리 이동 : cd

### 디렉터리 내용 확인 : ls

| 옵션                 | 설명                                                      |
| -------------------- | --------------------------------------------------------- |
| -a(all)              | 숨김 파일을 포함하여 모든 파일 목록                       |
| -d(directory)        | 디렉터리 자체의 정보<br />-ld 로 써야 자체 정보가 나온다. |
| -i(inode)            | inode 번호                                                |
| -l(long list format) | 파일의 상세 정보                                          |
| -A(almost all)       | .와 ..를 제외한 모든 파일 목록                            |
| -F(classify)         | 파일의 종류(* 실행파일, / 디렉터리, @ 심볼릭 링크)        |
| -L(dereference)      | 심볼릭 링크 파일의 경우 원본 파일의 정보 출               |
| -R(recursive)        | 하위 디렉터리의 목록까지 출력                             |
| -h(human readable)   | with -l and -s, print sizes like 1K 234M 2G etc.          |
| -S(sort)             | sort by file size, largest first                          |
| -t(time)             | sort by time, newest first; see --time                    |

**파일의 상세 정보**

ex) drwxr-xr-x 2 root root 4096 Feb 17 22:39 watchdog 

| 필드 값      | 의미                                                         |
| ------------ | ------------------------------------------------------------ |
| d            | 다음과 같은 파일 종류를 나타낸다.<br />- : 일반 파일<br />d : 디렉터리 파일<br />l : 심볼릭 링크 파일<br />b : 블록 단위로 읽고 쓰는 블록 장치 파일<br />c : 섹터 단위로 읽고 쓰는 문자 장치 파일<br />p : 파이프 파일(프로세스 간 통신에 사용되는 특수 파일)<br />s : 소켓(네트워크 통신에 사용되는 특수 파일) |
| rwxr-xr-x    | 파일의 사용자에 따른 접근 권한                               |
| 2            | 하드 링크의 개수                                             |
| root         | 파일 소유자                                                  |
| root         | 파일이 속한 그룹                                             |
| 4096         | 파일 크기(바이트 단위)                                       |
| Feb 17 22:39 | 파일이 마지막으로 수정된 시간                                |
| watchdog     | 파일명                                                       |

이밖에도 파일이 있는지 없는지 확인하는 용도로도 사용이 된다.

ex) ls .bashrc

### 디렉터리 생성 : mkdir

| 옵션 | 설명                                                   |
| ---- | ------------------------------------------------------ |
| -p   | 중간 단계의 디렉터리를 생성하고 지정한 디렉터리를 생성 |

**디렉터리 여러 개 만들기**

![image-20240217234741682](.\assets\image-20240217234741682.png)

**중간 디렉터리 자동으로 만들기 : -p**

![image-20240217234925912](.\assets\image-20240217234925912.png)

### 디렉터리 삭제 : rmdir

| 옵션 | 설명                                                         |
| ---- | ------------------------------------------------------------ |
| -p   | 지정한 디렉터리를 삭제하고 그 디렉터리의 부모 디렉터리가 빈 디렉터리일 경우 부모 디렉터리도 삭제 |

## 파일 관련 명령

### 파일 내용 출력

**cat : 파일 내용 연속 출력**

| 옵션 | 설명                  |
| ---- | --------------------- |
| -n   | 행 번호를 붙여서 출력 |

**more : 파일 내용 화면 단위 출력**

| 옵션     | 설명                       |
| -------- | -------------------------- |
| +행 번호 | 출력을 시작할 행 번호 지정 |

**less : 파일 내용 화면 단위 출력**

**tail : 파일 내용의 뒷부분 출력**

| 옵션     | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| +행 번호 | 지정한 행부터 끝까지 출력                                    |
| -숫자    | 화면에 출력할 행의 수를 지정(기본값은 10)                    |
| -f       | 파일 출력을 종료하지 않고 주기적으로 계속 출력한다(파일 내용의 변화를 확인할 때 편리). |

### cp : 파일 복사

| 옵션   | 설명                                                         |
| ------ | ------------------------------------------------------------ |
| -i     | 파일2가 이미 존재하면 덮어쓸 것인지 물어본다.                |
| -r, -R | 디렉터리를 재귀적으로 복사한다. 만약 소유자, 퍼미션까지 원본과 동일하게 복사하려면 -a를 사용한다. |

### mv : 파일 이동과 파일명 변경

| 옵션 | 설명                                             |
| ---- | ------------------------------------------------ |
| -i   | 동일명의 파일이 존재하면 덮어쓸 것인지 물어본다. |

### rm : 파일 삭제

| 옵션 | 설명                            |
| ---- | ------------------------------- |
| -i   | 파일을 삭제할 것인지 확인한다.  |
| -r   | 디렉터리를 재귀적으로 삭제한다. |

### 파일 링크

파일의 구성 : 파일명 + inode + 데이터 블록

* 파일명 : 사용자가 파일에 접근할 때 사용하는 파일 이름
* inode : 파일 정보가 담긴 구조체이다. 외부적으로는 번호로 표시되고 내부적으로는 파일의 종류와 크기, 소유자, 파일 변경 시간, 파일명 등 파일 상세 정보와 데이터 블록 주소가 저장되어 있다.
* 데이터 블록 : 

### ln : 하드 링크 만들기

| 옵션 | 설명                  |
| ---- | --------------------- |
| -s   | 심볼릭 링크 파일 생성 |

### touch : 빈 파일 만들기, 접근/수정 시간 변경하기

| 옵션                     | 설명             |
| ------------------------ | ---------------- |
| -a                       | 접근 시간만 변경 |
| -m                       | 수정 시간만 변경 |
| -t [[CC]YY]MMDDhhmm[.ss] | 시간을 직접 입력 |

### grep : 파일 내용 검색

| 옵션 | 설명                               |
| ---- | ---------------------------------- |
| -i   | 대소문자를 모두 검색               |
| -l   | 지정한 패턴이 포함된 파일명을 출력 |
| -n   | 행 번호를 출력                     |

### find : 파일 찾기

* 형식 : find [경로] [검색 조건] [동작]
* 검색 조건
  * -name filename : 파일명으로 검색한다.
  * -type 파일 종류 : 파일 종류로 검색한다.
  * -user loginID : 지정한 사용자가 소유한 모든 파일을 검색한다.
  * -perm 접근 권한 : 지정한 사용 권한과 일치하는 파일을 검색한다.
* 동작
  * -exec 명령 {} \; : 검색된 파일에 명령을 실행한다.
  * -ok 명령 {} \; : 사용자의 확인을 받아서 명령을 실행한다.
  * -print : 검색된 파일의 절대 경로명을 화면에 출력한다(기본 동작).
  * -ls : 검색 결과를 긴 목록 형식으로 출력한다.

### whereis : 명령의 위치 찾기

| 옵션 | 설명                 |
| ---- | -------------------- |
| -b   | 바이너리 파일만 검색 |
| -m   | 메뉴얼 파일만 검색   |
| -s   | 소스 파일만 검색     |

### which : 명령의 위치 찾기

# 문서 편집

## vi 사용법

### vi 동작 모드

![image-20240218203005425](.\assets\image-20240218203005425.png)

**vi 파일 저장 및 종료**

| 명령키          | 기능                                                         |
| --------------- | ------------------------------------------------------------ |
| :q              | 작업한 내용을 저장하지 않고 종료                             |
| :q!             | 작업한 내용을 저장하지 않고 종료                             |
| :w or :w 파일명 | 작업한 내용을 저장만 한다. 파일명을 지정하면 다른 파일로 저장한다. |
| :wq, :wq!       | 작업한 내용을 저장하고 종료                                  |
| ZZ(shift + zz)  | 작업한 내용을 저장하고 종료                                  |

### vi 모드 전환

| 명령키      | 기능             |
| ----------- | ---------------- |
| i           | 현재 자리        |
| a           | 다음 자리        |
| o           | 다음 행          |
| I(대문자 i) | 행의 첫 칼럼     |
| A           | 행의 마지막 칼럼 |
| O           | 행의 이전 행     |

### 커서와 화면 이동

| 명령키         | 기능                      |
| -------------- | ------------------------- |
| k / j          | 위 / 아래                 |
| l / h          | 오른쪽 / 왼쪽             |
| 0 / $          | 현재 행의 처음 / 마지막   |
| - / + or Enter | 앞 / 다음 행의 처음       |
| H / M / L      | 맨 위 / 중간 / 맨 아래    |
| w / e          | 다음 단어의 처음 / 마지막 |
| b              | 앞 단어의 첫 글자         |

| 명령키 | 기능           |
| ------ | -------------- |
| ^u     | 반 화면 위로   |
| ^d     | 반 화면 아래로 |
| ^b     | 한 화면 위로   |
| ^f     | 한 화면 아래로 |
| ^y     | 한 행만 위로   |
| ^e     | 한 행만 아래로 |

| 명령키   | 기능                           |
| -------- | ------------------------------ |
| G        | 마지막 행으로 커서 이동        |
| 행 번호G | 지정한 행 번호로 커서 이동     |
| :행 번호 | 지정한 행 번호로 커서 이동     |
| :$       | 파일의 마지막 행으로 커서 이동 |

### 내용 수정

| 명령키  | 기능                                                |
| ------- | --------------------------------------------------- |
| r       | 다른 글자로 수정                                    |
| cw, #cw | 단어 수정. #에는 수정할 단어의 수를 지정            |
| s, #s   | Esc를 입력할 때까지 수정. #에는 수정할 글자 수 지정 |
| cc      | 행의 내용 모두 수정                                 |
| C       | 행의 끝까지 수정                                    |

### 내용 삭제

| 명령키  | 기능             |
| ------- | ---------------- |
| x, #x   | 글자 삭제        |
| dw, #dw | 단어 삭제        |
| dd, #dd | 행 삭제          |
| D       | 행의 끝까지 삭제 |

### 명령 취소

| 명령키 | 기능                                                |
| ------ | --------------------------------------------------- |
| u      | 명령 취소                                           |
| U      | 해당 행에서의 모든 명령 취소                        |
| :e!    | 마지막으로 저장한 내용 이후의 것을 버리고 새로 작업 |

### 복사 및 잘라 붙이기

| 명령키  | 기능                 |
| ------- | -------------------- |
| yy, #yy | 행 복사              |
| p       | 행의 아래쪽에 붙인다 |
| P       | 행의 위쪽에 붙인다   |
| dd, #dd | 행을 잘라둔다        |

### 검색 및 바꾸기

| 명령키  | 기능                                |
| ------- | ----------------------------------- |
| /문자열 | 아래 방향으로 검색                  |
| ?문자열 | 위 방향으로 검색                    |
| n       | 원래 찾던 방향으로 다음 문자열 검색 |
| N       | 역방향으로 다음 문자열 검색         |

| 명령키  | 기능                                                         |
| ------- | ------------------------------------------------------------ |
| :r 파일 | 지정한 파일을 읽어들여 현재 커서 위치에 삽입                 |
| :e 파일 | 지정한 파일로 전환한다(기존 파일을 :w로 저장한 뒤에 실행)    |
| :n      | vi 시작 시 여러 파일을 지정했을 경우 다음 파일로 작업을 이동 |

| 명령키     | 기능                                                         |
| ---------- | ------------------------------------------------------------ |
| :! 셸 명령 | vi 작업 중단 및 셸 명령 실행(돌아오려면 Enter)               |
| :sh        | vi를 잠시 빠져나가서 셸 명령 실행(vi로 돌아오려면 exit 명령 실행) |

## vi 환경 설정

| set 명령과 옵션 | 기능                             |
| --------------- | -------------------------------- |
| set nu          | 행 번호 표시                     |
| set nonu        | 행 번호 표시X                    |
| set list        | 특수문자 표시                    |
| set nolist      | 특수문자 감추기                  |
| set showmode    | 현재 모드 표시                   |
| set noshowmode  | 현재 모드 감추기                 |
| set             | vi 환경 설정 값 출력             |
| set all         | 모든 vi 환경 변수와 현재 값 출력 |

# 셸 사용법

## 셸 기본 사용법

### 특수문자 사용 방법

**특수문자 * **

| 사용예                                      | 의미                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| ls *                                        | 현재 디렉터리의 모든 파일과 서브 디렉터리 나열. 서브 디렉터리 내용도 출력<br />![image-20240219210708375](.\assets\image-20240219210708375.png) |
| cp * /temp<br />sudo cp -a * ~/Desktop/temp | 현재 디렉터리의 모든 파일을 /tmp 디렉터리 아래로 복사<br />![image-20240219211038744](.\assets\image-20240219211038744.png) |
| ls -F s*                                    | 파일명이 t로 시작하는 모든 파일의 이름과 파일 종류를 출력<br />![image-20240219211215343](.\assets\image-20240219211215343.png) |
| cp *.py ../copypy                           | 확장자가 .py인 모든 파일을 상위 디렉터리 아래의 copypy 디렉터리로 복사<br />![image-20240219211403104](.\assets\image-20240219211403104.png) |
| ls -l a*y                                   | 파일명이 h로 시작하고 d로 끝나는 모든 파일의 상세 정보를 출력<br />![image-20240219211519885](.\assets\image-20240219211519885.png) |

**특수문자 ? 와 []**

| 사용예                   | 의미                                                         |
| ------------------------ | ------------------------------------------------------------ |
| ls -l test[135abcde].txt | 숫자 1, 3, 5 문자 a, b, c, d, e <br />![image-20240221201654339](.\assets\image-20240221201654339.png) |
| ls -l test[1-3].txt      | 숫자 1-3 사이<br />![image-20240221201811803](.\assets\image-20240221201811803.png) |
| ls [0-9]*                | 숫자 0-9 사이<br />![image-20240221202045091](.\assets\image-20240221202045091.png) |

**특수문자 ~와 -**

| 사용 예         | 의미                                                         |
| --------------- | ------------------------------------------------------------ |
| cp *.txt ~/temp | ![image-20240221202604156](.\assets\image-20240221202604156.png) |
| cd -            | ![image-20240221203123696](.\assets\image-20240221203123696.png) |

**특수문자 ;과 |**

| 사용 예          | 의미                                                         |
| ---------------- | ------------------------------------------------------------ |
| date; ls; pw     | ![image-20240221203310973](.\assets\image-20240221203310973.png) |
| ls -al / \| more | ![image-20240221203403068](.\assets\image-20240221203403068.png) |

**특수문자 ' '와 " "**

' ' : 모든 특수문자 무효화

" " : $, `, \ 를 제외한 특수문자 무효화

| 사용 예       | 의미                                                         |
| ------------- | ------------------------------------------------------------ |
| echo '$SHELL' | ![image-20240221203713942](.\assets\image-20240221203713942.png) |
| echo "$SHELL" | ![image-20240221204021183](.\assets\image-20240221204021183.png) |

**특수문자 ``**

| 사용 예                                           | 의미                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| echo "Today is `date`(원래는 ``로 date를 감싼것)" | ![image-20240221204312501](.\assets\image-20240221204312501.png) |
| ls /usr/bin/`uname -m`                            |                                                              |

![image-20240221205056127](.\assets\image-20240221205056127.png)

**특수문자 \ **

| 사용 예                  | 의미                                                         |
| ------------------------ | ------------------------------------------------------------ |
| touch t\*<br />ls -l t\* | ![image-20240221205442271](.\assets\image-20240221205442271.png) |
| echo \$SHELL             | ![image-20240221205526479](.\assets\image-20240221205526479.png) |

**특수문자 >, <, >>**

`>` : 덮어쓰기
명령 [파일 디스크립터]> 파일명 ([파일 디스크립터]와 > 사이에 공백X)
ex) ls -l 0> res.txt 

| 사용 예          | 의미                                                         |
| ---------------- | ------------------------------------------------------------ |
| ls -l > res.txt  | ![image-20240221205719684](.\assets\image-20240221205719684.png) |
| ls -l >> res.txt | ![image-20240221205829814](.\assets\image-20240221205829814.png)<br /><br />![image-20240221205842102](.\assets\image-20240221205842102.png) |
| cat < text.txt   | ![image-20240221211040986](.\assets\image-20240221211040986.png) |

## 입출력 방향 변경

입력도 키보드로 하는 것이 아니라 파일에서 읽어오도록 할 수 있다.

리눅스에서 입력과 출력으로 사용하는 장치를 바꾸면 출력을 화면이 아닌 파일에 하고 입력도 파일에서 받을 수 있다.

입출력 장치를 바꾼다.

### 표준 입출력 장치

표준 출력과 별도로 오류 메시지를 내보내는 장치를 표준 오류 장치라고 한다.

리눅스는 장치도 파일로 관리한다.

셸은 작업 중 필요한 파일에 일련번호를 붙여서 관리하며 이를 '파일 디스크립터'라고 한다.

표준 입출력 장치도 파일로 관리되기 때문에 파일 디스크립터가 부여되어 있다.

입출력 장치를 변경할 때는 이 파일 디스크립터를 사용한다.

표준 입출력 장치를 파일로 바꾸는 것을 '리다이렉션'이라고 한다.

| ㅁ파일 디스크립터 | 파일 디스크립터 대신 사용하는 이름 | 정의             |
| ----------------- | ---------------------------------- | ---------------- |
| 0                 | stdin                              | 명령의 표준 입력 |
| 1                 | stdout                             | 명령의 표준 출력 |
| 2                 | stderr                             | 명령의 표준 오류 |

### 출력 리다이렉션

**> (Overwrite)**

![image-20240221211501262](.\assets\image-20240221211501262.png)

![image-20240221211728857](.\assets\image-20240221211728857.png)

![image-20240221211814051](.\assets\image-20240221211814051.png)

![image-20240221211933332](.\assets\image-20240221211933332.png)

*194p [240221수2224]*

**set 명령**

![image-20240223223102657](.\assets\image-20240223223102657.png)

```
set: set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]
```

```
Set or unset values of shell options and positional parameters.

Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.
```

```
-C  If set, disallow existing regular files to be overwritten
          by redirection of output.
```

**>> (append)**

![image-20240223223648585](.\assets\image-20240223223648585.png)

### 오류 리다이렉션

표준 출력은 1번, 표준 오류는 2번 장치 파일이다.

![image-20240223224125140](.\assets\image-20240223224125140.png)

![image-20240223224214513](.\assets\image-20240223224214513.png)

### 입력 리다이렉션

https://ehpub.co.kr/15-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98%EA%B3%BC-%ED%8C%8C%EC%9D%B4%ED%94%84%EB%A5%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%95%84%EC%9A%94/

```c
// demo2.c

#include <stdio.h>

int main(void) {
    int num;
    char name[20] = "";

    printf("번호입력 : \n");
    scanf("%d", &num);
    printf("이름입력 : \n");
    scanf("%s", &name);

    printf("번호 : %d, 이름 : %s\n", num, name);

    return 0;
}
```

```
// input
3
홍길동
```

![image-20240223230511292](.\assets\image-20240223230511292.png)

```
3
홍길동
```

![image-20240223230538437](.\assets\image-20240223230538437.png)

## 배시셸 환경 설정

### 셸 변수와 환경 변수

셸 변수는 현재 셸에서만 사용할 수 있고 서브 셸로는 전달되지 않지만, 환경 변수는 현재 셸뿐만 아니라 서브 셸로도 전달된다.

**주요 셸 환경 변수**

| 환경 변수 | 의미                           |
| --------- | ------------------------------ |
| HISTSIZE  | 히스토리 저장 크기             |
| HOME      | 사용자 홈 디렉토리의 절대 경로 |
| LANG      | 사용하는 언어                  |
| LOGNAME   | 사용자 계정 이름               |
| PATH      | 명령을 탐색할 경로             |
| PWD       | 작업 디렉토리의 절대 경로      |
| SHELL     | 로그인 셸                      |

![image-20240223231531832](.\assets\image-20240223231531832.png)

### 셸 변수와 환경 변수 설정

변수명=문자열

셸 변수로는 설정했지만 환경 변수로는 설정하지 않았다.

환경 변수로 설정하면 셸 변수로도 설정이 된다.

환경 변수 : 전역 변수 / 셸 변수 : 지역 변수

![image-20240223234145459](.\assets\image-20240223234145459.png)

### 변수 해제

![image-20240223234223599](.\assets\image-20240223234223599.png)

## 앨리어스와 히스토리

![image-20240223234335036](.\assets\image-20240223234335036.png)

![image-20240223234546373](.\assets\image-20240223234546373.png)

![image-20240223234555843](.\assets\image-20240223234555843.png)

![image-20240223234603618](.\assets\image-20240223234603618.png)

![image-20240223235231868](.\assets\image-20240223235231868.png)

![image-20240223235323282](.\assets\image-20240223235323282.png)

![image-20240224000214141](.\assets\image-20240224000214141.png)

배시셸에서는 앨리어스로 인자를 전달할 수 없다.

배시셸에서 인자를 전달하려면 프로그래밍 기능에서 함수를 사용해야 한다.

함수를 제거하려면 셸을 종료하면 된다.

![image-20240224000448989](.\assets\image-20240224000448989.png)

### 히스토리

![image-20240224000732007](.\assets\image-20240224000732007.png)

![image-20240224000906837](.\assets\image-20240224000906837.png)

## 환경 설정 파일

| 파일                | 기능                                                         |
| ------------------- | ------------------------------------------------------------ |
| /etc/profile        | * 본셸이나 본셸과 호환되는 모든 셸에 공통으로 적용되는 환경 설정 파일이다.<br />* 배시셸의 경우 /etc/bash.bashrc 파일을 실행한다.<br />* 배시셸이 아닌 경우 프롬프트를 #(root 사용자)나 $(일반 사용자)로 설정한다.<br />* /etc/profile.d/*.sh 파일을 실행한다.<br />![image-20240224004049052](.\assets\image-20240224004049052.png) |
| /etc/bash.bashrc    | * 시스템에 공통으로 적용되는 .bashrc 파일이다.<br />* 기본 프롬프트를 설정한다.<br />* sudo 명령과 관련된 힌트를 설정한다.<br />![image-20240224004121885](.\assets\image-20240224004121885.png) |
| /etc/profile.d/*.sh | * 언어나 명령별로 각각 필요한 환경을 설정한다.<br />* 필요시 설정 파일을 추가한다.<br />![image-20240224004157477](.\assets\image-20240224004157477.png) |



### 사용자 환경 설정 파일

| 파일            | 기능                                                         |
| --------------- | ------------------------------------------------------------ |
| ~/.profile      | * .bashrc 파일이 있으면 실행한다.<br />![image-20240224010054991](.\assets\image-20240224010054991.png)<br />* 경로 추가 등 사용자가 정의하는 환경 설정 파일이다.<br />![image-20240224010134583](.\assets\image-20240224010134583.png) |
| ~/.bashrc       | * 히스토리의 크기를 설정한다.<br />![image-20240224005937166](.\assets\image-20240224005937166.png)<br />* 기본 앨리어스나 함수 등을 설정한다.<br />![image-20240224005958215](.\assets\image-20240224005958215.png) |
| ~/.bash_logout  | * 로그아웃 시 실행할 필요가 있는 함수 등을 설정한다.<br />![image-20240224010255848](\assets\image-20240224010255848.png)<br />$SHLVL은 쉘의 깊이. 1은 최상위 레벨을 의미한다. |
| ~/.bash_aliases | * 사용자가 정의한 앨리어스를 별도 파일로 저장한다.           |

# 파일 접근 권한 관리

## 파일 속성

file : 지정한 파일의 종류를 알려준다.

![image-20240224214415357](.\assets\image-20240224214415357.png)

groups : 사용자가 속한 그룹을 알려준다.

![image-20240224214548767](.\assets\image-20240224214548767.png)

## 파일 접근 권한

### 접근 권한 종류

| 권한 | 파일                                                         | 디렉터리                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 읽기 | 파일을 읽거나 복사할 수 있다.                                | ls 명령으로 디렉터리 목록을 볼 수 있다(ls 명령의 옵션은 실행 권한이 있어야 사용할 수 있다). |
| 쓰기 | 파일을 수정, 이동, 삭제할 수 있다(디렉터리에 쓰기 권한이 있어야 한다). | 파일을 생성하거나 삭제할 수 있다.                            |
| 실행 | 파일을 실행할 수 있다(셸 스크립트나 실행 파일의 경우).       | cd 명령을 사용할 수 있다. 파일을 디렉터리로 이동하거나 복사할 수 있다. |

### 접근 권한 표기 방법

rwx rwx rwx

### 접근 권한 변경 명령

chmod : 파일이나 디렉터리의 접근 권한을 변경한다.

* 기호 모드
* 숫자 모드

## 기호를 이용한 파일 접근 권한 변경

| 구분                 | 문자/기호 | 의미                             |
| :------------------- | :-------- | :------------------------------- |
| 사용자 카테고리 문자 | u         | 파일 소유자                      |
|                      | g         | 파일 소유 그룹                   |
|                      | o         | 소유자와 그룹 이외의 기타 사용자 |
|                      | a         | 전체 사용자                      |
| 연산자 기호          | +         | 권한 부여                        |
|                      | -         | 권한 제거                        |
|                      | =         | 접근 권한 설정                   |
| 접근 권한 문자       | r         | 읽기 권한                        |
|                      | w         | 쓰기 권한                        |
|                      | x         | 실행 권한                        |

![image-20240224215704156](.\assets\image-20240224215704156.png)

## 숫자를 이용한 파일 접근 권한 변경

### 숫자로 환산하는 방법

Q. 근데 왜 읽기 쓰기 실행 순으로 권한이 큰건가? 읽기가 가장 권한이 높은 이유는 뭔가?

| 접근권한 | 환산             | 숫자 | 의미             |
| -------- | ---------------- | ---- | ---------------- |
| rwx      | 111 -> 4 + 2 + 1 | 7    | 읽기, 쓰기, 실행 |
| rw-      | 110 -> 4 + 2 + 0 | 6    | 읽기, 쓰기       |
| r-x      | 101 -> 4 + 0 + 1 | 5    | 읽기, 실행       |
| r--      | ...              | 4    | 읽기             |
| -wx      | ...              | 3    | 쓰기, 실행       |
| -w-      | ...              | 2    | 쓰기             |
| --x      | ...              | 1    | 실행             |
| ---      | ...              | 0    | 권한X            |

| 접근 권한 | 숫자 모드 |
| --------- | --------- |
| rwxrwxrwx | 777       |
| rwxr-xr-x | 755       |
| rw-rw-rw- | 666       |

### 숫자 모드를 이용한 접근 권한 변경

![image-20240224220415672](.\assets\image-20240224220415672.png)

## 기본 접근 권한 설정

파일이나 디렉터리를 생성할 때 기본 접근 권한이 자동으로 설정된다.

![image-20240224220528058](.\assets\image-20240224220528058.png)

### 기본 접근 권한 확인 및 변경

umask : 기본 접근 권한을 출력하거나 변경한다.

ex) umask 0002 : -------w- 권한을 부여하지 않겠다. 즉 쓰여진 숫자의 권한을 부여하지 않겠다.

![image-20240224220626705](.\assets\image-20240224220626705.png)

![image-20240224220652904](.\assets\image-20240224220652904.png)

![image-20240224221243474](.\assets\image-20240224221243474.png)

### 마스크 값의 적용 과정

뺄셈 연산(마스크 값 적용에서는 0에서 1을 뺀 경우는 0)

![image-20240225004618906](.\assets\image-20240225004618906.png)

ex) 

최대 권한(파일)                 : rw- rw- rw-

최대 권한(디렉터리)         : rwx rwx rwx

umask 077                        :  ---  rwx  rwx

`---------------------------------`

파일 권한			      rw- --- ---		  

디렉터리 권한                      rwx --- ---

![image-20240225010753957](.\assets\image-20240225010753957.png)

## 특수 접근 권한 설정

맨 앞자리로 특수 접근 권한 설정

* SetUID : 맨 앞자리가 4
* SetGID : 맨 앞자리가 2
* 스티키 비트 : 맨 앞자리가 1

### SetUID

![image-20240225011331461](.\assets\image-20240225011331461.png)

![image-20240225011425222](.\assets\image-20240225011425222.png)

→ 소유자의 실행 권한에 s가 표기된다. 

set.exe 파일을 실행하면 항상 user1의 권한을 가진다.

흔히 사용하는 명령 중에 setUID가 설정된 명령은 passwd다.

![image-20240225011724253](.\assets\image-20240225011724253.png)

passwd 명령은 사용자 계정의 암호를 바꾼다.

계정의 암호가 저장된 /etc/shadow 파일은 root 계정으로만 수정 가능 → 일반 사용자 수정 불가

그러나 passwd 명령에는 SetUID가 설정되어 있기 때문에 root 권한으로 실행되어 /etc/shadow 파일을 수정해 암호를 바꿀 수 있다.

### SetGID

SetGID가 설정된 파일을 실행하면 해당 파일이 실행되는 동안에는 파일 소유 그룹의 권한으로 실행된다.

set.exe 파일에 SetGID를 설정하면 다음과 같이 그룹의 실행 권한에 's'가 표시된다.

![image-20240225012349677](.\assets\image-20240225012349677.png)

### 스티키 비트

스티키 비트는 SetUID, SetGID와는 다른 특징이 있다.

스티키 비트는 디렉터리에 설정하며, 디렉터리에 스티키 비트가 설정되어 있으면 이 디렉터리에는 누구나 파일을 생성할 수 있다.

즉 누구나 자유롭게 사용이 가능하다.

단, 스티키 비트가 디렉터리에 적용되면 디렉토리의 소유자나 파일 소유자 또는 슈퍼유저가 아닌 사용자들은 파일을 삭제하거나 변경할 수 없다. 그렇지만 파일 또는 디렉터리를 누구나 생성이 가능하다. 대표적인 디렉터리가 /tmp 디렉터리이다.

스티키 비트가 설정이 되면 실행 권한에 't'가 표시된다.

![image-20240225013732047](.\assets\image-20240225013732047.png)

# 프로세스 관리

## 프로세스의 개념

### 프로세스의 부모-자식 관계

리눅스 시스템을 부팅할 때 스케줄러가 실행한 프로세스인 systemd와 kthreadd 프로세스를 제외하면 모든 프로세스는 부모 프로세스를 가지고 있다.

자식 프로세스는 할 일이 끝나면 부모 프로세스에 결과를 돌려주고 종료된다.

### 프로세스의 번호

각 프로세스는 고유한 번호를 가지고 있는데 이를 PID라고 한다. 

리눅스가 부팅될 때 PID 1번 systemd 프로세스와 2번 kthreadd 프로세스가 차례로 실행된다.

1번 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스가 되고, 2번 프로세스는 모든 스레드의 부모 프로세스가 된다.

> 전통적으로 유닉스에서 1번 프로세스는 init 프로세스다.
>
> 그러나 우분투의 경우 init의 기능을 systemd로 바꾸었다.
>
> 다만, 이전 시스템과 호환되도록 1번 프로세스의 이름은 init을 유지하고 있다.
>
> init은 systemd의 심벌릭 링크이다.

### 프로세스의 종류

* 데몬 프로세스

  특정 서비스를 제공하기 위해 존재하며 리눅스 커널에 의해 실행된다.

  데몬은 평소에는 대기 상태로 있다가 서비스 요청이 들어오면 서비스를 제공한다.

* 고아 프로세스

  자식 프로세스가 실행 중인데 부모 프로세스가 먼저 종료되면 자식 프로세스는 고아 프로세스가 된다.

  이 경우 1번 프로세스가 고아 프로세스의 새로운 부모 프로세스가 되어 고아 프로세스가 작업을 마치고 종료될 수 있게 한다.

* 좀비 프로세스

  자식 프로세스는 종료될 때 부모 프로세스에 종료 정보를 보내고, 부모 프로세스가 이 정보를 받으면 자식 프로세스는 프로세스 테이블 목록에서 삭제된다.

  자식 프로세스가 실행을 종료했는데도 프로세스 테이블 목록에 남아 있는 경우가 있는데 이러한 자식 프로세스를 좀비 프로세스라고 한다.

  자식 프로세스의 종료 정보를 부모 프로세스가 읽어 가기를 기다리고 있는 것

  좀비 프로세스는 프로세스 목록에 defunct 프로세스라고 나오기도 한다.

  좀비 프로세스는 kill 명령으로 제가할 수 없으며, SIGCHLD 시그널을 부모 프로세스에 보내어 부모 프로세스가 자식 프로세스를 정리하도록 하거나 부모 프로세스 자체를 종료해야만 한다.

  부모 프로세스가 종료되면 좀비 프로세스는 고아 프로세스가 되고, 새로운 부모인 1번 프로세스는 주기적으로 자식 프로세스의 종료 정보를 확인하여 정리한다.

## 프로세스 관리 명령

### 프로세스 목록 확인

**ps : 현재 단말기에서 실행 중인 프로세스에 대한 정보를 출력한다.**

![image-20240225024225445](.\assets\image-20240225024225445.png)

**-f 옵션 : 프로세스의 상세 정보 출력하기**

![image-20240225024306781](.\assets\image-20240225024306781.png)

| 항목  | 의미                                   |
| ----- | -------------------------------------- |
| UID   | 프로세스를 실행한 사용자 ID            |
| PID   | 프로세스 번호                          |
| PPID  | 부모 프로세스 번호                     |
| C     | CPU 사용량(%)                          |
| STIME | 프로세스의 시작 날짜나 시간            |
| TTY   | 프로세스가 실행된 터미널의 종류와 번호 |
| TIME  | 프로세스 실행 시간                     |
| CMD   | 실행되고 있는 프로그램 이름(명령)      |

**a 옵션 : 터미널에서 실행시킨 프로세스 정보 출력하기**

![image-20240225024705339](.\assets\image-20240225024705339.png)

| 문자        | 의미                                  | 비고     |
| ----------- | ------------------------------------- | -------- |
| R           | 실행 중(running)                      |          |
| S           | 인터럽트가 가능한 대기(sleep) 상태    |          |
| T           | 작업 제어에 의해 정지된(stopped) 상태 |          |
| Z           | 좀비 프로세스(defunct)                |          |
| STIME       | 프로세스의 시작 날짜나 시간           |          |
| s           | 세션 리더 프로세스                    | BSD 형식 |
| +           | 포그라운드 프로세스 그룹              | BSD 형식 |
| l(소문자 L) | 멀티스레드                            | BSD 형식 |

**a옵션과 u옵션 : 터미널에서 실행시킨 프로세스 상세 정보 출력하기**

![image-20240225025916580](.\assets\image-20240225025916580.png)

| 항목  | 의미                                 |
| ----- | ------------------------------------ |
| USER  | 사용자 계정 이름                     |
| %CPU  | 퍼센트로 표시한 CPU 사용량           |
| %MEM  | 퍼센트로 표시한 물리적 메모리 사용량 |
| VSZ   | 사용 중인 가상 메모리의 크기(kB)     |
| RSS   | 사용 중인 물리적 메모리의 크기(kB)   |
| START | 프로세스 시작 시간                   |

**-e 옵션과 -f 옵션 : 전체 프로세스 목록 출력하기(유닉스 옵션)**

TTY 값이 ?인 것은 대부분 데몬으로 시스템이 실행한 프로세스다.

![image-20240225031424798](.\assets\image-20240225031424798.png)

스레드는 CMD에 [ ]로 표시하여 구분한다.

![image-20240225031524380](.\assets\image-20240225031524380.png)

**ax 옵션과 aux 옵션 : 전체 프로세스 목록 출력하기(BSD 옵션) : ax 옵션과 aux 옵션**

![image-20240225031842584](.\assets\image-20240225031842584.png)

![image-20240225031900522](.\assets\image-20240225031900522.png)

**-u 옵션 : 특정 사용자의 프로세스 목록 출력하기**

![image-20240225031950004](.\assets\image-20240225031950004.png).

![image-20240225032021907](.\assets\image-20240225032021907.png)

**-p 옵션 : 특정 프로세스 정보 출력하기**

![image-20240225032244705](.\assets\image-20240225032244705.png)

### 특정 프로세스 정보 검색

pgrep : 지정한 패턴과 일치하는 프로세스의 PID를 출력한다.

![image-20240225070533231](.\assets\image-20240225070533231.png)

-x(exact) 옵션 : 패턴과 정확히 일치하는 프로세스의 PID를 출력한다.

![image-20240225070650411](.\assets\image-20240225070650411.png)

-n(newset) 옵션 : 패턴을 포함하고 있는 가장 최근 프로세스의 PID를 출력한다.

![image-20240225071405212](.\assets\image-20240225071405212.png)

-u(uid) [사용자 이름] 옵션 : 특정 사용자에 대한 모든 프로세스 PID를 출력한다.

![image-20240225071818213](.\assets\image-20240225071818213.png)

-l(list-name) : PID와 프로세스 이름을 출력한다.

![image-20240225071945586](.\assets\image-20240225071945586.png)

-t(terminal) [term] : 특정 단말기와 관련된 프로세스의 정보를 출력한다.

![image-20240225072132308](.\assets\image-20240225072132308.png)

차후 과제) pgrep -t 명령으로 /dev 디렉토리에 있는 모든 파일의 프로세스를 확인하는 쉘스크립트 작성 후 실행 및 결과물 올리기

![image-20240225083629169](.\assets\image-20240225083629169.png)

![image-20240225084730297](.\assets\image-20240225084730297.png)

![image-20240225084631255](.\assets\image-20240225084631255.png)

리눅스 시스템에서 동시에 여러 사용자가 접속해있을 때

![image-20240225085011483](.\assets\image-20240225085011483.png)

### 프로세스 종료

응답이 없는 프로세스나 불필요한 프로세스를 강제로 종료하려면 해당 프로세스의 PID를 알아야 한다.

프로세스를 종료하는 데는 kill이나 pkill 명령을 사용한다. 

이 명령들은 프로세스에 시그널을 보내 프로세스를 종료한다.

시그널은 프로세스에 무언가 발생했음을 알리는 간단한 메시지다.

이 메시지에는 무엇이 발생했는지를 나타내는, 미리 정의된 상수를 사용한다.

시그널을 받은 프로세스는 기본적으로 종료된다.

다음은 시그널 목록이다.

![image-20240225085613598](.\assets\image-20240225085613598.png)

| 시그널  | 번호 | 기본 처리      | 의미                                                         |
| ------- | ---- | -------------- | ------------------------------------------------------------ |
| SIGHUP  | 1    | 종료           | 터미널과 연결이 끊겼을 때 발생한다.                          |
| SIGINT  | 2    | 종료           | 인터럽트로 사용자가 Ctrl + c를 입력하면 발생한다.            |
| SIGQUIT | 3    | 종료, 코어덤프 | 종료 신호로 사용자가 Ctrl + \를 입력하면 발생한다.           |
| SIGKILL | 9    | 종료           | 이 시그널을 받은 프로세스는 무시할 수 없으며 강제로 종료된다. |
| SIGALRM | 14   | 종료           | 알람에 의해 발생한다.                                        |
| SIGTERM | 15   | 종료           | kill 명령이 보내는 기본 시그널이다.                          |

kill : 지정한 시그널을 프로세스에게 보낸다.

kill [-시그널] PID...

![image-20240225095601531](.\assets\image-20240225095601531.png)

![image-20240225095616668](.\assets\image-20240225095616668.png)

![image-20240225095655634](.\assets\image-20240225095655634.png)

![image-20240225095712529](.\assets\image-20240225095712529.png)

pkill [명령 이름]

![image-20240225095858795](.\assets\image-20240225095858795.png)

![image-20240225095914009](.\assets\image-20240225095914009.png)

![image-20240225100354759](.\assets\image-20240225100354759.png)

※ 따라해보기

![image-20240225100632811](.\assets\image-20240225100632811.png)

![image-20240225100909845](.\assets\image-20240225100909845.png)

![image-20240225101243516](.\assets\image-20240225101243516.png)

![image-20240225101305612](.\assets\image-20240225101305612.png)

![image-20240225101425352](.\assets\image-20240225101425352.png)

![image-20240225101538945](.\assets\image-20240225101538945.png)

※ 혼자해보기

터미널 1에서 cron 프로세스 검색. 사용자 ID와 터미널 번호가 보이도록.

![image-20240225102007545](.\assets\image-20240225102007545.png)

검색한 결과 중 UID가 root인 프로세스를 종료. 종료되지 않는다면 이유는?

![image-20240225102208385](.\assets\image-20240225102208385.png)

: 시스템 프로세스이므로

### 프로세스 관리 도구

**top 명령**

현재 실행 중인 프로세스의 정보를 주기적으로 출력

| 항목                   | 의미                                                 |
| ---------------------- | ---------------------------------------------------- |
| PID(Process ID)        | 프로세스 ID. 각 프로세스를 구별하는 유일한 숫자.     |
| USER                   | 사용자 계정 - 프로세스를 실행하는 사용자의 이름      |
| PR(Priority)           | 프로세스의 실행 우선순위                             |
| NI(Nice Value)         | Nice 값. 프로세스의 실행 우선순위에 영향을 미치는 값 |
| VIRT(Virtual Memory)   | 프로세스가 사용하는 가상 메모리의 크기               |
| RES(Resident Set Size) | 프로세스가 사용하는 실제 물리 메모리의 크기          |
| SHR(Shared Memory)     | 프로세스가 사용하는 공유 메모리의 크기               |
| %CPU                   | 프로세스가 CPU를 사용하는 비율                       |
| TIME+                  | 프로세스가 CPU를 사용한 누적 시간                    |
| COMMAND                | 프로세스를 실행하는 명령어의 이름                    |

![image-20240225103915648](.\assets\image-20240225103915648.png)

![image-20240225103946113](.\assets\image-20240225103946113.png)

| top 명령의 내부 명령 | 기능                                                   |
| -------------------- | ------------------------------------------------------ |
| Enter, Space Bar     | 화면을 다시 출력한다.                                  |
| h, ?                 | 도움말 화면을 출력한다.                                |
| k                    | 프로세스를 종료한다. 종료할 프로세스의 PID를 물어본다. |
| n                    | 출력하는 프로세스의 개수를 바꾼다.                     |
| u                    | u 사용자에 따라 정렬하여 출력한다.                     |
| M                    | 사용하는 메모리 크기에 따라 정렬하여 출력한다.         |
| p                    | CPU 사용량에 따라 정렬하여 출력한다.                   |
| q                    | top 명령을 종료한다.                                   |

**시스템 감시**

[프로그램 표시] - [시스템 감시]

## 포그라운드/백그라운드 프로세스와 작업 제어

### 포그라운드 작업과 백그라운드 작업

**포그라운드 작업**

![image-20240228195446674](.\assets\image-20240228195446674.png)

**백그라운드 작업**

![image-20240228195513000](.\assets\image-20240228195513000.png)

![image-20240228195658066](.\assets\image-20240228195658066.png)

### 작업 제어

jobs : 백그라운드 작업을 모두 보여준다. 특정 작업 번호를 지정하면 해당 작업의 정보만 보여준다.

![image-20240228195825767](.\assets\image-20240228195825767.png)

**작업 전환하기**

| 명령           | 기능                                                         |
| -------------- | ------------------------------------------------------------ |
| Ctrl + z       | 포그라운드 작업을 중지한다(종료하는 것이 아니라 잠시 중단하는 것) |
| bg % 작업 번호 | 작업 번호가 지시하는 작업을 백그라운드 작업으로 전환한다.    |
| fg % 작업 번호 | 작업 번호가 지시하는 작업을 포그라운드 작업으로 전환한다.    |

![image-20240228200049053](.\assets\image-20240228200049053.png)

![image-20240228200218320](.\assets\image-20240228200218320.png)

**작업 종료하기 : Ctrl + c**

![image-20240228200248701](.\assets\image-20240228200248701.png)

![image-20240228200324722](.\assets\image-20240228200324722.png)

**로그아웃 후에도 백그라운드 작업 계속 실행하기**

nohup : 로그아웃한 후에도 백그라운드 작업을 계속 실행한다.

![image-20240228200604365](.\assets\image-20240228200604365.png)

![image-20240228200830227](.\assets\image-20240228200830227.png)

![image-20240228200904707](.\assets\image-20240228200904707.png)

**※ 따라해보기 : 작업 전환하기**

1. 실습 디렉터리를 만들고 이동한다.

   ![image-20240228201122341](.\assets\image-20240228201122341.png)

2. 다음과 같이 백그라운드 작업을 만든다.

   * 파일을 하나 복사하고 vi 명령을 실행한다.

   * Ctrl + z를 실행하여 vi 작업을 일시 정지한다.

     ![image-20240228201342064](.\assets\image-20240228201342064.png)

3. jobs 명령으로 백그라운드 작업을 확인한다.

   ![image-20240228201419869](.\assets\image-20240228201419869.png)

4. 정지 중인 작업을 fg 명령을 사용하여 복구한다.

   ![image-20240228201542204](.\assets\image-20240228201542204.png)

5. q!로 vi를 종료한다.

   ![image-20240228201518679](.\assets\image-20240228201518679.png)

## 작업 예약

### 정해진 시간에 한 번 실행

at : 예약한 명령을 정해진 시간에 실행한다.

at 명령이 설치되지 않았다면 설치한다.

![image-20240228201715535](.\assets\image-20240228201715535.png)

at 명령의 결과를 파일로 저장하도록 설정하지 않으면 메일로 보내지므로 메일이 설치되어 있어야 한다. 다음과 같이 메일 패키지를 설치한다.

![image-20240228202039623](.\assets\image-20240228202039623.png)

**at 명령 설정하기**

(at 작업 종료는 Ctrl + d이다.)

* at 4pm + 3 days : 지금부터 3일 후 오후 4시에 작업을 수행한다.
* at 10am Jul 31 : 7월 31일 오전 10시에 작업을 수행한다.
* at 1am tomorrow : 내일 오전 1시에 작업을 수행한다.
* at 10:00am today : 오늘 오전 10시에 작업을 수행한다.

![image-20240228202918269](.\assets\image-20240228202918269.png)

![image-20240228203029273](.\assets\image-20240228203029273.png)

**at 작업 목록 확인하기 : -l 옵션과 atq 명령**

![image-20240228203246261](.\assets\image-20240228203246261.png)

atq : 현재 사용자의 등록된 작업 목록을 보여준다. 슈퍼유저일 경우 모든 사용자의 작업 목록을 보여준다.

![image-20240228203405717](.\assets\image-20240228203405717.png)

**at 작업 삭제하기 : -d 옵션과 atrm 명령**

at 명령으로 설정한 작업이 실행되기 전에 삭제하려면 -d 옵션을 사용하고 삭제할 작업 번호를 지정한다. atrm 명령은 at -d와 같은 기능을 수행한다.

atrm : 지정된 작업 번호와 작업을 삭제한다.

![image-20240228203807240](.\assets\image-20240228203807240.png)

![image-20240228203903216](.\assets\image-20240228203903216.png)

**at 명령 사용 제한하기**

시스템 관리자는 일반 사용자들이 at 명령을 사용하도록 허용하거나 사용하지 못하도록 제한할 수 있다.

이와 관련된 파일은 /etc/at.allow 파일어 지정하고, at 명령의 사용이 금지된 사용자들은 /etc/at.deny 파일에 지정한다.

at.deny 파일은 기본적으로 있지만 at.allow 파일은 없으므로 필요할 때에 관리자가 만들어야 한다.

/etc/at.allow 파일과 /etc/at.deny 파일은 기본적으로 있지만 at.allow 파일은 없으므로 필요할 때에 관리자가 만들어야 한다.

/etc/at.allow 파일과 /etc/at.deny 파일에는 사용자 이름을 한 줄에 하나씩만 입력한다. 두 파일의 적용 기준은 다음과 같다.

* /etc/at.allow 파일이 있으면 이 파일에 지정된 사용자만 at 명령을 사용할 수 있다. 이 경우 /etc/at.deny 파일은 무시된다.
* /etc/at.allow 파일이 없으면 /etc/at.deny 파일에 지정된 사용자를 제외한 모든 사용자가 at 명령을 사용할 수 있다.
* 만약 두 파일이 모두 없다면 root만 at 명령을 사용할 수 있다.
* 사용자가 두 파일 모두에 속해 있다면 at 명령을 사용할 수 있다. /etc/at.allow 파일이 적용되기 때문이다.
* /ect/at.deny를 빈 파일로 두면 모든 사용자가 at 명령을 사용할 수 있는데, 이것이 초기 설정이다.

### 정해진 시간에 반복 실행

crontab :  사용자의 crontab 파일을 관리한다.

**crontab 파일 형식**

![image-20240228230345320](.\assets\image-20240228230345320.png)

**crontab 파일 생성하고 편집하기 : crontab -e**

![image-20240228232255819](.\assets\image-20240228232255819.png)

![image-20240228232726189](.\assets\image-20240228232726189.png)

![image-20240228232806585](.\assets\image-20240228232806585.png)

![image-20240228232818803](.\assets\image-20240228232818803.png)

**crontab -l : crontab 파일 내용 확인하기**

![image-20240228232903324](.\assets\image-20240228232903324.png)

**crontab -r : crontab 파일 삭제하기**

![image-20240228232947473](.\assets\image-20240228232947473.png)

**crontab 명령 사용 제한하기**

at 명령과 마찬가지로 crontab 명령도

* /etc/cron.allow 파일과
* /etc/cron.deny 파일로

crontab 명령 사용 권한을 제한할 수 있다.

# 파일 시스템과 디스크 관리

## 리눅스 파일 시스템 종류

### 디스크 기반 파일 시스템

리눅스는 초기에 미닉스의 파일 시스템을 사용했으나 곧 ext 파일 시스템으로 알려진 리눅스 고유의 파일 시스템을 만들어 사용하게 되었다.

현재는 ex4 파일 시스템을 사용 중이다.

### 특수 용도의 가상 파일 시스템

| 파일 시스템 | 기능                                                         |
| ----------- | ------------------------------------------------------------ |
| swap        | 스왑 영역을 관리하기 위한 스왑 파일 시스템이다.              |
| tmpfs       | * Temporary File System으로 메모리에 임시 파일을 저장하기 위한 파일 시스템이며, 시스템이 재시작할 때마다 기존 내용이 없어진다.<br />* /tmp 디렉터리를 예로 들 수 있다. |
| proc        | * proc 파일 시스템으로 /proc 디렉터리이다.<br />* 커널의 현재 상태를 나타내는 파일을 가지고 있다. |
| ramfs       | 램디스크를 지원하는 파일 시스템이다.                         |
| rootfs      | * Root File System으로 / 디렉터리다.<br />* 시스템 초기화 및 관리에 필요한 내용을 관리한다. |

### 현재 시스템이 지원하는 파일 시스템 확인

![image-20240301083652359](.\assets\image-20240301083652359.png)

## 리눅스 파일 시스템 구조

### ex4 파일 시스템의 구조

ex4 파일 시스템은 효율적으로 디스크를 관리하기 위해 저장 장치를 논리적인 블록의 집합(블록 그룹)으로 구분한다.

일반적으로 블록은 4KB이고 실제 크기는 시스템의 설정에 따라 달라질 수 있다. 

블록 그룹의 개수는 장치의 크기를 블록 그룹의 크기로 나눈 값이다.

블록 그룹에는 세 가지 유형이 있다.

* 블록 그룹 0 : 파일 시스템의 첫 번째 블록 그룹으로 특별하게 그룹 0 패딩과 슈퍼 블록, 그룹 디스크립터를 가지고 있다.
* 블록 그룹 a : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩이 없으나 슈퍼 블록과 그룹 디스크립터의 복사본을 가지고 있다.
* 블록 그룹 b : 파일 시스템에서 첫 번째 블록 그룹이 아닌 블록 그룹으로 그룹 0 패딩, 슈퍼 블록, 그룹 디스크립터가 없고 바로 데이터 블록 비트맵으로 시작한다.

![image-20240301180528688](.\assets\image-20240301180528688.png)

**그룹 0 패딩**

블록 그룹 0의 첫 1024B는 특별한 목적으로 사용되는데, x86 부트 섹터와 부가 정보를 저장하기 위한 것이다.

**슈퍼 블록**

슈퍼 블록에는 파일 시스템과 관련된 다양한 정보가 저장된다.

* 전체 inode 개수
* 전체 블록의 개수
* 할당되지 않은 블록(free block)의 개수
* 할당되지 않은 inode(free inode)의 개수
* 첫 번째 데이터 블록의 주소
* 블록의 크기
* 그룹당 블록의 개수
* 마운트 시간
* 파일 시스템의 상태
* 그룹 디스크립터의 크기

**그룹 디스크립터와 GDT 예약 블록**

그룹 디스크립터도 블록 그룹 0에 있는 것으로 슈퍼 블록 다음에 위치한다.

* 블록 비트맵 주소
* inode 비트맵의 주소
* inode 테이블의 주소
* 할당되지 않은 블록의 개수
* 할당되지 않은 inode의 개수
* 디렉터리의 개수
* 블록 비트맵, inode 비트맵 체크섬

**데이터 블록 비트맵과 inode 비트맵**

cf) : 비트맵(영어: BMP file format, DIB file format 또는 bitmap, 문화어: 비트매프, 이진 숫자 배렬표)은 컴퓨터 분야에서 디지털 이미지를 저장하는 데 쓰이는 이미지 파일 포맷 또는 메모리 저장 방식의 한 형태이다.

데이터 블록 비트맵은 블록 그룹에 포함된 데이터 블록의 사용 여부를 확인하는 데 쓰임

inode 비트맵은 inode 테이블의 항목이 사용 중인지를 표시

비트맵에서 각 데이터 블록과 inode 테이블의 항목은 1비트로 표현된다.

**inode 테이블과 데이터 블록**

일반적인 유닉스처럼 리눅스에서도 inode에 파일 정보를 저장한다.

데이터 블록에는 실제 데이터가 저장된다.

일반 파일은 데이터 블록에 파일 내용을 저장하고, 

디렉터리는 데이터 블록에 해당 디렉터리에 있는 파일이나 서브 디렉터리의 정보(이름, inode)를 저장한다.

### inode 구조

![image-20240302004122976](.\assets\image-20240302004122976.png)

inode는 크게 두 부분,

* **파일 정보**를 저장하는 부분과
* 실제 파일 내용이 저장된 **데이터 블록의 주소**를 저장하는 부분으로 나뉜다.

inode에서 데이터 블록의 주소를 저장하는 부분은

* 직접 블록(direct block),
* 간접 블록(indirect block),
* 이중 간접 블록(double indirect block)으로 구분된다.

직접 블록은 데이터 블록에 대한 주소를 직접 가지고 있다.

간접 블록과 이중 간접 블록에는 데이터 블록에 대한 주소를 가지고 있는 블록의 주소가 저장된다.

데이터 블록의 크기는 시스템 설정에 따라 1~8KB 까지 지정할 수 있다.

### 파일 시스템과 디렉터리 계층 구조

실제 파일이 저장된 파일 시스템은 디렉터리 계층 구조에 연결되어야 사용자가 접근하여 사용할 수 있다.

**한 파일 시스템으로 구성하기**

디렉터리 계층 구조에서 보이는 모든 디렉터리와 파일은 하나의 파일 시스템에 둘 수도 있고 여러 파일 시스템에 나누어 구성할 수도 있다.

하나의 파일 시스템으로 구성할 경우 아래와 같이 / 디렉터리에 해당 파일 시스템을 연결한다.

![image-20240302010241406](.\assets\image-20240302010241406.png)

**여러 파일 시스템으로 구성하기**

디렉터리의 계층 구조를 여러 파일 시스템으로 구분하여 구성할 수도 있다.

/ 디렉터리에 연결된 파일 시스템을 루트 파일 시스템이라고 한다.

여러 파일 시스템으로 나누어 디렉터리 계층 구조를 구성할 경우, 일부 파일 시스템에 문제가 생기더라도 다른 파일 시스템은 안전하다.

![image-20240302011447920](.\assets\image-20240302011447920.png)

## 파일 시스템 마운트

### 마운트 포인트

디렉터리 계층 구조에서 각각의 파일 시스템이 연결되는 디렉터리를 마운트 포인트라고 한다.

### 파일 시스템 마운트 설정 파일

리눅스에서 시스템이 부팅될 때 자동으로 파일 시스템이 마운트 되게 하려면 /etc/fstab 파일에 관련 사항을 설정해야 한다.

**/etc/fstab 파일의 기능**

/etc/fstab 파일은 파일 시스템의 마운트 설정 정보를 가지고 있다.

리눅스 시스템은 부팅할 때 이 파일을 읽고 설정 내용에 따라 파일 시스템을 자동으로 마운트하며,

이 파일에 오류가 있으면 시스템 부팅이 중지될 수도 있다.

/etc/fstab 파일에는 파일 시스템의 장치명과 마운트 포인트, 마운트할 때 설정할 옵션을 지정한다.

**/etc/fstab 파일의 구조**

![image-20240302012219324](.\assets\image-20240302012219324.png)

![image-20240302011841452](.\assets\image-20240302011841452.png)

* 장치명 : PARTUUID=cca89262-02
* 마운트 포인트 : /
* 파일 시스템 종류 : ext4
* 옵션 : defaults, noatime
* 덤프 관련 설정 : 0
* 파일 점검 옵션 : 1

1. 장치명

   /dev/sda1과 같이 특정 디스크를 지정하는 것이다.

   앞서 본 파일 시스템 3개가 마운트된 그림을 보면 파일 시스템에 구축된 물리적인 디스크 장치가 3개 있고,

   그 장치의 이름을 첫 번째 항목으로 설정하는 것이다.

   UUID는 시스템의 하드웨어 정보와 시간 정보가 조합되어 랜덤으로 생성되며,

   디스크가 추가될 때 부트 로더가 있는 부트 장치의 이름이 바뀌는 것을 방지하기 위해 사용된다.

2. 마운트 포인트

   앞서 본 파일 시스템 3개가 마운트된 그림을 보면 파일 시스템 3의 마운트 포인트는 /home이 된다.

   마운트 포인트가 /인 것은 / 디렉터리이므로 이는 루트 파일 시스템이라는 뜻이다.

3. 파일 시스템의 종류

   위의 파일 시스템을 보면 첫 번째 파일 시스템은 vfat, 두 번째 파일 시스템은 ex4임을 알 수 있다.

4. 옵션

   이 항목에 올 수 있는 값은 파일 시스템에 따라 다르며 일반적으로 사용하는 옵션은 아래의 표와 같다.

   | 옵션     | 의미                                                         |
   | -------- | ------------------------------------------------------------ |
   | defaults | 일반적인 파일 시스템에 지정하는 속성이다. rw, nouser, auto, exec, suid 속성을 모두 포함한다. |
   | auto     | 부팅 시 자동으로 마운트한다.                                 |
   | exec     | 실행 파일이 실행되는 것을 허용한다.                          |
   | suid     | setuid, setgid의 사용을 허용한다.                            |
   | ro       | 읽기 전용 파일이다.                                          |
   | rw       | 읽기, 쓰기가 가능한 파일 시스템이다.                         |
   | user     | 일반 사용자도 마운트가 가능하다.                             |
   | nouser   | 일반 사용자는 마운트가 불가능하다. root만 마운트할 수 있다.  |
   | noauto   | 부팅 시 자동으로 마운트하지 않는다.                          |
   | noexec   | 실행 파일이 실행되는 것을 허용하지 않는다.                   |
   | nosuid   | setuid, setgid의 사용을 금지한다.                            |
   | usrquota | 사용자별로 디스크 쿼터 설정이 가능하다.                      |
   | grpquota | 그룹별로 디스크 쿼터 설정이 가능하다.                        |

5. 덤프 관련 설정

   0의 경우 dump 명령으로 파일 시스템의 내용이 덤프되지 않는 파일 시스템이고,

   1의 경우 데이터 백업 등을 위해 dump 명령의 사용이 가능한 파일 시스템이다.

6. 파일 점검 옵션

   0은 부팅할 때 fsck 명령으로 파일 시스템을 점검하지 않도록 하는 설정이고

   1은 루트 파일 시스템을,

   2는 루트 파일 시스템 이외의 파일 시스템을 의미한다.

   즉 부팅할 때 0으로 지정된 파일 시스템은 fsck 명령을 실행하지 않으며, 

   다음으로 1번인 루트 파일 시스템이 fsck 명령으로 파일 시스템 점검을 수행하고,

   나머지 2로 설정된 파일 시스템들은 나열된 순서대로 fsck 명령을 사용하여 점검하게 된다.

### 마운트 관련 명령

mount : 파일 시스템을 마운트한다.

umount : 파일 시스템을 언마운트한다.

**mount 명령만 사용하는 경우**

옵션이나 인자를 지정하지 않고 mount 명령을 사용하면 다음과 같이 현재 마운트되어 있는 정보가 출력된다.

![image-20240302014950031](.\assets\image-20240302014950031.png)

mount 명령으로 출력되는 정보는 /etc/mtab 파일 내용과 동일하다.

![image-20240302015124324](.\assets\image-20240302015124324.png)

/etc/mtab 파일에는 현재 시스템에 마운트되어 있는 파일 시스템의 정보가 저장되어 있다.

이 파일은 /proc/mounts에 대한 심볼릭 링크로 읽기 전용 파일이므로 내용을 수정할 수 없다.

**장치 연결하기 : mount**

하드디스크를 디렉터리 계층 구조에 연결할 때는 기본적으로 다음과 같은 형태로 mount 명령을 사용한다.

/dev/sdb1은 하드 디스크 장치의 이름이고 /mnt는 마운트 포인트이다.

![image-20240302015800067](.\assets\image-20240302015800067.png)

이외에 다른 종류의 파일 시스템이나 CD-ROM, USB 메모리 같은 이동식 저장 장치와 윈도 포맷의 디스크 등 다양한 장치를 디렉터리 계층 구조에 연결하려면 mount 명령을 사용한다.

**※ 따라해보기 : 리눅스용 USB 메모리 연결**

USB 메모리를 마운트할 때 고려해야 할 사항은 이 메모리가 리눅스용인지 윈도용인지를 구분하는 것이다.

리눅스용 USB 메모리는 리눅스에서 포맷하고 리눅스 파일 시스템을 생성한 메모리를 의미한다.

1. USB 메모리를 리눅스 시스템에 인식시키기

   USB를 꽂고 mount 명령을 통해 USB 메모리가 추가 됨을 알 수 있다.

   가장 아래의 /dev/sda1이 USB 장치가 추가 됨을 알 수 있다.

   ![image-20240302020527473](.\assets\image-20240302020527473.png)

2. USB 메모리의 장치명 확인하기

   USB의 장치명은 맨 밑의 /dev/sda1 임을 알 수 있다.

   세부 내용은 USB 상태에 따라 다르게 나타날 수 있다.

   아래 USB Type을 보면 Microsoft 즉, 리눅스용이 아닌 윈도용 USB임을 알 수 있다.

![image-20240302020613450](.\assets\image-20240302020613450.png)

![image-20240302020625280](.\assets\image-20240302020625280.png)

3. USB 메모리에 파티션 생성하기

   파티션작업은 일반 하드디스크에서 수행하는 것과 동일하게 fdisk 명령을 사용한다.

   ![image-20240302025339294](.\assets\image-20240302025339294.png)

   m을 입력하여 사용할 수 있는 명령을 알아본다.

   ![image-20240302025412602](.\assets\image-20240302025412602.png)

   새로운 파티션을 생성하려는 것이므로 n을 입력한다.

   n을 입력하면 파티션을 기본(primary) 파티션으로 할 것인지, 확장(extended) 파티션으로 할 것인지 선택해야 한다.

   기본값은 기본(p) 파티션이다.

   ![image-20240302025533281](.\assets\image-20240302025533281.png)

   기본으로 선택하고 파티션 번호를 1로 지정한다.

   ![image-20240302025733775](.\assets\image-20240302025733775.png)

   ![image-20240302025809609](.\assets\image-20240302025809609.png)

   모두 기본값으로 지정하였고 새로운 파티션이 생성되었다.

   p 명령을 사용하여 파티션이 제대로 설정되었는지 확인한다.

   ![image-20240302025901876](.\assets\image-20240302025901876.png)

   w를 입력하여 설정한 파티션 정보를 파티션 테이블에 기록한다.

   파티션 테이블에 기록되면 이전에 있던 정보가 없어진다.

   이제 USB 파티션이 생성되었다.

4. 생성한 파티션 포맷하고 파일 시스템 생성하기

   파일 시스템을 생성하는 데는 mke2fs 명령을 사용한다.

   ![image-20240302030142007](.\assets\image-20240302030142007.png)

5. USB 파일 시스템 마운트하기

   /mnt 디렉터리에 마운트하였다.

   ![image-20240302030249492](.\assets\image-20240302030249492.png)

6. 디렉터리 사용하기

   ![image-20240302030405240](.\assets\image-20240302030405240.png)

   ![image-20240302030512440](.\assets\image-20240302030512440.png)

7. 장치연결 해제하기 : umount

   ![image-20240302030635929](.\assets\image-20240302030635929.png)

   해당 디렉터리를 사용중이므로 마운트 해제가 안된다.

   다른 디렉터리로 이동 후 마운트 해제한다.

   ![image-20240302030710984](.\assets\image-20240302030710984.png)

**※ 따라해보기 : 윈도용 USB 메모리 연결**

1. USB 메모리를 USB 슬롯에 꽂고 리눅스 시스템에 인식시킨다.

2. USB 메모리가 인식되었으면, USB 메모리의 장치명을 확인한다.

   fdisk -l 명령의 실행 결과를 보면 USB 메모리의 장치명은 /dev/sdb1 임을 알 수 있다.

   ![image-20240302030956734](.\assets\image-20240302030956734.png)

3. USB 메모리를 마운트한다.

   fdisk -l의 결과를 보면 포맷이 Microsoft basic data이다.

   윈도의 파일 시스템은 ntfs이므로 ntfs로 지정하여 마운트한다.

   ![image-20240302031334475](.\assets\image-20240302031334475.png)

   ntfs가 아니라는 오류..

   ext4로 변경 후 마운트한다.

   ![image-20240302031407019](.\assets\image-20240302031407019.png)

   순조롭게 잘된다. 이유가 뭔지...

## 디스크 추가 설치

### 가상 머신에 디스크를 추가하는 방법

### 디스크 파티션을 나누는 방법

### 파일 시스템을 생성하는 방법

### 디스크를 마운트하는 방법

### 여러 디스크를 하나의 디스크로 사용하는 방법

## 디스크 관리

### 디스크 사용량 확인

**df : 파일 시스템별 디스크 사용량 확인하기**

df : 디스크의 남은 공간에 대한 정보를 출력한다.

![image-20240302031803441](.\assets\image-20240302031803441.png)

df 명령으로 출력되는 항목은 다음과 같다.

* 파일 시스템 장치명
* 파일 시스템의 전체 용량
* 파일 시스템의 사용량
* 파일 시스템의 사용 가능한 남은 용량
* 퍼센트로 나타낸 사용량
* 마운트 포인트

**-h : 파일 시스템 사용량을 이해하기 쉬운 단위로 표시하기**

![image-20240302031931057](.\assets\image-20240302031931057.png)

**-T : 파일 시스템의 종류 출력하기**

![image-20240302032006717](.\assets\image-20240302032006717.png)

**du : 디렉터리나 사용자별 디스크 사용량 확인하기**

du : 디스크의 사용 공간에 대한 정보를 출력한다.

![image-20240302032238045](.\assets\image-20240302032238045.png)

**-s : 전체 디스크 사용량 출력하기**

![image-20240302032314560](.\assets\image-20240302032314560.png)

**특정 사용자의 디스크 용량 출력**

![image-20240302032407350](.\assets\image-20240302032407350.png)

**※ 따라해보기**

1. 파일 시스템의 디스크 사용량을 MB 단위로 출력한다.

   ![image-20240302032449878](.\assets\image-20240302032449878.png)

2. ext4 파일 시스템의 디스크 사용량을 출력한다.

   ![image-20240302032513686](.\assets\image-20240302032513686.png)

3. 전체 파일 시스템의 디스크 사용량 출력

   -a 옵션을 사용하면 용량이 0인 파일 시스템의 정보도 출력한다.

   크기가 0인 파일 시스템은 대부분 내부 관리용으로 사용된다.

   ![image-20240302032635999](.\assets\image-20240302032635999.png)

4. /usr 디렉터리가 사용하고 있는 디스크 사용량을 출력한다.

   ![image-20240302032731978](.\assets\image-20240302032731978.png)

### 파일 시스템 검사 및 복구

**fsck : 파일 시스템 검사하기**

fsck : 리눅스의 파일 시스템을 검사한다.

* 일반적인 파일 시스템 검사

  ![image-20240302043939959](.\assets\image-20240302043939959.png)

* 파일 시스템 강제 검사

  ![image-20240302043901052](.\assets\image-20240302043901052.png)

* 파일 시스템 종류를 지정한 검사

  ![image-20240302044245453](.\assets\image-20240302044245453.png)

**e2fsck : 파일 시스템 검사하기**

e2fsck : 리눅스의 확장 파일 시스템(ext2, ext3, ext4)을 점검한다.

* 일반적인 파일 시스템으로 검사

  ![image-20240302044410517](.\assets\image-20240302044410517.png)

* 파일 시스템 강제 검사

  ![image-20240302044457149](.\assets\image-20240302044457149.png)

**badblocks : 배드 블록 검사하기**

디스크에 발생하는 심각한 문제 중 하나는 배드 블록으로 인한 데이터 유실이다.

물론 백업이나 이중화 구성 등으로 대비하겠지만 주기적으로 배드 블록을 검사하는 것도 매우 중요하다.

badblocks : 장치의 배드 블록을 검사한다.

**배드 블록 검색하기**

![image-20240302045035208](.\assets\image-20240302045035208.png)

**백업 슈퍼 블록을 이용하여 파일 시스템 복구하기**

* dumpe2fs : 백업 슈퍼 블록의 위치 파악하기

  dumpe2fs : 파일 시스템의 정보를 출력한다.

  ![image-20240302045708503](.\assets\image-20240302045708503.png)

  ![image-20240302045851700](.\assets\image-20240302045851700.png)

* **파일 시스템 복구하기**

  dd : 지정한 블록 크기만큼 파일을 복사한다.

  ex) dd if=/dev/zero of=/dev/sda1 bs=4096 count=20

  여기서 if은 조건문이 아닌 input file의 약자이며 of는 out file의 약자이다.

  /dev/zero는 메모리를 null(혹은 0)로 채울 때 사용하는 파일이다.

  bs는 블록 당 바이트 사이즈를 의미하며

  count는 블록의 수를 의미한다.

  ![image-20240302050502181](.\assets\image-20240302050502181.png)

  이제 /dev/sda1 파일 시스템의 기본 슈퍼 블록이 지워졌다.

  따라서 /dev/sda1 파일 시스템을 마운트하면 오류 메시지가 출력된다.

  ![image-20240302050714945](.\assets\image-20240302050714945.png)

  앞에서 dumpe2fs로 확인한 백업 슈퍼 블록을 이용하여 /dev/sda1 파일 시스템을 복구하려면 다음과 같이 한다.

  ![image-20240302050835818](.\assets\image-20240302050835818.png)

  파일 시스템이 복구되었으므로 정상적으로 마운트가 된다.

  ![image-20240302050934331](.\assets\image-20240302050934331.png)

# 리눅스 부팅과 종료

## 리눅스 시스템의 부팅

리눅스의 부팅은 PC의 전원을 켜는 순간부터 리눅스가 완전히 동작하여 로그인 프롬프트가 출력될 때까지를 말한다.

리눅스 시스템의 부팅 과정은 크게

1. PC 부팅(하드웨어 부팅)과
2. 리눅스 부팅(운영체제 부팅)으로 나뉜다.

리눅스는 부팅 과정을 다음과 같은 단계로 나누어 관리한다.

![image-20240302051613658](.\assets\image-20240302051613658.png)

### 1. 바이오스 단계

PC 전원 스위치를 켜면 제일 먼저 바이오스(BIOS, Basic Input Output System)가 동작한다.

바이오스는 보통 ROM에 저장되어 있어 ROM-BIOS라고 부른다.

바이오스는 PC에 장착된 기본적인 하드웨어(키보드, 디스크 등)의 상태를 확인한 후 부팅 장치를 선택하여 부팅 디스크의 첫 섹터에 512B를 로딩한다.

이 512B를 마스터 부트 레코드(MBR, Master Boot Record)라 하며 여기에는 디스크의 어느 파티션에 2차 부팅 프로그램(부트 로더)이 있는지에 대한 정보가 저장되어 있다.

메모리에 로딩된 MBR은 부트 로더를 찾아 메모리에 로딩하는 작업까지 수행한다.

이를 정리하면 아래와 같다.

![image-20240302052336045](.\assets\image-20240302052336045.png)

### 2. 부트 로더 단계

바이오스 단계에서 MBR은 부트 로더를 찾아 메모리에 로딩한다.

부팅할 때 GRUB 메뉴를 출력하려면 /etc/default/grub 파일을 수정해야 한다.

### 3. 커널 초기화 단계

1. 부트 로더에 의해 메모리에 로딩된 커널은 가장 먼저 시스템에 연결된 메모리, 디스크, 키보드, 마우스 등의 장치를 검사한다.

리눅스를 처음 시스템에 설치할 때 사용 가능한 하드웨어의 정보를 미리 확인했다가, 부팅할 때 이러한 장치들이 사용 가능한 상태로 유지되고 있는지 확인하는 것이다.

2. 장치 검사 등 기본적인 초기화 과정이 끝나면 커널은 일반적으로 프로세스를 만드는 방식인 fork를 사용하지 않고 프로세스와 스레드를 생성한다.

   이 프로세스들은 메모리 관리 같은 커널의 여러 가지 동작을 수행한다.

   이 프로세스들은 일반적인 프로세드와 구분되도록 대괄호([ ])로 표시되며, 주로 PID 번호가 낮게 배정되어 있다.

   ![image-20240302185906985](.\assets\image-20240302185906985.png)

3. 커널 프로세스가 생성되면 커널이 수행할 작업이 끝난다.

   이제 systemd 서비스를 동작시킨다.

### 4. systemd 서비스 단계

systemd 서비스 단계에 이르면 리눅스가 본격적으로 동작하기 시작한 것이다.

우분투에서 systemd 서비스는 기존의 init 스크립트를 대체한 것으로 다양한 서비스를 동작시킨다.

부팅할 때 메시지가 출력되게 하려면 /etc/default/grub 파일의 GRUB_CMDLINE_LINUX_DEFAULT="quiet splash" 에서 quiet를 삭제하고 sudo update-grup를 실행하여 변경된 내용을 적용하면 된다.

이 메시지는 부팅 후 demesg 명령이나 more /var/log/boot.log 명령으로 확인할 수 있다.

cf) : dmesg - print or control the kernel ring buffer

전통적으로 유닉스에서는 init 프로세스가 서비스를 실행했다. 따라서 init 프로세스는 처음 생성된 프로세스로서 PID가 1번이다. 우분투에서는 init 대신 시스템과 서비스 관리자로 systemd를 사용하고 있다.

![image-20240304005147128](.\assets\image-20240304005147128.png)

1번 프로세스가 여전히 init인 것처럼 보이지만 사실은 systemd 파일의 심볼릭 링크다.

![image-20240304005228498](.\assets\image-20240304005228498.png)

## systemd 서비스

systemd는 리눅스의 시스템과 서버의 관리자로서 유닉스의 init 프로세스가 하던 작업을 대신 수행한다.

즉 systemd는

* 다양한 서비스 데몬을 시작하고,
* 프로세스들의 상태를 유지하며,
* 시스템의 상태를 관리한다.

우선 init 프로세스의 동작을 살펴본다.

### init 프로세스와 런레벨

기존에는 init 프로세스가 스크립트를 순차적으로 실행하여 다른 프로세스를 동작시켰다. 

현재 init 서비스는 systemd 서비스로 대체되었다. 

![image-20240304005535610](.\assets\image-20240304005535610.png)

전통적으로 init와 관련된 스크립트 파일은 /etc/init.d 디렉터리에 있으며 아직 일부 서비스의 스크립트 파일이 남아 있다.

init 프로세스는 없어졌지만, 전통적으로 사용해온 init 프로세스의 런레벨 개념은 이해할 필요가 있다.

init은 시스템 상태를 7개로 정의하여 구분하고 각 상태에 따라 셸 스크립트를 실행하는데, 이러한 상태를 런레벨이라 한다.

![image-20240304005940330](.\assets\image-20240304005940330.png)

각 런레벨의 기능은 다음과 같다.

* 0
  * Power Off
  * 시스템 종료를 의미한다.
  * 기본값으로 설정 불가
* 1
  * Rescue
  * 시스템 복구 모드이며 Windows의 안전모드를 생각할 수 있다.
  * 기본적으로 관리자 권한을 얻어 수행된다.
  * 로그인 과정 없이 root 계정으로 로그온
  * 네트워크, 서버, 파일 공유 등과 같은 서비스 사용X
  * 시스템 점검/복구, root 계정 패스워드 초기화 등에 사용
    (즉, 시스템 관리 목적으로 사용)
* 2
  * Multi-User
  * 네트워크를 사용하지 않는 다중 사용자 모드
  * 여러 계정으로 로그온할 수 있다.
  * 네트워크를 사용하지 않는 런레벨 3과 동일하다
* 3
  * Multi-User
  * 네트워크를 지원하는 CLI(텍스트 기반) 다중 사용자 모드이다.
  * 여러 계정으로 로그온할 수 있다.
* 4
  * Multi-User
  * 사용하지 않음(사용자가 정의해서 사용은 가능)
* 5
  * Graphical
  * X Window를 사용하는 GUI(그래픽 모드) 다중 사용자 모드이다.
* 6
  * Reboot
  * 시스템 재시작을 의미한다.
  * 기본값으로 설정 불가

### systemd 기본 개념

systemd는 init 방식에 비해 다음과 같은 장점이 있다.

* 소켓 기반으로 동작하여 inetd와 호환성을 유지한다.
* 셸과 독립적으로 부팅이 가능하다.
* 마운트 제어가 가능하다
* fsck 제어가 가능하다.
* 시스템 상태에 대한 스냅숏을 유지한다.
* 서비스에 시그널을 전달할 수 있다.
* 셧다운 전에 사용자 세션의 안전한 종료가 가능하다.

**systemd 유닛**

systemd는 전체 시스템을 시작하고 관리하는 데 유닛이라 부르는 구성 요소를 사용한다.

systemd는 아래의 표와 같은 유닛들을 구분하여 관리한다.

systemd는 관리 대상의 이름을 '서비스명.유닛 종류'의 형태로 관리한다.

각 유닛은 같은 이름과 종류로 구성된 설정 파일과 동일한 이름을 사용한다. 
예를 들어 atd.service 유닛의 경우 같은 이름의 설정 파일을 가지며, atd 데몬을 관리한다.

| 유닛      | 기능                                                         | 예                                |
| --------- | ------------------------------------------------------------ | --------------------------------- |
| service   | 시스템 서비스 유닛으로 데몬을 시작, 종료, 재시작, 로드한다.  | atd.service                       |
| target    | 유닛을 그루핑한다( ex) multi-user.target → 런레벨 5에 해당하는 유닛 ) | basic.target                      |
| automount | 디렉터리 계층 구조에서 자동 마운트 포인트를 관리한다.        | proc-sys-fs-binfmt_misc.automount |
| device    | 리눅스 장치 트리에 있는 장치를 관리한다.                     | sys-module-fuse.device            |
| mount     | 디렉터리 계층 구조의 마운트 포인트를 관리한다.               | boot.mount                        |
| path      | 파일 시스템의 파일이나 디렉터리 등 경로를 관리한다.          | cups.path                         |
| scope     | 외부에서 생성된 프로세스를 관리한다.                         | init.scope                        |
| slice     | 시스템의 프로세스를 계층적으로 관리한다                      | system-getty.slice                |
| socket    | 소켓을 관리하는 유닛으로 AF_INET, AF_INET6, AF_UNIX 소켓 스트림과 데이터그램, FIFO를 지원한다. | dbus.socket                       |
| swap      | 스왑 장치를 관리한다.                                        | dev-mapper-fedora\x2dswap.swap    |
| timer     | 타이머와 관련된 기능을 관리한다.                             | dnf-makecache.timer               |

### systemd 관련 명령

systemd 기반으로 서비스를 시작하거나 종료할 때 사용하는 명령은 systemctl이다.

systemctl 명령에서 유닛을 지정할 때 유닛의 종류는 제외해도 된다.

예를 들면 sshd.service를 지정할 때 sshd만 지정해도 된다.

systemctl : systemd 서비스를 제어한다.

**동작 중인 유닛 출력하기**

옵션이나 명령 없이 systemctl 명령만 사용하면 현재 동작 중인 유닛이 출력된다.

**전체 유닛 출력하기 -a**

![image-20240304011911825](.\assets\image-20240304011911825.png)

**특정 유닛 출력하기 -t**

![image-20240304011924571](.\assets\image-20240304011924571.png)

**유닛 서비스 시작하기 : start**

![image-20240304012122913](.\assets\image-20240304012122913.png)

**유닛의 상태 확인하기 : status**

![image-20240304012054224](.\assets\image-20240304012054224.png)

**유닛 서비스 정지하기 : stop**

![image-20240304012204528](.\assets\image-20240304012204528.png)

### systemd와 런레벨

앞서 본 런레벨은 현재 시스템의 상태를 나타내는 한 자리 숫자(문자 S, s 포함)다.

이에 대응하는 systemd의 target 유닛은 아래의 표와 같이 제공된다.

이 파일들은 /usr/lib/systemd/system 디렉터리에 있다.

아래 표를 보면 각 런레벨에 해당하는 runlevelX.target이 제공되는데, 이는 런레벨에 익숙한 사용자의 편의를 위한 심볼릭 링크다.

![image-20240304012742621](.\assets\image-20240304012742621.png)

**현재 target과 런레벨 확인하기**

![image-20240304012823264](.\assets\image-20240304012823264.png)

런레벨을 확인하려면 runlevel 명령을 사용한다. 출력된 'N 5'는 런레벨 5로 부팅했다는 의미다.

![image-20240304012900226](.\assets\image-20240304012900226.png)

**기본 target 지정하기**

부팅할 때 동작하는 기본 런레벨은 예전에는 /etc/inittab 파일에 지정했으나 지금은 default.target이 가리키는 target 유닛으로 바뀌었다.

default.target이 가리키는 기본 target은 다음과 같은 형식으로 지정한다.

```
systemctl set-default <name of target>.target
```

이 명령은 /etc/systemd/system 디렉터리 아래의 심볼릭 링크인 default.target이 가리키는 target 파일을 변경한다.

예를 들어 현재 target인 graphical.target에서 multi-user.target으로 바꾸려면 다음과 같이 한다.

![image-20240304013344952](.\assets\image-20240304013344952.png)

당연한 말이지만 런레벨 0이나, 런레벨 6에 해당하는 target을 기본으로 지정하면 안 된다(시스템에 치명적일 수도 있다).

다시 기본 target을 graphical.target으로 변경한다.

![image-20240304013535901](.\assets\image-20240304013535901.png)

**target 변경하기**

systemd에서 런레벨을 변경하는 것도 isolate 명령으로 간단히 해결할 수 있다.

예를 들어 multi-user.target(런레벨 3)으로 변경하려면 다음 명령 중 하나를 입력한다.

```
systemctl isolate multi-user
```

```
systemctl isolate runlevel3
```

graphical.target(런레벨 5)으로 변경하려면 다음 명령 중 하나를 사용한다.

```
systemctl isolate graphical
```

```
systemctl isolate runlevel5
```

**런레벨 변경하기 : telinit, init**

init은 1번 프로세스의 이름이기도 하지만 init 프로세스의 런레벨을 바꿀 때 사용하기도 한다.

![image-20240304013923769](.\assets\image-20240304013923769.png)

이는 기존의 init 프로세스에 익숙한 사용자들을 위해 명령을 유지하고 있는 것으로 예를 들어 init 3을 입력하면 런레벨 3으로 변경된다.

런레벨을 바꾸는 명령으로 telinit도 있다. telinit은 systemctl에 대한 심볼릭 링크다.

![image-20240304014100840](.\assets\image-20240304014100840.png)

telinit 명령을 실행하면 init 명령과 같은 결과가 출력된다.

![image-20240304014133448](.\assets\image-20240304014133448.png)

**단일 사용자 모드로 전환하기 : rescue.target(런레벨 1)**

시스템에 문제가 있을 경우 시스템을 rescue.target 유닛(런레벨 1, 런레벨 S)으로 변경하여 점검해야 한다.

이는 윈도의 안전모드와 같은 것으로, 다중 사용자 모드에서 시스템 관리자만 사용할 수 있는 단일 사용자 모드로 전환하는 것이다.

따라서 이 모드로 변환하기 전에 다른 사용자들은 로그아웃을 해야 한다.

다음 명령 중 하나를 사용하면 단일 사용자 모드로 전환할 수 있다.

```
systemctl isolate rescue
```

```
systemctl isolate runlevel1
```

```
init
```

```
telinit S
```

단일 사용자 모드로 전환하면 그래픽 환경이었던 리눅스가 텍스트 모드로 바뀐다.

단일 사용자 모드에서는 바로 root 암호를 입력하여 시스템과 관련된 점검 작업을 하고 다시 다중 사용자 모드로 전환한다.

단일 사용자 모드에서 다중 사용자 모드로 전환하려면 reboot 명령이나 systemctl default 명령을 사용한다.

## 리눅스 시스템의 종료

### shutdown 명령

shutdown : 리눅스를 종료한다.

**시스템 즉시 종료**

-h 옵션을 주면 halt 상태로 이동한다.

cf) : halt 상태 :  모든 프로세스는 꺼지지만 시스템 전원은 차단되지 않음

```
sudo shutdown -h now
```

**셧다운 알림 메시지 보내고 종료**

현재 시스템을 사용 중인 사용자들이 있다면 시스템이 종료된다는 메시지를 보내어 작업을 저장하고 정리할 시간을 주어야 한다.

시스템을 종료할 때 shutdown 명령으로 메시지를 보낼 수 있다.

```
sudo shutdown -h +2 "System is going down in 2 min"
```

**시스템 재시작하기**

```
sudo shutdown -r +3
```

**명령 취소하기**

```
sudo shutdown -c
```

**메시지만 보내기**

실제로 shutdown 명령을 실행하지는 않고 사용자들에게 메시지만 보내려면 -k 옵션을 사용한다.

```
sudo shutdown -k 2
```

### 런레벨 변경

**런레벨 변경하기**

시스템 종료하기

```
sudo init 0
```

시스템 재시작하기

```
sudo init 6
```

**systemd로 종료하기**

```
sudo systemctl isolate poweroff.target
```

```
sudo systemctl isolate runlevel0.target
```

**systemd로 재시작하기**

```
sudo systemctl isolate reboot.target
```

```
sudo systemctl isolate runlevel6.target
```

## 데몬 프로세스

데몬은 리눅스의 백그라운드에서 동작하며 특정한 서비스를 제공하는 프로세스를 의미한다.

리눅스 시스템에서 동작하는 웹 서버나 데이터베이스 서버, 원격 접속 서버 등 각종 서비스를 제공하는 프로세스가 데몬이다.

### 데몬의 동작 방식

데몬은 두 가지 동작 방식,

* 데몬 혼자서 스스로 동작하는 독자형과
* 데몬을 관리하는 슈퍼데몬에 의해 동작하는 방식이 있다.

독자형의 경우 시스템의 백그라운드에서 항상 동작하고 있는데, 자주 호출되는 데몬이 아니라면 시스템의 자원을 낭비할 우려가 있다.

슈퍼데몬에 의한 동작 방식은, 평소에는 슈퍼데몬만 동작하다가 서비스 요청이 오면 슈퍼데몬이 해당 데몬을 동작시키는 것이다.

독자형보다는 서비스 응답 시간이 길지만 자원을 효율적으로 사용한다는 장점이 있다(trade off).

### 슈퍼데몬















# 보충

## 리다이렉션

2>&1
